//go:build linux
// +build linux

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by counterfeiter. DO NOT EDIT.
package runnerfakes

import (
	"sync"

	"github.com/opencontainers/runc/libcontainer/configs"
	specs "github.com/opencontainers/runtime-spec/specs-go"
	"sigs.k8s.io/security-profiles-operator/internal/pkg/cli/command"
)

type FakeImpl struct {
	CommandRunStub        func(*command.Command) (uint32, error)
	commandRunMutex       sync.RWMutex
	commandRunArgsForCall []struct {
		arg1 *command.Command
	}
	commandRunReturns struct {
		result1 uint32
		result2 error
	}
	commandRunReturnsOnCall map[int]struct {
		result1 uint32
		result2 error
	}
	CommandWaitStub        func(*command.Command) error
	commandWaitMutex       sync.RWMutex
	commandWaitArgsForCall []struct {
		arg1 *command.Command
	}
	commandWaitReturns struct {
		result1 error
	}
	commandWaitReturnsOnCall map[int]struct {
		result1 error
	}
	InitSeccompStub        func(*configs.Seccomp) (int, error)
	initSeccompMutex       sync.RWMutex
	initSeccompArgsForCall []struct {
		arg1 *configs.Seccomp
	}
	initSeccompReturns struct {
		result1 int
		result2 error
	}
	initSeccompReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	JSONMarshalStub        func(any) ([]byte, error)
	jSONMarshalMutex       sync.RWMutex
	jSONMarshalArgsForCall []struct {
		arg1 any
	}
	jSONMarshalReturns struct {
		result1 []byte
		result2 error
	}
	jSONMarshalReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	JSONUnmarshalStub        func([]byte, any) error
	jSONUnmarshalMutex       sync.RWMutex
	jSONUnmarshalArgsForCall []struct {
		arg1 []byte
		arg2 any
	}
	jSONUnmarshalReturns struct {
		result1 error
	}
	jSONUnmarshalReturnsOnCall map[int]struct {
		result1 error
	}
	ReadFileStub        func(string) ([]byte, error)
	readFileMutex       sync.RWMutex
	readFileArgsForCall []struct {
		arg1 string
	}
	readFileReturns struct {
		result1 []byte
		result2 error
	}
	readFileReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	SetupSeccompStub        func(*specs.LinuxSeccomp) (*configs.Seccomp, error)
	setupSeccompMutex       sync.RWMutex
	setupSeccompArgsForCall []struct {
		arg1 *specs.LinuxSeccomp
	}
	setupSeccompReturns struct {
		result1 *configs.Seccomp
		result2 error
	}
	setupSeccompReturnsOnCall map[int]struct {
		result1 *configs.Seccomp
		result2 error
	}
	YamlUnmarshalStub        func([]byte, interface{}) error
	yamlUnmarshalMutex       sync.RWMutex
	yamlUnmarshalArgsForCall []struct {
		arg1 []byte
		arg2 interface{}
	}
	yamlUnmarshalReturns struct {
		result1 error
	}
	yamlUnmarshalReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeImpl) CommandRun(arg1 *command.Command) (uint32, error) {
	fake.commandRunMutex.Lock()
	ret, specificReturn := fake.commandRunReturnsOnCall[len(fake.commandRunArgsForCall)]
	fake.commandRunArgsForCall = append(fake.commandRunArgsForCall, struct {
		arg1 *command.Command
	}{arg1})
	stub := fake.CommandRunStub
	fakeReturns := fake.commandRunReturns
	fake.recordInvocation("CommandRun", []interface{}{arg1})
	fake.commandRunMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) CommandRunCallCount() int {
	fake.commandRunMutex.RLock()
	defer fake.commandRunMutex.RUnlock()
	return len(fake.commandRunArgsForCall)
}

func (fake *FakeImpl) CommandRunCalls(stub func(*command.Command) (uint32, error)) {
	fake.commandRunMutex.Lock()
	defer fake.commandRunMutex.Unlock()
	fake.CommandRunStub = stub
}

func (fake *FakeImpl) CommandRunArgsForCall(i int) *command.Command {
	fake.commandRunMutex.RLock()
	defer fake.commandRunMutex.RUnlock()
	argsForCall := fake.commandRunArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) CommandRunReturns(result1 uint32, result2 error) {
	fake.commandRunMutex.Lock()
	defer fake.commandRunMutex.Unlock()
	fake.CommandRunStub = nil
	fake.commandRunReturns = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) CommandRunReturnsOnCall(i int, result1 uint32, result2 error) {
	fake.commandRunMutex.Lock()
	defer fake.commandRunMutex.Unlock()
	fake.CommandRunStub = nil
	if fake.commandRunReturnsOnCall == nil {
		fake.commandRunReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 error
		})
	}
	fake.commandRunReturnsOnCall[i] = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) CommandWait(arg1 *command.Command) error {
	fake.commandWaitMutex.Lock()
	ret, specificReturn := fake.commandWaitReturnsOnCall[len(fake.commandWaitArgsForCall)]
	fake.commandWaitArgsForCall = append(fake.commandWaitArgsForCall, struct {
		arg1 *command.Command
	}{arg1})
	stub := fake.CommandWaitStub
	fakeReturns := fake.commandWaitReturns
	fake.recordInvocation("CommandWait", []interface{}{arg1})
	fake.commandWaitMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) CommandWaitCallCount() int {
	fake.commandWaitMutex.RLock()
	defer fake.commandWaitMutex.RUnlock()
	return len(fake.commandWaitArgsForCall)
}

func (fake *FakeImpl) CommandWaitCalls(stub func(*command.Command) error) {
	fake.commandWaitMutex.Lock()
	defer fake.commandWaitMutex.Unlock()
	fake.CommandWaitStub = stub
}

func (fake *FakeImpl) CommandWaitArgsForCall(i int) *command.Command {
	fake.commandWaitMutex.RLock()
	defer fake.commandWaitMutex.RUnlock()
	argsForCall := fake.commandWaitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) CommandWaitReturns(result1 error) {
	fake.commandWaitMutex.Lock()
	defer fake.commandWaitMutex.Unlock()
	fake.CommandWaitStub = nil
	fake.commandWaitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) CommandWaitReturnsOnCall(i int, result1 error) {
	fake.commandWaitMutex.Lock()
	defer fake.commandWaitMutex.Unlock()
	fake.CommandWaitStub = nil
	if fake.commandWaitReturnsOnCall == nil {
		fake.commandWaitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.commandWaitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) InitSeccomp(arg1 *configs.Seccomp) (int, error) {
	fake.initSeccompMutex.Lock()
	ret, specificReturn := fake.initSeccompReturnsOnCall[len(fake.initSeccompArgsForCall)]
	fake.initSeccompArgsForCall = append(fake.initSeccompArgsForCall, struct {
		arg1 *configs.Seccomp
	}{arg1})
	stub := fake.InitSeccompStub
	fakeReturns := fake.initSeccompReturns
	fake.recordInvocation("InitSeccomp", []interface{}{arg1})
	fake.initSeccompMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) InitSeccompCallCount() int {
	fake.initSeccompMutex.RLock()
	defer fake.initSeccompMutex.RUnlock()
	return len(fake.initSeccompArgsForCall)
}

func (fake *FakeImpl) InitSeccompCalls(stub func(*configs.Seccomp) (int, error)) {
	fake.initSeccompMutex.Lock()
	defer fake.initSeccompMutex.Unlock()
	fake.InitSeccompStub = stub
}

func (fake *FakeImpl) InitSeccompArgsForCall(i int) *configs.Seccomp {
	fake.initSeccompMutex.RLock()
	defer fake.initSeccompMutex.RUnlock()
	argsForCall := fake.initSeccompArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) InitSeccompReturns(result1 int, result2 error) {
	fake.initSeccompMutex.Lock()
	defer fake.initSeccompMutex.Unlock()
	fake.InitSeccompStub = nil
	fake.initSeccompReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) InitSeccompReturnsOnCall(i int, result1 int, result2 error) {
	fake.initSeccompMutex.Lock()
	defer fake.initSeccompMutex.Unlock()
	fake.InitSeccompStub = nil
	if fake.initSeccompReturnsOnCall == nil {
		fake.initSeccompReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.initSeccompReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) JSONMarshal(arg1 any) ([]byte, error) {
	fake.jSONMarshalMutex.Lock()
	ret, specificReturn := fake.jSONMarshalReturnsOnCall[len(fake.jSONMarshalArgsForCall)]
	fake.jSONMarshalArgsForCall = append(fake.jSONMarshalArgsForCall, struct {
		arg1 any
	}{arg1})
	stub := fake.JSONMarshalStub
	fakeReturns := fake.jSONMarshalReturns
	fake.recordInvocation("JSONMarshal", []interface{}{arg1})
	fake.jSONMarshalMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) JSONMarshalCallCount() int {
	fake.jSONMarshalMutex.RLock()
	defer fake.jSONMarshalMutex.RUnlock()
	return len(fake.jSONMarshalArgsForCall)
}

func (fake *FakeImpl) JSONMarshalCalls(stub func(any) ([]byte, error)) {
	fake.jSONMarshalMutex.Lock()
	defer fake.jSONMarshalMutex.Unlock()
	fake.JSONMarshalStub = stub
}

func (fake *FakeImpl) JSONMarshalArgsForCall(i int) any {
	fake.jSONMarshalMutex.RLock()
	defer fake.jSONMarshalMutex.RUnlock()
	argsForCall := fake.jSONMarshalArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) JSONMarshalReturns(result1 []byte, result2 error) {
	fake.jSONMarshalMutex.Lock()
	defer fake.jSONMarshalMutex.Unlock()
	fake.JSONMarshalStub = nil
	fake.jSONMarshalReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) JSONMarshalReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.jSONMarshalMutex.Lock()
	defer fake.jSONMarshalMutex.Unlock()
	fake.JSONMarshalStub = nil
	if fake.jSONMarshalReturnsOnCall == nil {
		fake.jSONMarshalReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.jSONMarshalReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) JSONUnmarshal(arg1 []byte, arg2 any) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.jSONUnmarshalMutex.Lock()
	ret, specificReturn := fake.jSONUnmarshalReturnsOnCall[len(fake.jSONUnmarshalArgsForCall)]
	fake.jSONUnmarshalArgsForCall = append(fake.jSONUnmarshalArgsForCall, struct {
		arg1 []byte
		arg2 any
	}{arg1Copy, arg2})
	stub := fake.JSONUnmarshalStub
	fakeReturns := fake.jSONUnmarshalReturns
	fake.recordInvocation("JSONUnmarshal", []interface{}{arg1Copy, arg2})
	fake.jSONUnmarshalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) JSONUnmarshalCallCount() int {
	fake.jSONUnmarshalMutex.RLock()
	defer fake.jSONUnmarshalMutex.RUnlock()
	return len(fake.jSONUnmarshalArgsForCall)
}

func (fake *FakeImpl) JSONUnmarshalCalls(stub func([]byte, any) error) {
	fake.jSONUnmarshalMutex.Lock()
	defer fake.jSONUnmarshalMutex.Unlock()
	fake.JSONUnmarshalStub = stub
}

func (fake *FakeImpl) JSONUnmarshalArgsForCall(i int) ([]byte, any) {
	fake.jSONUnmarshalMutex.RLock()
	defer fake.jSONUnmarshalMutex.RUnlock()
	argsForCall := fake.jSONUnmarshalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) JSONUnmarshalReturns(result1 error) {
	fake.jSONUnmarshalMutex.Lock()
	defer fake.jSONUnmarshalMutex.Unlock()
	fake.JSONUnmarshalStub = nil
	fake.jSONUnmarshalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) JSONUnmarshalReturnsOnCall(i int, result1 error) {
	fake.jSONUnmarshalMutex.Lock()
	defer fake.jSONUnmarshalMutex.Unlock()
	fake.JSONUnmarshalStub = nil
	if fake.jSONUnmarshalReturnsOnCall == nil {
		fake.jSONUnmarshalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.jSONUnmarshalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) ReadFile(arg1 string) ([]byte, error) {
	fake.readFileMutex.Lock()
	ret, specificReturn := fake.readFileReturnsOnCall[len(fake.readFileArgsForCall)]
	fake.readFileArgsForCall = append(fake.readFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadFileStub
	fakeReturns := fake.readFileReturns
	fake.recordInvocation("ReadFile", []interface{}{arg1})
	fake.readFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ReadFileCallCount() int {
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	return len(fake.readFileArgsForCall)
}

func (fake *FakeImpl) ReadFileCalls(stub func(string) ([]byte, error)) {
	fake.readFileMutex.Lock()
	defer fake.readFileMutex.Unlock()
	fake.ReadFileStub = stub
}

func (fake *FakeImpl) ReadFileArgsForCall(i int) string {
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	argsForCall := fake.readFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) ReadFileReturns(result1 []byte, result2 error) {
	fake.readFileMutex.Lock()
	defer fake.readFileMutex.Unlock()
	fake.ReadFileStub = nil
	fake.readFileReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ReadFileReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.readFileMutex.Lock()
	defer fake.readFileMutex.Unlock()
	fake.ReadFileStub = nil
	if fake.readFileReturnsOnCall == nil {
		fake.readFileReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.readFileReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) SetupSeccomp(arg1 *specs.LinuxSeccomp) (*configs.Seccomp, error) {
	fake.setupSeccompMutex.Lock()
	ret, specificReturn := fake.setupSeccompReturnsOnCall[len(fake.setupSeccompArgsForCall)]
	fake.setupSeccompArgsForCall = append(fake.setupSeccompArgsForCall, struct {
		arg1 *specs.LinuxSeccomp
	}{arg1})
	stub := fake.SetupSeccompStub
	fakeReturns := fake.setupSeccompReturns
	fake.recordInvocation("SetupSeccomp", []interface{}{arg1})
	fake.setupSeccompMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) SetupSeccompCallCount() int {
	fake.setupSeccompMutex.RLock()
	defer fake.setupSeccompMutex.RUnlock()
	return len(fake.setupSeccompArgsForCall)
}

func (fake *FakeImpl) SetupSeccompCalls(stub func(*specs.LinuxSeccomp) (*configs.Seccomp, error)) {
	fake.setupSeccompMutex.Lock()
	defer fake.setupSeccompMutex.Unlock()
	fake.SetupSeccompStub = stub
}

func (fake *FakeImpl) SetupSeccompArgsForCall(i int) *specs.LinuxSeccomp {
	fake.setupSeccompMutex.RLock()
	defer fake.setupSeccompMutex.RUnlock()
	argsForCall := fake.setupSeccompArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) SetupSeccompReturns(result1 *configs.Seccomp, result2 error) {
	fake.setupSeccompMutex.Lock()
	defer fake.setupSeccompMutex.Unlock()
	fake.SetupSeccompStub = nil
	fake.setupSeccompReturns = struct {
		result1 *configs.Seccomp
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) SetupSeccompReturnsOnCall(i int, result1 *configs.Seccomp, result2 error) {
	fake.setupSeccompMutex.Lock()
	defer fake.setupSeccompMutex.Unlock()
	fake.SetupSeccompStub = nil
	if fake.setupSeccompReturnsOnCall == nil {
		fake.setupSeccompReturnsOnCall = make(map[int]struct {
			result1 *configs.Seccomp
			result2 error
		})
	}
	fake.setupSeccompReturnsOnCall[i] = struct {
		result1 *configs.Seccomp
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) YamlUnmarshal(arg1 []byte, arg2 interface{}) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.yamlUnmarshalMutex.Lock()
	ret, specificReturn := fake.yamlUnmarshalReturnsOnCall[len(fake.yamlUnmarshalArgsForCall)]
	fake.yamlUnmarshalArgsForCall = append(fake.yamlUnmarshalArgsForCall, struct {
		arg1 []byte
		arg2 interface{}
	}{arg1Copy, arg2})
	stub := fake.YamlUnmarshalStub
	fakeReturns := fake.yamlUnmarshalReturns
	fake.recordInvocation("YamlUnmarshal", []interface{}{arg1Copy, arg2})
	fake.yamlUnmarshalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) YamlUnmarshalCallCount() int {
	fake.yamlUnmarshalMutex.RLock()
	defer fake.yamlUnmarshalMutex.RUnlock()
	return len(fake.yamlUnmarshalArgsForCall)
}

func (fake *FakeImpl) YamlUnmarshalCalls(stub func([]byte, interface{}) error) {
	fake.yamlUnmarshalMutex.Lock()
	defer fake.yamlUnmarshalMutex.Unlock()
	fake.YamlUnmarshalStub = stub
}

func (fake *FakeImpl) YamlUnmarshalArgsForCall(i int) ([]byte, interface{}) {
	fake.yamlUnmarshalMutex.RLock()
	defer fake.yamlUnmarshalMutex.RUnlock()
	argsForCall := fake.yamlUnmarshalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) YamlUnmarshalReturns(result1 error) {
	fake.yamlUnmarshalMutex.Lock()
	defer fake.yamlUnmarshalMutex.Unlock()
	fake.YamlUnmarshalStub = nil
	fake.yamlUnmarshalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) YamlUnmarshalReturnsOnCall(i int, result1 error) {
	fake.yamlUnmarshalMutex.Lock()
	defer fake.yamlUnmarshalMutex.Unlock()
	fake.YamlUnmarshalStub = nil
	if fake.yamlUnmarshalReturnsOnCall == nil {
		fake.yamlUnmarshalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.yamlUnmarshalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.commandRunMutex.RLock()
	defer fake.commandRunMutex.RUnlock()
	fake.commandWaitMutex.RLock()
	defer fake.commandWaitMutex.RUnlock()
	fake.initSeccompMutex.RLock()
	defer fake.initSeccompMutex.RUnlock()
	fake.jSONMarshalMutex.RLock()
	defer fake.jSONMarshalMutex.RUnlock()
	fake.jSONUnmarshalMutex.RLock()
	defer fake.jSONUnmarshalMutex.RUnlock()
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	fake.setupSeccompMutex.RLock()
	defer fake.setupSeccompMutex.RUnlock()
	fake.yamlUnmarshalMutex.RLock()
	defer fake.yamlUnmarshalMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeImpl) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
