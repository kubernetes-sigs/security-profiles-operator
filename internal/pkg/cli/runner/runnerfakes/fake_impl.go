//go:build linux
// +build linux

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by counterfeiter. DO NOT EDIT.
package runnerfakes

import (
	"sync"

	"github.com/nxadm/tail"
	"github.com/opencontainers/runc/libcontainer/configs"
	specs "github.com/opencontainers/runtime-spec/specs-go"
	seccomp "github.com/seccomp/libseccomp-golang"
	"sigs.k8s.io/security-profiles-operator/internal/pkg/cli/command"
	"sigs.k8s.io/security-profiles-operator/internal/pkg/daemon/enricher/types"
)

type FakeImpl struct {
	CommandRunStub        func(*command.Command) (uint32, error)
	commandRunMutex       sync.RWMutex
	commandRunArgsForCall []struct {
		arg1 *command.Command
	}
	commandRunReturns struct {
		result1 uint32
		result2 error
	}
	commandRunReturnsOnCall map[int]struct {
		result1 uint32
		result2 error
	}
	CommandWaitStub        func(*command.Command) error
	commandWaitMutex       sync.RWMutex
	commandWaitArgsForCall []struct {
		arg1 *command.Command
	}
	commandWaitReturns struct {
		result1 error
	}
	commandWaitReturnsOnCall map[int]struct {
		result1 error
	}
	ExtractAuditLineStub        func(string) (*types.AuditLine, error)
	extractAuditLineMutex       sync.RWMutex
	extractAuditLineArgsForCall []struct {
		arg1 string
	}
	extractAuditLineReturns struct {
		result1 *types.AuditLine
		result2 error
	}
	extractAuditLineReturnsOnCall map[int]struct {
		result1 *types.AuditLine
		result2 error
	}
	GetNameStub        func(seccomp.ScmpSyscall) (string, error)
	getNameMutex       sync.RWMutex
	getNameArgsForCall []struct {
		arg1 seccomp.ScmpSyscall
	}
	getNameReturns struct {
		result1 string
		result2 error
	}
	getNameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	InitSeccompStub        func(*configs.Seccomp) (int, error)
	initSeccompMutex       sync.RWMutex
	initSeccompArgsForCall []struct {
		arg1 *configs.Seccomp
	}
	initSeccompReturns struct {
		result1 int
		result2 error
	}
	initSeccompReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	IsAuditLineStub        func(string) bool
	isAuditLineMutex       sync.RWMutex
	isAuditLineArgsForCall []struct {
		arg1 string
	}
	isAuditLineReturns struct {
		result1 bool
	}
	isAuditLineReturnsOnCall map[int]struct {
		result1 bool
	}
	JSONMarshalStub        func(any) ([]byte, error)
	jSONMarshalMutex       sync.RWMutex
	jSONMarshalArgsForCall []struct {
		arg1 any
	}
	jSONMarshalReturns struct {
		result1 []byte
		result2 error
	}
	jSONMarshalReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	JSONUnmarshalStub        func([]byte, any) error
	jSONUnmarshalMutex       sync.RWMutex
	jSONUnmarshalArgsForCall []struct {
		arg1 []byte
		arg2 any
	}
	jSONUnmarshalReturns struct {
		result1 error
	}
	jSONUnmarshalReturnsOnCall map[int]struct {
		result1 error
	}
	LinesStub        func(*tail.Tail) chan *tail.Line
	linesMutex       sync.RWMutex
	linesArgsForCall []struct {
		arg1 *tail.Tail
	}
	linesReturns struct {
		result1 chan *tail.Line
	}
	linesReturnsOnCall map[int]struct {
		result1 chan *tail.Line
	}
	PidLoadStub        func() uint32
	pidLoadMutex       sync.RWMutex
	pidLoadArgsForCall []struct {
	}
	pidLoadReturns struct {
		result1 uint32
	}
	pidLoadReturnsOnCall map[int]struct {
		result1 uint32
	}
	ReadFileStub        func(string) ([]byte, error)
	readFileMutex       sync.RWMutex
	readFileArgsForCall []struct {
		arg1 string
	}
	readFileReturns struct {
		result1 []byte
		result2 error
	}
	readFileReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	SetupSeccompStub        func(*specs.LinuxSeccomp) (*configs.Seccomp, error)
	setupSeccompMutex       sync.RWMutex
	setupSeccompArgsForCall []struct {
		arg1 *specs.LinuxSeccomp
	}
	setupSeccompReturns struct {
		result1 *configs.Seccomp
		result2 error
	}
	setupSeccompReturnsOnCall map[int]struct {
		result1 *configs.Seccomp
		result2 error
	}
	TailFileStub        func(string, tail.Config) (*tail.Tail, error)
	tailFileMutex       sync.RWMutex
	tailFileArgsForCall []struct {
		arg1 string
		arg2 tail.Config
	}
	tailFileReturns struct {
		result1 *tail.Tail
		result2 error
	}
	tailFileReturnsOnCall map[int]struct {
		result1 *tail.Tail
		result2 error
	}
	YamlUnmarshalStub        func([]byte, interface{}) error
	yamlUnmarshalMutex       sync.RWMutex
	yamlUnmarshalArgsForCall []struct {
		arg1 []byte
		arg2 interface{}
	}
	yamlUnmarshalReturns struct {
		result1 error
	}
	yamlUnmarshalReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeImpl) CommandRun(arg1 *command.Command) (uint32, error) {
	fake.commandRunMutex.Lock()
	ret, specificReturn := fake.commandRunReturnsOnCall[len(fake.commandRunArgsForCall)]
	fake.commandRunArgsForCall = append(fake.commandRunArgsForCall, struct {
		arg1 *command.Command
	}{arg1})
	stub := fake.CommandRunStub
	fakeReturns := fake.commandRunReturns
	fake.recordInvocation("CommandRun", []interface{}{arg1})
	fake.commandRunMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) CommandRunCallCount() int {
	fake.commandRunMutex.RLock()
	defer fake.commandRunMutex.RUnlock()
	return len(fake.commandRunArgsForCall)
}

func (fake *FakeImpl) CommandRunCalls(stub func(*command.Command) (uint32, error)) {
	fake.commandRunMutex.Lock()
	defer fake.commandRunMutex.Unlock()
	fake.CommandRunStub = stub
}

func (fake *FakeImpl) CommandRunArgsForCall(i int) *command.Command {
	fake.commandRunMutex.RLock()
	defer fake.commandRunMutex.RUnlock()
	argsForCall := fake.commandRunArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) CommandRunReturns(result1 uint32, result2 error) {
	fake.commandRunMutex.Lock()
	defer fake.commandRunMutex.Unlock()
	fake.CommandRunStub = nil
	fake.commandRunReturns = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) CommandRunReturnsOnCall(i int, result1 uint32, result2 error) {
	fake.commandRunMutex.Lock()
	defer fake.commandRunMutex.Unlock()
	fake.CommandRunStub = nil
	if fake.commandRunReturnsOnCall == nil {
		fake.commandRunReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 error
		})
	}
	fake.commandRunReturnsOnCall[i] = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) CommandWait(arg1 *command.Command) error {
	fake.commandWaitMutex.Lock()
	ret, specificReturn := fake.commandWaitReturnsOnCall[len(fake.commandWaitArgsForCall)]
	fake.commandWaitArgsForCall = append(fake.commandWaitArgsForCall, struct {
		arg1 *command.Command
	}{arg1})
	stub := fake.CommandWaitStub
	fakeReturns := fake.commandWaitReturns
	fake.recordInvocation("CommandWait", []interface{}{arg1})
	fake.commandWaitMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) CommandWaitCallCount() int {
	fake.commandWaitMutex.RLock()
	defer fake.commandWaitMutex.RUnlock()
	return len(fake.commandWaitArgsForCall)
}

func (fake *FakeImpl) CommandWaitCalls(stub func(*command.Command) error) {
	fake.commandWaitMutex.Lock()
	defer fake.commandWaitMutex.Unlock()
	fake.CommandWaitStub = stub
}

func (fake *FakeImpl) CommandWaitArgsForCall(i int) *command.Command {
	fake.commandWaitMutex.RLock()
	defer fake.commandWaitMutex.RUnlock()
	argsForCall := fake.commandWaitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) CommandWaitReturns(result1 error) {
	fake.commandWaitMutex.Lock()
	defer fake.commandWaitMutex.Unlock()
	fake.CommandWaitStub = nil
	fake.commandWaitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) CommandWaitReturnsOnCall(i int, result1 error) {
	fake.commandWaitMutex.Lock()
	defer fake.commandWaitMutex.Unlock()
	fake.CommandWaitStub = nil
	if fake.commandWaitReturnsOnCall == nil {
		fake.commandWaitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.commandWaitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) ExtractAuditLine(arg1 string) (*types.AuditLine, error) {
	fake.extractAuditLineMutex.Lock()
	ret, specificReturn := fake.extractAuditLineReturnsOnCall[len(fake.extractAuditLineArgsForCall)]
	fake.extractAuditLineArgsForCall = append(fake.extractAuditLineArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ExtractAuditLineStub
	fakeReturns := fake.extractAuditLineReturns
	fake.recordInvocation("ExtractAuditLine", []interface{}{arg1})
	fake.extractAuditLineMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ExtractAuditLineCallCount() int {
	fake.extractAuditLineMutex.RLock()
	defer fake.extractAuditLineMutex.RUnlock()
	return len(fake.extractAuditLineArgsForCall)
}

func (fake *FakeImpl) ExtractAuditLineCalls(stub func(string) (*types.AuditLine, error)) {
	fake.extractAuditLineMutex.Lock()
	defer fake.extractAuditLineMutex.Unlock()
	fake.ExtractAuditLineStub = stub
}

func (fake *FakeImpl) ExtractAuditLineArgsForCall(i int) string {
	fake.extractAuditLineMutex.RLock()
	defer fake.extractAuditLineMutex.RUnlock()
	argsForCall := fake.extractAuditLineArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) ExtractAuditLineReturns(result1 *types.AuditLine, result2 error) {
	fake.extractAuditLineMutex.Lock()
	defer fake.extractAuditLineMutex.Unlock()
	fake.ExtractAuditLineStub = nil
	fake.extractAuditLineReturns = struct {
		result1 *types.AuditLine
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ExtractAuditLineReturnsOnCall(i int, result1 *types.AuditLine, result2 error) {
	fake.extractAuditLineMutex.Lock()
	defer fake.extractAuditLineMutex.Unlock()
	fake.ExtractAuditLineStub = nil
	if fake.extractAuditLineReturnsOnCall == nil {
		fake.extractAuditLineReturnsOnCall = make(map[int]struct {
			result1 *types.AuditLine
			result2 error
		})
	}
	fake.extractAuditLineReturnsOnCall[i] = struct {
		result1 *types.AuditLine
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetName(arg1 seccomp.ScmpSyscall) (string, error) {
	fake.getNameMutex.Lock()
	ret, specificReturn := fake.getNameReturnsOnCall[len(fake.getNameArgsForCall)]
	fake.getNameArgsForCall = append(fake.getNameArgsForCall, struct {
		arg1 seccomp.ScmpSyscall
	}{arg1})
	stub := fake.GetNameStub
	fakeReturns := fake.getNameReturns
	fake.recordInvocation("GetName", []interface{}{arg1})
	fake.getNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) GetNameCallCount() int {
	fake.getNameMutex.RLock()
	defer fake.getNameMutex.RUnlock()
	return len(fake.getNameArgsForCall)
}

func (fake *FakeImpl) GetNameCalls(stub func(seccomp.ScmpSyscall) (string, error)) {
	fake.getNameMutex.Lock()
	defer fake.getNameMutex.Unlock()
	fake.GetNameStub = stub
}

func (fake *FakeImpl) GetNameArgsForCall(i int) seccomp.ScmpSyscall {
	fake.getNameMutex.RLock()
	defer fake.getNameMutex.RUnlock()
	argsForCall := fake.getNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) GetNameReturns(result1 string, result2 error) {
	fake.getNameMutex.Lock()
	defer fake.getNameMutex.Unlock()
	fake.GetNameStub = nil
	fake.getNameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetNameReturnsOnCall(i int, result1 string, result2 error) {
	fake.getNameMutex.Lock()
	defer fake.getNameMutex.Unlock()
	fake.GetNameStub = nil
	if fake.getNameReturnsOnCall == nil {
		fake.getNameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getNameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) InitSeccomp(arg1 *configs.Seccomp) (int, error) {
	fake.initSeccompMutex.Lock()
	ret, specificReturn := fake.initSeccompReturnsOnCall[len(fake.initSeccompArgsForCall)]
	fake.initSeccompArgsForCall = append(fake.initSeccompArgsForCall, struct {
		arg1 *configs.Seccomp
	}{arg1})
	stub := fake.InitSeccompStub
	fakeReturns := fake.initSeccompReturns
	fake.recordInvocation("InitSeccomp", []interface{}{arg1})
	fake.initSeccompMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) InitSeccompCallCount() int {
	fake.initSeccompMutex.RLock()
	defer fake.initSeccompMutex.RUnlock()
	return len(fake.initSeccompArgsForCall)
}

func (fake *FakeImpl) InitSeccompCalls(stub func(*configs.Seccomp) (int, error)) {
	fake.initSeccompMutex.Lock()
	defer fake.initSeccompMutex.Unlock()
	fake.InitSeccompStub = stub
}

func (fake *FakeImpl) InitSeccompArgsForCall(i int) *configs.Seccomp {
	fake.initSeccompMutex.RLock()
	defer fake.initSeccompMutex.RUnlock()
	argsForCall := fake.initSeccompArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) InitSeccompReturns(result1 int, result2 error) {
	fake.initSeccompMutex.Lock()
	defer fake.initSeccompMutex.Unlock()
	fake.InitSeccompStub = nil
	fake.initSeccompReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) InitSeccompReturnsOnCall(i int, result1 int, result2 error) {
	fake.initSeccompMutex.Lock()
	defer fake.initSeccompMutex.Unlock()
	fake.InitSeccompStub = nil
	if fake.initSeccompReturnsOnCall == nil {
		fake.initSeccompReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.initSeccompReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) IsAuditLine(arg1 string) bool {
	fake.isAuditLineMutex.Lock()
	ret, specificReturn := fake.isAuditLineReturnsOnCall[len(fake.isAuditLineArgsForCall)]
	fake.isAuditLineArgsForCall = append(fake.isAuditLineArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.IsAuditLineStub
	fakeReturns := fake.isAuditLineReturns
	fake.recordInvocation("IsAuditLine", []interface{}{arg1})
	fake.isAuditLineMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) IsAuditLineCallCount() int {
	fake.isAuditLineMutex.RLock()
	defer fake.isAuditLineMutex.RUnlock()
	return len(fake.isAuditLineArgsForCall)
}

func (fake *FakeImpl) IsAuditLineCalls(stub func(string) bool) {
	fake.isAuditLineMutex.Lock()
	defer fake.isAuditLineMutex.Unlock()
	fake.IsAuditLineStub = stub
}

func (fake *FakeImpl) IsAuditLineArgsForCall(i int) string {
	fake.isAuditLineMutex.RLock()
	defer fake.isAuditLineMutex.RUnlock()
	argsForCall := fake.isAuditLineArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) IsAuditLineReturns(result1 bool) {
	fake.isAuditLineMutex.Lock()
	defer fake.isAuditLineMutex.Unlock()
	fake.IsAuditLineStub = nil
	fake.isAuditLineReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeImpl) IsAuditLineReturnsOnCall(i int, result1 bool) {
	fake.isAuditLineMutex.Lock()
	defer fake.isAuditLineMutex.Unlock()
	fake.IsAuditLineStub = nil
	if fake.isAuditLineReturnsOnCall == nil {
		fake.isAuditLineReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isAuditLineReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeImpl) JSONMarshal(arg1 any) ([]byte, error) {
	fake.jSONMarshalMutex.Lock()
	ret, specificReturn := fake.jSONMarshalReturnsOnCall[len(fake.jSONMarshalArgsForCall)]
	fake.jSONMarshalArgsForCall = append(fake.jSONMarshalArgsForCall, struct {
		arg1 any
	}{arg1})
	stub := fake.JSONMarshalStub
	fakeReturns := fake.jSONMarshalReturns
	fake.recordInvocation("JSONMarshal", []interface{}{arg1})
	fake.jSONMarshalMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) JSONMarshalCallCount() int {
	fake.jSONMarshalMutex.RLock()
	defer fake.jSONMarshalMutex.RUnlock()
	return len(fake.jSONMarshalArgsForCall)
}

func (fake *FakeImpl) JSONMarshalCalls(stub func(any) ([]byte, error)) {
	fake.jSONMarshalMutex.Lock()
	defer fake.jSONMarshalMutex.Unlock()
	fake.JSONMarshalStub = stub
}

func (fake *FakeImpl) JSONMarshalArgsForCall(i int) any {
	fake.jSONMarshalMutex.RLock()
	defer fake.jSONMarshalMutex.RUnlock()
	argsForCall := fake.jSONMarshalArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) JSONMarshalReturns(result1 []byte, result2 error) {
	fake.jSONMarshalMutex.Lock()
	defer fake.jSONMarshalMutex.Unlock()
	fake.JSONMarshalStub = nil
	fake.jSONMarshalReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) JSONMarshalReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.jSONMarshalMutex.Lock()
	defer fake.jSONMarshalMutex.Unlock()
	fake.JSONMarshalStub = nil
	if fake.jSONMarshalReturnsOnCall == nil {
		fake.jSONMarshalReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.jSONMarshalReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) JSONUnmarshal(arg1 []byte, arg2 any) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.jSONUnmarshalMutex.Lock()
	ret, specificReturn := fake.jSONUnmarshalReturnsOnCall[len(fake.jSONUnmarshalArgsForCall)]
	fake.jSONUnmarshalArgsForCall = append(fake.jSONUnmarshalArgsForCall, struct {
		arg1 []byte
		arg2 any
	}{arg1Copy, arg2})
	stub := fake.JSONUnmarshalStub
	fakeReturns := fake.jSONUnmarshalReturns
	fake.recordInvocation("JSONUnmarshal", []interface{}{arg1Copy, arg2})
	fake.jSONUnmarshalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) JSONUnmarshalCallCount() int {
	fake.jSONUnmarshalMutex.RLock()
	defer fake.jSONUnmarshalMutex.RUnlock()
	return len(fake.jSONUnmarshalArgsForCall)
}

func (fake *FakeImpl) JSONUnmarshalCalls(stub func([]byte, any) error) {
	fake.jSONUnmarshalMutex.Lock()
	defer fake.jSONUnmarshalMutex.Unlock()
	fake.JSONUnmarshalStub = stub
}

func (fake *FakeImpl) JSONUnmarshalArgsForCall(i int) ([]byte, any) {
	fake.jSONUnmarshalMutex.RLock()
	defer fake.jSONUnmarshalMutex.RUnlock()
	argsForCall := fake.jSONUnmarshalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) JSONUnmarshalReturns(result1 error) {
	fake.jSONUnmarshalMutex.Lock()
	defer fake.jSONUnmarshalMutex.Unlock()
	fake.JSONUnmarshalStub = nil
	fake.jSONUnmarshalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) JSONUnmarshalReturnsOnCall(i int, result1 error) {
	fake.jSONUnmarshalMutex.Lock()
	defer fake.jSONUnmarshalMutex.Unlock()
	fake.JSONUnmarshalStub = nil
	if fake.jSONUnmarshalReturnsOnCall == nil {
		fake.jSONUnmarshalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.jSONUnmarshalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) Lines(arg1 *tail.Tail) chan *tail.Line {
	fake.linesMutex.Lock()
	ret, specificReturn := fake.linesReturnsOnCall[len(fake.linesArgsForCall)]
	fake.linesArgsForCall = append(fake.linesArgsForCall, struct {
		arg1 *tail.Tail
	}{arg1})
	stub := fake.LinesStub
	fakeReturns := fake.linesReturns
	fake.recordInvocation("Lines", []interface{}{arg1})
	fake.linesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) LinesCallCount() int {
	fake.linesMutex.RLock()
	defer fake.linesMutex.RUnlock()
	return len(fake.linesArgsForCall)
}

func (fake *FakeImpl) LinesCalls(stub func(*tail.Tail) chan *tail.Line) {
	fake.linesMutex.Lock()
	defer fake.linesMutex.Unlock()
	fake.LinesStub = stub
}

func (fake *FakeImpl) LinesArgsForCall(i int) *tail.Tail {
	fake.linesMutex.RLock()
	defer fake.linesMutex.RUnlock()
	argsForCall := fake.linesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) LinesReturns(result1 chan *tail.Line) {
	fake.linesMutex.Lock()
	defer fake.linesMutex.Unlock()
	fake.LinesStub = nil
	fake.linesReturns = struct {
		result1 chan *tail.Line
	}{result1}
}

func (fake *FakeImpl) LinesReturnsOnCall(i int, result1 chan *tail.Line) {
	fake.linesMutex.Lock()
	defer fake.linesMutex.Unlock()
	fake.LinesStub = nil
	if fake.linesReturnsOnCall == nil {
		fake.linesReturnsOnCall = make(map[int]struct {
			result1 chan *tail.Line
		})
	}
	fake.linesReturnsOnCall[i] = struct {
		result1 chan *tail.Line
	}{result1}
}

func (fake *FakeImpl) PidLoad() uint32 {
	fake.pidLoadMutex.Lock()
	ret, specificReturn := fake.pidLoadReturnsOnCall[len(fake.pidLoadArgsForCall)]
	fake.pidLoadArgsForCall = append(fake.pidLoadArgsForCall, struct {
	}{})
	stub := fake.PidLoadStub
	fakeReturns := fake.pidLoadReturns
	fake.recordInvocation("PidLoad", []interface{}{})
	fake.pidLoadMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) PidLoadCallCount() int {
	fake.pidLoadMutex.RLock()
	defer fake.pidLoadMutex.RUnlock()
	return len(fake.pidLoadArgsForCall)
}

func (fake *FakeImpl) PidLoadCalls(stub func() uint32) {
	fake.pidLoadMutex.Lock()
	defer fake.pidLoadMutex.Unlock()
	fake.PidLoadStub = stub
}

func (fake *FakeImpl) PidLoadReturns(result1 uint32) {
	fake.pidLoadMutex.Lock()
	defer fake.pidLoadMutex.Unlock()
	fake.PidLoadStub = nil
	fake.pidLoadReturns = struct {
		result1 uint32
	}{result1}
}

func (fake *FakeImpl) PidLoadReturnsOnCall(i int, result1 uint32) {
	fake.pidLoadMutex.Lock()
	defer fake.pidLoadMutex.Unlock()
	fake.PidLoadStub = nil
	if fake.pidLoadReturnsOnCall == nil {
		fake.pidLoadReturnsOnCall = make(map[int]struct {
			result1 uint32
		})
	}
	fake.pidLoadReturnsOnCall[i] = struct {
		result1 uint32
	}{result1}
}

func (fake *FakeImpl) ReadFile(arg1 string) ([]byte, error) {
	fake.readFileMutex.Lock()
	ret, specificReturn := fake.readFileReturnsOnCall[len(fake.readFileArgsForCall)]
	fake.readFileArgsForCall = append(fake.readFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadFileStub
	fakeReturns := fake.readFileReturns
	fake.recordInvocation("ReadFile", []interface{}{arg1})
	fake.readFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ReadFileCallCount() int {
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	return len(fake.readFileArgsForCall)
}

func (fake *FakeImpl) ReadFileCalls(stub func(string) ([]byte, error)) {
	fake.readFileMutex.Lock()
	defer fake.readFileMutex.Unlock()
	fake.ReadFileStub = stub
}

func (fake *FakeImpl) ReadFileArgsForCall(i int) string {
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	argsForCall := fake.readFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) ReadFileReturns(result1 []byte, result2 error) {
	fake.readFileMutex.Lock()
	defer fake.readFileMutex.Unlock()
	fake.ReadFileStub = nil
	fake.readFileReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ReadFileReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.readFileMutex.Lock()
	defer fake.readFileMutex.Unlock()
	fake.ReadFileStub = nil
	if fake.readFileReturnsOnCall == nil {
		fake.readFileReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.readFileReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) SetupSeccomp(arg1 *specs.LinuxSeccomp) (*configs.Seccomp, error) {
	fake.setupSeccompMutex.Lock()
	ret, specificReturn := fake.setupSeccompReturnsOnCall[len(fake.setupSeccompArgsForCall)]
	fake.setupSeccompArgsForCall = append(fake.setupSeccompArgsForCall, struct {
		arg1 *specs.LinuxSeccomp
	}{arg1})
	stub := fake.SetupSeccompStub
	fakeReturns := fake.setupSeccompReturns
	fake.recordInvocation("SetupSeccomp", []interface{}{arg1})
	fake.setupSeccompMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) SetupSeccompCallCount() int {
	fake.setupSeccompMutex.RLock()
	defer fake.setupSeccompMutex.RUnlock()
	return len(fake.setupSeccompArgsForCall)
}

func (fake *FakeImpl) SetupSeccompCalls(stub func(*specs.LinuxSeccomp) (*configs.Seccomp, error)) {
	fake.setupSeccompMutex.Lock()
	defer fake.setupSeccompMutex.Unlock()
	fake.SetupSeccompStub = stub
}

func (fake *FakeImpl) SetupSeccompArgsForCall(i int) *specs.LinuxSeccomp {
	fake.setupSeccompMutex.RLock()
	defer fake.setupSeccompMutex.RUnlock()
	argsForCall := fake.setupSeccompArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) SetupSeccompReturns(result1 *configs.Seccomp, result2 error) {
	fake.setupSeccompMutex.Lock()
	defer fake.setupSeccompMutex.Unlock()
	fake.SetupSeccompStub = nil
	fake.setupSeccompReturns = struct {
		result1 *configs.Seccomp
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) SetupSeccompReturnsOnCall(i int, result1 *configs.Seccomp, result2 error) {
	fake.setupSeccompMutex.Lock()
	defer fake.setupSeccompMutex.Unlock()
	fake.SetupSeccompStub = nil
	if fake.setupSeccompReturnsOnCall == nil {
		fake.setupSeccompReturnsOnCall = make(map[int]struct {
			result1 *configs.Seccomp
			result2 error
		})
	}
	fake.setupSeccompReturnsOnCall[i] = struct {
		result1 *configs.Seccomp
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) TailFile(arg1 string, arg2 tail.Config) (*tail.Tail, error) {
	fake.tailFileMutex.Lock()
	ret, specificReturn := fake.tailFileReturnsOnCall[len(fake.tailFileArgsForCall)]
	fake.tailFileArgsForCall = append(fake.tailFileArgsForCall, struct {
		arg1 string
		arg2 tail.Config
	}{arg1, arg2})
	stub := fake.TailFileStub
	fakeReturns := fake.tailFileReturns
	fake.recordInvocation("TailFile", []interface{}{arg1, arg2})
	fake.tailFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) TailFileCallCount() int {
	fake.tailFileMutex.RLock()
	defer fake.tailFileMutex.RUnlock()
	return len(fake.tailFileArgsForCall)
}

func (fake *FakeImpl) TailFileCalls(stub func(string, tail.Config) (*tail.Tail, error)) {
	fake.tailFileMutex.Lock()
	defer fake.tailFileMutex.Unlock()
	fake.TailFileStub = stub
}

func (fake *FakeImpl) TailFileArgsForCall(i int) (string, tail.Config) {
	fake.tailFileMutex.RLock()
	defer fake.tailFileMutex.RUnlock()
	argsForCall := fake.tailFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) TailFileReturns(result1 *tail.Tail, result2 error) {
	fake.tailFileMutex.Lock()
	defer fake.tailFileMutex.Unlock()
	fake.TailFileStub = nil
	fake.tailFileReturns = struct {
		result1 *tail.Tail
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) TailFileReturnsOnCall(i int, result1 *tail.Tail, result2 error) {
	fake.tailFileMutex.Lock()
	defer fake.tailFileMutex.Unlock()
	fake.TailFileStub = nil
	if fake.tailFileReturnsOnCall == nil {
		fake.tailFileReturnsOnCall = make(map[int]struct {
			result1 *tail.Tail
			result2 error
		})
	}
	fake.tailFileReturnsOnCall[i] = struct {
		result1 *tail.Tail
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) YamlUnmarshal(arg1 []byte, arg2 interface{}) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.yamlUnmarshalMutex.Lock()
	ret, specificReturn := fake.yamlUnmarshalReturnsOnCall[len(fake.yamlUnmarshalArgsForCall)]
	fake.yamlUnmarshalArgsForCall = append(fake.yamlUnmarshalArgsForCall, struct {
		arg1 []byte
		arg2 interface{}
	}{arg1Copy, arg2})
	stub := fake.YamlUnmarshalStub
	fakeReturns := fake.yamlUnmarshalReturns
	fake.recordInvocation("YamlUnmarshal", []interface{}{arg1Copy, arg2})
	fake.yamlUnmarshalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) YamlUnmarshalCallCount() int {
	fake.yamlUnmarshalMutex.RLock()
	defer fake.yamlUnmarshalMutex.RUnlock()
	return len(fake.yamlUnmarshalArgsForCall)
}

func (fake *FakeImpl) YamlUnmarshalCalls(stub func([]byte, interface{}) error) {
	fake.yamlUnmarshalMutex.Lock()
	defer fake.yamlUnmarshalMutex.Unlock()
	fake.YamlUnmarshalStub = stub
}

func (fake *FakeImpl) YamlUnmarshalArgsForCall(i int) ([]byte, interface{}) {
	fake.yamlUnmarshalMutex.RLock()
	defer fake.yamlUnmarshalMutex.RUnlock()
	argsForCall := fake.yamlUnmarshalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) YamlUnmarshalReturns(result1 error) {
	fake.yamlUnmarshalMutex.Lock()
	defer fake.yamlUnmarshalMutex.Unlock()
	fake.YamlUnmarshalStub = nil
	fake.yamlUnmarshalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) YamlUnmarshalReturnsOnCall(i int, result1 error) {
	fake.yamlUnmarshalMutex.Lock()
	defer fake.yamlUnmarshalMutex.Unlock()
	fake.YamlUnmarshalStub = nil
	if fake.yamlUnmarshalReturnsOnCall == nil {
		fake.yamlUnmarshalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.yamlUnmarshalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.commandRunMutex.RLock()
	defer fake.commandRunMutex.RUnlock()
	fake.commandWaitMutex.RLock()
	defer fake.commandWaitMutex.RUnlock()
	fake.extractAuditLineMutex.RLock()
	defer fake.extractAuditLineMutex.RUnlock()
	fake.getNameMutex.RLock()
	defer fake.getNameMutex.RUnlock()
	fake.initSeccompMutex.RLock()
	defer fake.initSeccompMutex.RUnlock()
	fake.isAuditLineMutex.RLock()
	defer fake.isAuditLineMutex.RUnlock()
	fake.jSONMarshalMutex.RLock()
	defer fake.jSONMarshalMutex.RUnlock()
	fake.jSONUnmarshalMutex.RLock()
	defer fake.jSONUnmarshalMutex.RUnlock()
	fake.linesMutex.RLock()
	defer fake.linesMutex.RUnlock()
	fake.pidLoadMutex.RLock()
	defer fake.pidLoadMutex.RUnlock()
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	fake.setupSeccompMutex.RLock()
	defer fake.setupSeccompMutex.RUnlock()
	fake.tailFileMutex.RLock()
	defer fake.tailFileMutex.RUnlock()
	fake.yamlUnmarshalMutex.RLock()
	defer fake.yamlUnmarshalMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeImpl) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
