/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by counterfeiter. DO NOT EDIT.
package profilerecorderfakes

import (
	"sync"

	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/tools/record"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/manager"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"
)

type FakeImpl struct {
	ClientGetStub        func(client.Client, types.NamespacedName, client.Object) error
	clientGetMutex       sync.RWMutex
	clientGetArgsForCall []struct {
		arg1 client.Client
		arg2 types.NamespacedName
		arg3 client.Object
	}
	clientGetReturns struct {
		result1 error
	}
	clientGetReturnsOnCall map[int]struct {
		result1 error
	}
	ManagerGetClientStub        func(manager.Manager) client.Client
	managerGetClientMutex       sync.RWMutex
	managerGetClientArgsForCall []struct {
		arg1 manager.Manager
	}
	managerGetClientReturns struct {
		result1 client.Client
	}
	managerGetClientReturnsOnCall map[int]struct {
		result1 client.Client
	}
	ManagerGetEventRecorderForStub        func(manager.Manager, string) record.EventRecorder
	managerGetEventRecorderForMutex       sync.RWMutex
	managerGetEventRecorderForArgsForCall []struct {
		arg1 manager.Manager
		arg2 string
	}
	managerGetEventRecorderForReturns struct {
		result1 record.EventRecorder
	}
	managerGetEventRecorderForReturnsOnCall map[int]struct {
		result1 record.EventRecorder
	}
	NewClientStub        func(manager.Manager) (client.Client, error)
	newClientMutex       sync.RWMutex
	newClientArgsForCall []struct {
		arg1 manager.Manager
	}
	newClientReturns struct {
		result1 client.Client
		result2 error
	}
	newClientReturnsOnCall map[int]struct {
		result1 client.Client
		result2 error
	}
	NewControllerManagedByStub        func(manager.Manager, string, func(obj runtime.Object) bool, func(obj runtime.Object) bool, reconcile.Reconciler) error
	newControllerManagedByMutex       sync.RWMutex
	newControllerManagedByArgsForCall []struct {
		arg1 manager.Manager
		arg2 string
		arg3 func(obj runtime.Object) bool
		arg4 func(obj runtime.Object) bool
		arg5 reconcile.Reconciler
	}
	newControllerManagedByReturns struct {
		result1 error
	}
	newControllerManagedByReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeImpl) ClientGet(arg1 client.Client, arg2 types.NamespacedName, arg3 client.Object) error {
	fake.clientGetMutex.Lock()
	ret, specificReturn := fake.clientGetReturnsOnCall[len(fake.clientGetArgsForCall)]
	fake.clientGetArgsForCall = append(fake.clientGetArgsForCall, struct {
		arg1 client.Client
		arg2 types.NamespacedName
		arg3 client.Object
	}{arg1, arg2, arg3})
	stub := fake.ClientGetStub
	fakeReturns := fake.clientGetReturns
	fake.recordInvocation("ClientGet", []interface{}{arg1, arg2, arg3})
	fake.clientGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) ClientGetCallCount() int {
	fake.clientGetMutex.RLock()
	defer fake.clientGetMutex.RUnlock()
	return len(fake.clientGetArgsForCall)
}

func (fake *FakeImpl) ClientGetCalls(stub func(client.Client, types.NamespacedName, client.Object) error) {
	fake.clientGetMutex.Lock()
	defer fake.clientGetMutex.Unlock()
	fake.ClientGetStub = stub
}

func (fake *FakeImpl) ClientGetArgsForCall(i int) (client.Client, types.NamespacedName, client.Object) {
	fake.clientGetMutex.RLock()
	defer fake.clientGetMutex.RUnlock()
	argsForCall := fake.clientGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) ClientGetReturns(result1 error) {
	fake.clientGetMutex.Lock()
	defer fake.clientGetMutex.Unlock()
	fake.ClientGetStub = nil
	fake.clientGetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) ClientGetReturnsOnCall(i int, result1 error) {
	fake.clientGetMutex.Lock()
	defer fake.clientGetMutex.Unlock()
	fake.ClientGetStub = nil
	if fake.clientGetReturnsOnCall == nil {
		fake.clientGetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.clientGetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) ManagerGetClient(arg1 manager.Manager) client.Client {
	fake.managerGetClientMutex.Lock()
	ret, specificReturn := fake.managerGetClientReturnsOnCall[len(fake.managerGetClientArgsForCall)]
	fake.managerGetClientArgsForCall = append(fake.managerGetClientArgsForCall, struct {
		arg1 manager.Manager
	}{arg1})
	stub := fake.ManagerGetClientStub
	fakeReturns := fake.managerGetClientReturns
	fake.recordInvocation("ManagerGetClient", []interface{}{arg1})
	fake.managerGetClientMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) ManagerGetClientCallCount() int {
	fake.managerGetClientMutex.RLock()
	defer fake.managerGetClientMutex.RUnlock()
	return len(fake.managerGetClientArgsForCall)
}

func (fake *FakeImpl) ManagerGetClientCalls(stub func(manager.Manager) client.Client) {
	fake.managerGetClientMutex.Lock()
	defer fake.managerGetClientMutex.Unlock()
	fake.ManagerGetClientStub = stub
}

func (fake *FakeImpl) ManagerGetClientArgsForCall(i int) manager.Manager {
	fake.managerGetClientMutex.RLock()
	defer fake.managerGetClientMutex.RUnlock()
	argsForCall := fake.managerGetClientArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) ManagerGetClientReturns(result1 client.Client) {
	fake.managerGetClientMutex.Lock()
	defer fake.managerGetClientMutex.Unlock()
	fake.ManagerGetClientStub = nil
	fake.managerGetClientReturns = struct {
		result1 client.Client
	}{result1}
}

func (fake *FakeImpl) ManagerGetClientReturnsOnCall(i int, result1 client.Client) {
	fake.managerGetClientMutex.Lock()
	defer fake.managerGetClientMutex.Unlock()
	fake.ManagerGetClientStub = nil
	if fake.managerGetClientReturnsOnCall == nil {
		fake.managerGetClientReturnsOnCall = make(map[int]struct {
			result1 client.Client
		})
	}
	fake.managerGetClientReturnsOnCall[i] = struct {
		result1 client.Client
	}{result1}
}

func (fake *FakeImpl) ManagerGetEventRecorderFor(arg1 manager.Manager, arg2 string) record.EventRecorder {
	fake.managerGetEventRecorderForMutex.Lock()
	ret, specificReturn := fake.managerGetEventRecorderForReturnsOnCall[len(fake.managerGetEventRecorderForArgsForCall)]
	fake.managerGetEventRecorderForArgsForCall = append(fake.managerGetEventRecorderForArgsForCall, struct {
		arg1 manager.Manager
		arg2 string
	}{arg1, arg2})
	stub := fake.ManagerGetEventRecorderForStub
	fakeReturns := fake.managerGetEventRecorderForReturns
	fake.recordInvocation("ManagerGetEventRecorderFor", []interface{}{arg1, arg2})
	fake.managerGetEventRecorderForMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) ManagerGetEventRecorderForCallCount() int {
	fake.managerGetEventRecorderForMutex.RLock()
	defer fake.managerGetEventRecorderForMutex.RUnlock()
	return len(fake.managerGetEventRecorderForArgsForCall)
}

func (fake *FakeImpl) ManagerGetEventRecorderForCalls(stub func(manager.Manager, string) record.EventRecorder) {
	fake.managerGetEventRecorderForMutex.Lock()
	defer fake.managerGetEventRecorderForMutex.Unlock()
	fake.ManagerGetEventRecorderForStub = stub
}

func (fake *FakeImpl) ManagerGetEventRecorderForArgsForCall(i int) (manager.Manager, string) {
	fake.managerGetEventRecorderForMutex.RLock()
	defer fake.managerGetEventRecorderForMutex.RUnlock()
	argsForCall := fake.managerGetEventRecorderForArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) ManagerGetEventRecorderForReturns(result1 record.EventRecorder) {
	fake.managerGetEventRecorderForMutex.Lock()
	defer fake.managerGetEventRecorderForMutex.Unlock()
	fake.ManagerGetEventRecorderForStub = nil
	fake.managerGetEventRecorderForReturns = struct {
		result1 record.EventRecorder
	}{result1}
}

func (fake *FakeImpl) ManagerGetEventRecorderForReturnsOnCall(i int, result1 record.EventRecorder) {
	fake.managerGetEventRecorderForMutex.Lock()
	defer fake.managerGetEventRecorderForMutex.Unlock()
	fake.ManagerGetEventRecorderForStub = nil
	if fake.managerGetEventRecorderForReturnsOnCall == nil {
		fake.managerGetEventRecorderForReturnsOnCall = make(map[int]struct {
			result1 record.EventRecorder
		})
	}
	fake.managerGetEventRecorderForReturnsOnCall[i] = struct {
		result1 record.EventRecorder
	}{result1}
}

func (fake *FakeImpl) NewClient(arg1 manager.Manager) (client.Client, error) {
	fake.newClientMutex.Lock()
	ret, specificReturn := fake.newClientReturnsOnCall[len(fake.newClientArgsForCall)]
	fake.newClientArgsForCall = append(fake.newClientArgsForCall, struct {
		arg1 manager.Manager
	}{arg1})
	stub := fake.NewClientStub
	fakeReturns := fake.newClientReturns
	fake.recordInvocation("NewClient", []interface{}{arg1})
	fake.newClientMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) NewClientCallCount() int {
	fake.newClientMutex.RLock()
	defer fake.newClientMutex.RUnlock()
	return len(fake.newClientArgsForCall)
}

func (fake *FakeImpl) NewClientCalls(stub func(manager.Manager) (client.Client, error)) {
	fake.newClientMutex.Lock()
	defer fake.newClientMutex.Unlock()
	fake.NewClientStub = stub
}

func (fake *FakeImpl) NewClientArgsForCall(i int) manager.Manager {
	fake.newClientMutex.RLock()
	defer fake.newClientMutex.RUnlock()
	argsForCall := fake.newClientArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) NewClientReturns(result1 client.Client, result2 error) {
	fake.newClientMutex.Lock()
	defer fake.newClientMutex.Unlock()
	fake.NewClientStub = nil
	fake.newClientReturns = struct {
		result1 client.Client
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewClientReturnsOnCall(i int, result1 client.Client, result2 error) {
	fake.newClientMutex.Lock()
	defer fake.newClientMutex.Unlock()
	fake.NewClientStub = nil
	if fake.newClientReturnsOnCall == nil {
		fake.newClientReturnsOnCall = make(map[int]struct {
			result1 client.Client
			result2 error
		})
	}
	fake.newClientReturnsOnCall[i] = struct {
		result1 client.Client
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewControllerManagedBy(arg1 manager.Manager, arg2 string, arg3 func(obj runtime.Object) bool, arg4 func(obj runtime.Object) bool, arg5 reconcile.Reconciler) error {
	fake.newControllerManagedByMutex.Lock()
	ret, specificReturn := fake.newControllerManagedByReturnsOnCall[len(fake.newControllerManagedByArgsForCall)]
	fake.newControllerManagedByArgsForCall = append(fake.newControllerManagedByArgsForCall, struct {
		arg1 manager.Manager
		arg2 string
		arg3 func(obj runtime.Object) bool
		arg4 func(obj runtime.Object) bool
		arg5 reconcile.Reconciler
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.NewControllerManagedByStub
	fakeReturns := fake.newControllerManagedByReturns
	fake.recordInvocation("NewControllerManagedBy", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.newControllerManagedByMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) NewControllerManagedByCallCount() int {
	fake.newControllerManagedByMutex.RLock()
	defer fake.newControllerManagedByMutex.RUnlock()
	return len(fake.newControllerManagedByArgsForCall)
}

func (fake *FakeImpl) NewControllerManagedByCalls(stub func(manager.Manager, string, func(obj runtime.Object) bool, func(obj runtime.Object) bool, reconcile.Reconciler) error) {
	fake.newControllerManagedByMutex.Lock()
	defer fake.newControllerManagedByMutex.Unlock()
	fake.NewControllerManagedByStub = stub
}

func (fake *FakeImpl) NewControllerManagedByArgsForCall(i int) (manager.Manager, string, func(obj runtime.Object) bool, func(obj runtime.Object) bool, reconcile.Reconciler) {
	fake.newControllerManagedByMutex.RLock()
	defer fake.newControllerManagedByMutex.RUnlock()
	argsForCall := fake.newControllerManagedByArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeImpl) NewControllerManagedByReturns(result1 error) {
	fake.newControllerManagedByMutex.Lock()
	defer fake.newControllerManagedByMutex.Unlock()
	fake.NewControllerManagedByStub = nil
	fake.newControllerManagedByReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) NewControllerManagedByReturnsOnCall(i int, result1 error) {
	fake.newControllerManagedByMutex.Lock()
	defer fake.newControllerManagedByMutex.Unlock()
	fake.NewControllerManagedByStub = nil
	if fake.newControllerManagedByReturnsOnCall == nil {
		fake.newControllerManagedByReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.newControllerManagedByReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.clientGetMutex.RLock()
	defer fake.clientGetMutex.RUnlock()
	fake.managerGetClientMutex.RLock()
	defer fake.managerGetClientMutex.RUnlock()
	fake.managerGetEventRecorderForMutex.RLock()
	defer fake.managerGetEventRecorderForMutex.RUnlock()
	fake.newClientMutex.RLock()
	defer fake.newClientMutex.RUnlock()
	fake.newControllerManagedByMutex.RLock()
	defer fake.newControllerManagedByMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeImpl) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
