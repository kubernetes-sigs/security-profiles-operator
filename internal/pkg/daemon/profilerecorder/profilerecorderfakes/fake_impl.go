/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by counterfeiter. DO NOT EDIT.
package profilerecorderfakes

import (
	"context"
	"sync"

	"github.com/containers/common/pkg/seccomp"
	"google.golang.org/grpc"
	v1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/tools/record"
	controllerruntime "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/manager"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"
	api_bpfrecorder "sigs.k8s.io/security-profiles-operator/api/grpc/bpfrecorder"
	api_enricher "sigs.k8s.io/security-profiles-operator/api/grpc/enricher"
	"sigs.k8s.io/security-profiles-operator/api/profilerecording/v1alpha1"
	v1alpha1a "sigs.k8s.io/security-profiles-operator/api/spod/v1alpha1"
)

type FakeImpl struct {
	ApparmorForProfileStub        func(context.Context, api_bpfrecorder.BpfRecorderClient, *api_bpfrecorder.ProfileRequest) (*api_bpfrecorder.ApparmorResponse, error)
	apparmorForProfileMutex       sync.RWMutex
	apparmorForProfileArgsForCall []struct {
		arg1 context.Context
		arg2 api_bpfrecorder.BpfRecorderClient
		arg3 *api_bpfrecorder.ProfileRequest
	}
	apparmorForProfileReturns struct {
		result1 *api_bpfrecorder.ApparmorResponse
		result2 error
	}
	apparmorForProfileReturnsOnCall map[int]struct {
		result1 *api_bpfrecorder.ApparmorResponse
		result2 error
	}
	AvcsStub        func(context.Context, api_enricher.EnricherClient, *api_enricher.AvcRequest) (*api_enricher.AvcResponse, error)
	avcsMutex       sync.RWMutex
	avcsArgsForCall []struct {
		arg1 context.Context
		arg2 api_enricher.EnricherClient
		arg3 *api_enricher.AvcRequest
	}
	avcsReturns struct {
		result1 *api_enricher.AvcResponse
		result2 error
	}
	avcsReturnsOnCall map[int]struct {
		result1 *api_enricher.AvcResponse
		result2 error
	}
	ClientGetStub        func(context.Context, client.Client, client.ObjectKey, client.Object) error
	clientGetMutex       sync.RWMutex
	clientGetArgsForCall []struct {
		arg1 context.Context
		arg2 client.Client
		arg3 client.ObjectKey
		arg4 client.Object
	}
	clientGetReturns struct {
		result1 error
	}
	clientGetReturnsOnCall map[int]struct {
		result1 error
	}
	CreateOrUpdateStub        func(context.Context, client.Client, client.Object, controllerutil.MutateFn) (controllerutil.OperationResult, error)
	createOrUpdateMutex       sync.RWMutex
	createOrUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 client.Client
		arg3 client.Object
		arg4 controllerutil.MutateFn
	}
	createOrUpdateReturns struct {
		result1 controllerutil.OperationResult
		result2 error
	}
	createOrUpdateReturnsOnCall map[int]struct {
		result1 controllerutil.OperationResult
		result2 error
	}
	DialBpfRecorderStub        func() (*grpc.ClientConn, context.CancelFunc, error)
	dialBpfRecorderMutex       sync.RWMutex
	dialBpfRecorderArgsForCall []struct {
	}
	dialBpfRecorderReturns struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}
	dialBpfRecorderReturnsOnCall map[int]struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}
	DialEnricherStub        func() (*grpc.ClientConn, context.CancelFunc, error)
	dialEnricherMutex       sync.RWMutex
	dialEnricherArgsForCall []struct {
	}
	dialEnricherReturns struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}
	dialEnricherReturnsOnCall map[int]struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}
	GetPodStub        func(context.Context, client.Client, client.ObjectKey) (*v1.Pod, error)
	getPodMutex       sync.RWMutex
	getPodArgsForCall []struct {
		arg1 context.Context
		arg2 client.Client
		arg3 client.ObjectKey
	}
	getPodReturns struct {
		result1 *v1.Pod
		result2 error
	}
	getPodReturnsOnCall map[int]struct {
		result1 *v1.Pod
		result2 error
	}
	GetRecordingStub        func(context.Context, client.Client, client.ObjectKey) (*v1alpha1.ProfileRecording, error)
	getRecordingMutex       sync.RWMutex
	getRecordingArgsForCall []struct {
		arg1 context.Context
		arg2 client.Client
		arg3 client.ObjectKey
	}
	getRecordingReturns struct {
		result1 *v1alpha1.ProfileRecording
		result2 error
	}
	getRecordingReturnsOnCall map[int]struct {
		result1 *v1alpha1.ProfileRecording
		result2 error
	}
	GetSPODStub        func(context.Context, client.Client) (*v1alpha1a.SecurityProfilesOperatorDaemon, error)
	getSPODMutex       sync.RWMutex
	getSPODArgsForCall []struct {
		arg1 context.Context
		arg2 client.Client
	}
	getSPODReturns struct {
		result1 *v1alpha1a.SecurityProfilesOperatorDaemon
		result2 error
	}
	getSPODReturnsOnCall map[int]struct {
		result1 *v1alpha1a.SecurityProfilesOperatorDaemon
		result2 error
	}
	GoArchToSeccompArchStub        func(string) (seccomp.Arch, error)
	goArchToSeccompArchMutex       sync.RWMutex
	goArchToSeccompArchArgsForCall []struct {
		arg1 string
	}
	goArchToSeccompArchReturns struct {
		result1 seccomp.Arch
		result2 error
	}
	goArchToSeccompArchReturnsOnCall map[int]struct {
		result1 seccomp.Arch
		result2 error
	}
	ManagerGetClientStub        func(manager.Manager) client.Client
	managerGetClientMutex       sync.RWMutex
	managerGetClientArgsForCall []struct {
		arg1 manager.Manager
	}
	managerGetClientReturns struct {
		result1 client.Client
	}
	managerGetClientReturnsOnCall map[int]struct {
		result1 client.Client
	}
	ManagerGetEventRecorderForStub        func(manager.Manager, string) record.EventRecorder
	managerGetEventRecorderForMutex       sync.RWMutex
	managerGetEventRecorderForArgsForCall []struct {
		arg1 manager.Manager
		arg2 string
	}
	managerGetEventRecorderForReturns struct {
		result1 record.EventRecorder
	}
	managerGetEventRecorderForReturnsOnCall map[int]struct {
		result1 record.EventRecorder
	}
	NewClientStub        func(controllerruntime.Manager) (client.Client, error)
	newClientMutex       sync.RWMutex
	newClientArgsForCall []struct {
		arg1 controllerruntime.Manager
	}
	newClientReturns struct {
		result1 client.Client
		result2 error
	}
	newClientReturnsOnCall map[int]struct {
		result1 client.Client
		result2 error
	}
	NewControllerManagedByStub        func(manager.Manager, string, func(obj runtime.Object) bool, func(obj runtime.Object) bool, reconcile.Reconciler) error
	newControllerManagedByMutex       sync.RWMutex
	newControllerManagedByArgsForCall []struct {
		arg1 manager.Manager
		arg2 string
		arg3 func(obj runtime.Object) bool
		arg4 func(obj runtime.Object) bool
		arg5 reconcile.Reconciler
	}
	newControllerManagedByReturns struct {
		result1 error
	}
	newControllerManagedByReturnsOnCall map[int]struct {
		result1 error
	}
	ResetAvcsStub        func(context.Context, api_enricher.EnricherClient, *api_enricher.AvcRequest) error
	resetAvcsMutex       sync.RWMutex
	resetAvcsArgsForCall []struct {
		arg1 context.Context
		arg2 api_enricher.EnricherClient
		arg3 *api_enricher.AvcRequest
	}
	resetAvcsReturns struct {
		result1 error
	}
	resetAvcsReturnsOnCall map[int]struct {
		result1 error
	}
	ResetSyscallsStub        func(context.Context, api_enricher.EnricherClient, *api_enricher.SyscallsRequest) error
	resetSyscallsMutex       sync.RWMutex
	resetSyscallsArgsForCall []struct {
		arg1 context.Context
		arg2 api_enricher.EnricherClient
		arg3 *api_enricher.SyscallsRequest
	}
	resetSyscallsReturns struct {
		result1 error
	}
	resetSyscallsReturnsOnCall map[int]struct {
		result1 error
	}
	StartBpfRecorderStub        func(context.Context, api_bpfrecorder.BpfRecorderClient) error
	startBpfRecorderMutex       sync.RWMutex
	startBpfRecorderArgsForCall []struct {
		arg1 context.Context
		arg2 api_bpfrecorder.BpfRecorderClient
	}
	startBpfRecorderReturns struct {
		result1 error
	}
	startBpfRecorderReturnsOnCall map[int]struct {
		result1 error
	}
	StopBpfRecorderStub        func(context.Context, api_bpfrecorder.BpfRecorderClient) error
	stopBpfRecorderMutex       sync.RWMutex
	stopBpfRecorderArgsForCall []struct {
		arg1 context.Context
		arg2 api_bpfrecorder.BpfRecorderClient
	}
	stopBpfRecorderReturns struct {
		result1 error
	}
	stopBpfRecorderReturnsOnCall map[int]struct {
		result1 error
	}
	SyscallsStub        func(context.Context, api_enricher.EnricherClient, *api_enricher.SyscallsRequest) (*api_enricher.SyscallsResponse, error)
	syscallsMutex       sync.RWMutex
	syscallsArgsForCall []struct {
		arg1 context.Context
		arg2 api_enricher.EnricherClient
		arg3 *api_enricher.SyscallsRequest
	}
	syscallsReturns struct {
		result1 *api_enricher.SyscallsResponse
		result2 error
	}
	syscallsReturnsOnCall map[int]struct {
		result1 *api_enricher.SyscallsResponse
		result2 error
	}
	SyscallsForProfileStub        func(context.Context, api_bpfrecorder.BpfRecorderClient, *api_bpfrecorder.ProfileRequest) (*api_bpfrecorder.SyscallsResponse, error)
	syscallsForProfileMutex       sync.RWMutex
	syscallsForProfileArgsForCall []struct {
		arg1 context.Context
		arg2 api_bpfrecorder.BpfRecorderClient
		arg3 *api_bpfrecorder.ProfileRequest
	}
	syscallsForProfileReturns struct {
		result1 *api_bpfrecorder.SyscallsResponse
		result2 error
	}
	syscallsForProfileReturnsOnCall map[int]struct {
		result1 *api_bpfrecorder.SyscallsResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeImpl) ApparmorForProfile(arg1 context.Context, arg2 api_bpfrecorder.BpfRecorderClient, arg3 *api_bpfrecorder.ProfileRequest) (*api_bpfrecorder.ApparmorResponse, error) {
	fake.apparmorForProfileMutex.Lock()
	ret, specificReturn := fake.apparmorForProfileReturnsOnCall[len(fake.apparmorForProfileArgsForCall)]
	fake.apparmorForProfileArgsForCall = append(fake.apparmorForProfileArgsForCall, struct {
		arg1 context.Context
		arg2 api_bpfrecorder.BpfRecorderClient
		arg3 *api_bpfrecorder.ProfileRequest
	}{arg1, arg2, arg3})
	stub := fake.ApparmorForProfileStub
	fakeReturns := fake.apparmorForProfileReturns
	fake.recordInvocation("ApparmorForProfile", []interface{}{arg1, arg2, arg3})
	fake.apparmorForProfileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ApparmorForProfileCallCount() int {
	fake.apparmorForProfileMutex.RLock()
	defer fake.apparmorForProfileMutex.RUnlock()
	return len(fake.apparmorForProfileArgsForCall)
}

func (fake *FakeImpl) ApparmorForProfileCalls(stub func(context.Context, api_bpfrecorder.BpfRecorderClient, *api_bpfrecorder.ProfileRequest) (*api_bpfrecorder.ApparmorResponse, error)) {
	fake.apparmorForProfileMutex.Lock()
	defer fake.apparmorForProfileMutex.Unlock()
	fake.ApparmorForProfileStub = stub
}

func (fake *FakeImpl) ApparmorForProfileArgsForCall(i int) (context.Context, api_bpfrecorder.BpfRecorderClient, *api_bpfrecorder.ProfileRequest) {
	fake.apparmorForProfileMutex.RLock()
	defer fake.apparmorForProfileMutex.RUnlock()
	argsForCall := fake.apparmorForProfileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) ApparmorForProfileReturns(result1 *api_bpfrecorder.ApparmorResponse, result2 error) {
	fake.apparmorForProfileMutex.Lock()
	defer fake.apparmorForProfileMutex.Unlock()
	fake.ApparmorForProfileStub = nil
	fake.apparmorForProfileReturns = struct {
		result1 *api_bpfrecorder.ApparmorResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ApparmorForProfileReturnsOnCall(i int, result1 *api_bpfrecorder.ApparmorResponse, result2 error) {
	fake.apparmorForProfileMutex.Lock()
	defer fake.apparmorForProfileMutex.Unlock()
	fake.ApparmorForProfileStub = nil
	if fake.apparmorForProfileReturnsOnCall == nil {
		fake.apparmorForProfileReturnsOnCall = make(map[int]struct {
			result1 *api_bpfrecorder.ApparmorResponse
			result2 error
		})
	}
	fake.apparmorForProfileReturnsOnCall[i] = struct {
		result1 *api_bpfrecorder.ApparmorResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Avcs(arg1 context.Context, arg2 api_enricher.EnricherClient, arg3 *api_enricher.AvcRequest) (*api_enricher.AvcResponse, error) {
	fake.avcsMutex.Lock()
	ret, specificReturn := fake.avcsReturnsOnCall[len(fake.avcsArgsForCall)]
	fake.avcsArgsForCall = append(fake.avcsArgsForCall, struct {
		arg1 context.Context
		arg2 api_enricher.EnricherClient
		arg3 *api_enricher.AvcRequest
	}{arg1, arg2, arg3})
	stub := fake.AvcsStub
	fakeReturns := fake.avcsReturns
	fake.recordInvocation("Avcs", []interface{}{arg1, arg2, arg3})
	fake.avcsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) AvcsCallCount() int {
	fake.avcsMutex.RLock()
	defer fake.avcsMutex.RUnlock()
	return len(fake.avcsArgsForCall)
}

func (fake *FakeImpl) AvcsCalls(stub func(context.Context, api_enricher.EnricherClient, *api_enricher.AvcRequest) (*api_enricher.AvcResponse, error)) {
	fake.avcsMutex.Lock()
	defer fake.avcsMutex.Unlock()
	fake.AvcsStub = stub
}

func (fake *FakeImpl) AvcsArgsForCall(i int) (context.Context, api_enricher.EnricherClient, *api_enricher.AvcRequest) {
	fake.avcsMutex.RLock()
	defer fake.avcsMutex.RUnlock()
	argsForCall := fake.avcsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) AvcsReturns(result1 *api_enricher.AvcResponse, result2 error) {
	fake.avcsMutex.Lock()
	defer fake.avcsMutex.Unlock()
	fake.AvcsStub = nil
	fake.avcsReturns = struct {
		result1 *api_enricher.AvcResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) AvcsReturnsOnCall(i int, result1 *api_enricher.AvcResponse, result2 error) {
	fake.avcsMutex.Lock()
	defer fake.avcsMutex.Unlock()
	fake.AvcsStub = nil
	if fake.avcsReturnsOnCall == nil {
		fake.avcsReturnsOnCall = make(map[int]struct {
			result1 *api_enricher.AvcResponse
			result2 error
		})
	}
	fake.avcsReturnsOnCall[i] = struct {
		result1 *api_enricher.AvcResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ClientGet(arg1 context.Context, arg2 client.Client, arg3 client.ObjectKey, arg4 client.Object) error {
	fake.clientGetMutex.Lock()
	ret, specificReturn := fake.clientGetReturnsOnCall[len(fake.clientGetArgsForCall)]
	fake.clientGetArgsForCall = append(fake.clientGetArgsForCall, struct {
		arg1 context.Context
		arg2 client.Client
		arg3 client.ObjectKey
		arg4 client.Object
	}{arg1, arg2, arg3, arg4})
	stub := fake.ClientGetStub
	fakeReturns := fake.clientGetReturns
	fake.recordInvocation("ClientGet", []interface{}{arg1, arg2, arg3, arg4})
	fake.clientGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) ClientGetCallCount() int {
	fake.clientGetMutex.RLock()
	defer fake.clientGetMutex.RUnlock()
	return len(fake.clientGetArgsForCall)
}

func (fake *FakeImpl) ClientGetCalls(stub func(context.Context, client.Client, client.ObjectKey, client.Object) error) {
	fake.clientGetMutex.Lock()
	defer fake.clientGetMutex.Unlock()
	fake.ClientGetStub = stub
}

func (fake *FakeImpl) ClientGetArgsForCall(i int) (context.Context, client.Client, client.ObjectKey, client.Object) {
	fake.clientGetMutex.RLock()
	defer fake.clientGetMutex.RUnlock()
	argsForCall := fake.clientGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeImpl) ClientGetReturns(result1 error) {
	fake.clientGetMutex.Lock()
	defer fake.clientGetMutex.Unlock()
	fake.ClientGetStub = nil
	fake.clientGetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) ClientGetReturnsOnCall(i int, result1 error) {
	fake.clientGetMutex.Lock()
	defer fake.clientGetMutex.Unlock()
	fake.ClientGetStub = nil
	if fake.clientGetReturnsOnCall == nil {
		fake.clientGetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.clientGetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) CreateOrUpdate(arg1 context.Context, arg2 client.Client, arg3 client.Object, arg4 controllerutil.MutateFn) (controllerutil.OperationResult, error) {
	fake.createOrUpdateMutex.Lock()
	ret, specificReturn := fake.createOrUpdateReturnsOnCall[len(fake.createOrUpdateArgsForCall)]
	fake.createOrUpdateArgsForCall = append(fake.createOrUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 client.Client
		arg3 client.Object
		arg4 controllerutil.MutateFn
	}{arg1, arg2, arg3, arg4})
	stub := fake.CreateOrUpdateStub
	fakeReturns := fake.createOrUpdateReturns
	fake.recordInvocation("CreateOrUpdate", []interface{}{arg1, arg2, arg3, arg4})
	fake.createOrUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) CreateOrUpdateCallCount() int {
	fake.createOrUpdateMutex.RLock()
	defer fake.createOrUpdateMutex.RUnlock()
	return len(fake.createOrUpdateArgsForCall)
}

func (fake *FakeImpl) CreateOrUpdateCalls(stub func(context.Context, client.Client, client.Object, controllerutil.MutateFn) (controllerutil.OperationResult, error)) {
	fake.createOrUpdateMutex.Lock()
	defer fake.createOrUpdateMutex.Unlock()
	fake.CreateOrUpdateStub = stub
}

func (fake *FakeImpl) CreateOrUpdateArgsForCall(i int) (context.Context, client.Client, client.Object, controllerutil.MutateFn) {
	fake.createOrUpdateMutex.RLock()
	defer fake.createOrUpdateMutex.RUnlock()
	argsForCall := fake.createOrUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeImpl) CreateOrUpdateReturns(result1 controllerutil.OperationResult, result2 error) {
	fake.createOrUpdateMutex.Lock()
	defer fake.createOrUpdateMutex.Unlock()
	fake.CreateOrUpdateStub = nil
	fake.createOrUpdateReturns = struct {
		result1 controllerutil.OperationResult
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) CreateOrUpdateReturnsOnCall(i int, result1 controllerutil.OperationResult, result2 error) {
	fake.createOrUpdateMutex.Lock()
	defer fake.createOrUpdateMutex.Unlock()
	fake.CreateOrUpdateStub = nil
	if fake.createOrUpdateReturnsOnCall == nil {
		fake.createOrUpdateReturnsOnCall = make(map[int]struct {
			result1 controllerutil.OperationResult
			result2 error
		})
	}
	fake.createOrUpdateReturnsOnCall[i] = struct {
		result1 controllerutil.OperationResult
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) DialBpfRecorder() (*grpc.ClientConn, context.CancelFunc, error) {
	fake.dialBpfRecorderMutex.Lock()
	ret, specificReturn := fake.dialBpfRecorderReturnsOnCall[len(fake.dialBpfRecorderArgsForCall)]
	fake.dialBpfRecorderArgsForCall = append(fake.dialBpfRecorderArgsForCall, struct {
	}{})
	stub := fake.DialBpfRecorderStub
	fakeReturns := fake.dialBpfRecorderReturns
	fake.recordInvocation("DialBpfRecorder", []interface{}{})
	fake.dialBpfRecorderMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeImpl) DialBpfRecorderCallCount() int {
	fake.dialBpfRecorderMutex.RLock()
	defer fake.dialBpfRecorderMutex.RUnlock()
	return len(fake.dialBpfRecorderArgsForCall)
}

func (fake *FakeImpl) DialBpfRecorderCalls(stub func() (*grpc.ClientConn, context.CancelFunc, error)) {
	fake.dialBpfRecorderMutex.Lock()
	defer fake.dialBpfRecorderMutex.Unlock()
	fake.DialBpfRecorderStub = stub
}

func (fake *FakeImpl) DialBpfRecorderReturns(result1 *grpc.ClientConn, result2 context.CancelFunc, result3 error) {
	fake.dialBpfRecorderMutex.Lock()
	defer fake.dialBpfRecorderMutex.Unlock()
	fake.DialBpfRecorderStub = nil
	fake.dialBpfRecorderReturns = struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeImpl) DialBpfRecorderReturnsOnCall(i int, result1 *grpc.ClientConn, result2 context.CancelFunc, result3 error) {
	fake.dialBpfRecorderMutex.Lock()
	defer fake.dialBpfRecorderMutex.Unlock()
	fake.DialBpfRecorderStub = nil
	if fake.dialBpfRecorderReturnsOnCall == nil {
		fake.dialBpfRecorderReturnsOnCall = make(map[int]struct {
			result1 *grpc.ClientConn
			result2 context.CancelFunc
			result3 error
		})
	}
	fake.dialBpfRecorderReturnsOnCall[i] = struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeImpl) DialEnricher() (*grpc.ClientConn, context.CancelFunc, error) {
	fake.dialEnricherMutex.Lock()
	ret, specificReturn := fake.dialEnricherReturnsOnCall[len(fake.dialEnricherArgsForCall)]
	fake.dialEnricherArgsForCall = append(fake.dialEnricherArgsForCall, struct {
	}{})
	stub := fake.DialEnricherStub
	fakeReturns := fake.dialEnricherReturns
	fake.recordInvocation("DialEnricher", []interface{}{})
	fake.dialEnricherMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeImpl) DialEnricherCallCount() int {
	fake.dialEnricherMutex.RLock()
	defer fake.dialEnricherMutex.RUnlock()
	return len(fake.dialEnricherArgsForCall)
}

func (fake *FakeImpl) DialEnricherCalls(stub func() (*grpc.ClientConn, context.CancelFunc, error)) {
	fake.dialEnricherMutex.Lock()
	defer fake.dialEnricherMutex.Unlock()
	fake.DialEnricherStub = stub
}

func (fake *FakeImpl) DialEnricherReturns(result1 *grpc.ClientConn, result2 context.CancelFunc, result3 error) {
	fake.dialEnricherMutex.Lock()
	defer fake.dialEnricherMutex.Unlock()
	fake.DialEnricherStub = nil
	fake.dialEnricherReturns = struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeImpl) DialEnricherReturnsOnCall(i int, result1 *grpc.ClientConn, result2 context.CancelFunc, result3 error) {
	fake.dialEnricherMutex.Lock()
	defer fake.dialEnricherMutex.Unlock()
	fake.DialEnricherStub = nil
	if fake.dialEnricherReturnsOnCall == nil {
		fake.dialEnricherReturnsOnCall = make(map[int]struct {
			result1 *grpc.ClientConn
			result2 context.CancelFunc
			result3 error
		})
	}
	fake.dialEnricherReturnsOnCall[i] = struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeImpl) GetPod(arg1 context.Context, arg2 client.Client, arg3 client.ObjectKey) (*v1.Pod, error) {
	fake.getPodMutex.Lock()
	ret, specificReturn := fake.getPodReturnsOnCall[len(fake.getPodArgsForCall)]
	fake.getPodArgsForCall = append(fake.getPodArgsForCall, struct {
		arg1 context.Context
		arg2 client.Client
		arg3 client.ObjectKey
	}{arg1, arg2, arg3})
	stub := fake.GetPodStub
	fakeReturns := fake.getPodReturns
	fake.recordInvocation("GetPod", []interface{}{arg1, arg2, arg3})
	fake.getPodMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) GetPodCallCount() int {
	fake.getPodMutex.RLock()
	defer fake.getPodMutex.RUnlock()
	return len(fake.getPodArgsForCall)
}

func (fake *FakeImpl) GetPodCalls(stub func(context.Context, client.Client, client.ObjectKey) (*v1.Pod, error)) {
	fake.getPodMutex.Lock()
	defer fake.getPodMutex.Unlock()
	fake.GetPodStub = stub
}

func (fake *FakeImpl) GetPodArgsForCall(i int) (context.Context, client.Client, client.ObjectKey) {
	fake.getPodMutex.RLock()
	defer fake.getPodMutex.RUnlock()
	argsForCall := fake.getPodArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) GetPodReturns(result1 *v1.Pod, result2 error) {
	fake.getPodMutex.Lock()
	defer fake.getPodMutex.Unlock()
	fake.GetPodStub = nil
	fake.getPodReturns = struct {
		result1 *v1.Pod
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetPodReturnsOnCall(i int, result1 *v1.Pod, result2 error) {
	fake.getPodMutex.Lock()
	defer fake.getPodMutex.Unlock()
	fake.GetPodStub = nil
	if fake.getPodReturnsOnCall == nil {
		fake.getPodReturnsOnCall = make(map[int]struct {
			result1 *v1.Pod
			result2 error
		})
	}
	fake.getPodReturnsOnCall[i] = struct {
		result1 *v1.Pod
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetRecording(arg1 context.Context, arg2 client.Client, arg3 client.ObjectKey) (*v1alpha1.ProfileRecording, error) {
	fake.getRecordingMutex.Lock()
	ret, specificReturn := fake.getRecordingReturnsOnCall[len(fake.getRecordingArgsForCall)]
	fake.getRecordingArgsForCall = append(fake.getRecordingArgsForCall, struct {
		arg1 context.Context
		arg2 client.Client
		arg3 client.ObjectKey
	}{arg1, arg2, arg3})
	stub := fake.GetRecordingStub
	fakeReturns := fake.getRecordingReturns
	fake.recordInvocation("GetRecording", []interface{}{arg1, arg2, arg3})
	fake.getRecordingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) GetRecordingCallCount() int {
	fake.getRecordingMutex.RLock()
	defer fake.getRecordingMutex.RUnlock()
	return len(fake.getRecordingArgsForCall)
}

func (fake *FakeImpl) GetRecordingCalls(stub func(context.Context, client.Client, client.ObjectKey) (*v1alpha1.ProfileRecording, error)) {
	fake.getRecordingMutex.Lock()
	defer fake.getRecordingMutex.Unlock()
	fake.GetRecordingStub = stub
}

func (fake *FakeImpl) GetRecordingArgsForCall(i int) (context.Context, client.Client, client.ObjectKey) {
	fake.getRecordingMutex.RLock()
	defer fake.getRecordingMutex.RUnlock()
	argsForCall := fake.getRecordingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) GetRecordingReturns(result1 *v1alpha1.ProfileRecording, result2 error) {
	fake.getRecordingMutex.Lock()
	defer fake.getRecordingMutex.Unlock()
	fake.GetRecordingStub = nil
	fake.getRecordingReturns = struct {
		result1 *v1alpha1.ProfileRecording
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetRecordingReturnsOnCall(i int, result1 *v1alpha1.ProfileRecording, result2 error) {
	fake.getRecordingMutex.Lock()
	defer fake.getRecordingMutex.Unlock()
	fake.GetRecordingStub = nil
	if fake.getRecordingReturnsOnCall == nil {
		fake.getRecordingReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ProfileRecording
			result2 error
		})
	}
	fake.getRecordingReturnsOnCall[i] = struct {
		result1 *v1alpha1.ProfileRecording
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetSPOD(arg1 context.Context, arg2 client.Client) (*v1alpha1a.SecurityProfilesOperatorDaemon, error) {
	fake.getSPODMutex.Lock()
	ret, specificReturn := fake.getSPODReturnsOnCall[len(fake.getSPODArgsForCall)]
	fake.getSPODArgsForCall = append(fake.getSPODArgsForCall, struct {
		arg1 context.Context
		arg2 client.Client
	}{arg1, arg2})
	stub := fake.GetSPODStub
	fakeReturns := fake.getSPODReturns
	fake.recordInvocation("GetSPOD", []interface{}{arg1, arg2})
	fake.getSPODMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) GetSPODCallCount() int {
	fake.getSPODMutex.RLock()
	defer fake.getSPODMutex.RUnlock()
	return len(fake.getSPODArgsForCall)
}

func (fake *FakeImpl) GetSPODCalls(stub func(context.Context, client.Client) (*v1alpha1a.SecurityProfilesOperatorDaemon, error)) {
	fake.getSPODMutex.Lock()
	defer fake.getSPODMutex.Unlock()
	fake.GetSPODStub = stub
}

func (fake *FakeImpl) GetSPODArgsForCall(i int) (context.Context, client.Client) {
	fake.getSPODMutex.RLock()
	defer fake.getSPODMutex.RUnlock()
	argsForCall := fake.getSPODArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) GetSPODReturns(result1 *v1alpha1a.SecurityProfilesOperatorDaemon, result2 error) {
	fake.getSPODMutex.Lock()
	defer fake.getSPODMutex.Unlock()
	fake.GetSPODStub = nil
	fake.getSPODReturns = struct {
		result1 *v1alpha1a.SecurityProfilesOperatorDaemon
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetSPODReturnsOnCall(i int, result1 *v1alpha1a.SecurityProfilesOperatorDaemon, result2 error) {
	fake.getSPODMutex.Lock()
	defer fake.getSPODMutex.Unlock()
	fake.GetSPODStub = nil
	if fake.getSPODReturnsOnCall == nil {
		fake.getSPODReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1a.SecurityProfilesOperatorDaemon
			result2 error
		})
	}
	fake.getSPODReturnsOnCall[i] = struct {
		result1 *v1alpha1a.SecurityProfilesOperatorDaemon
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GoArchToSeccompArch(arg1 string) (seccomp.Arch, error) {
	fake.goArchToSeccompArchMutex.Lock()
	ret, specificReturn := fake.goArchToSeccompArchReturnsOnCall[len(fake.goArchToSeccompArchArgsForCall)]
	fake.goArchToSeccompArchArgsForCall = append(fake.goArchToSeccompArchArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GoArchToSeccompArchStub
	fakeReturns := fake.goArchToSeccompArchReturns
	fake.recordInvocation("GoArchToSeccompArch", []interface{}{arg1})
	fake.goArchToSeccompArchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) GoArchToSeccompArchCallCount() int {
	fake.goArchToSeccompArchMutex.RLock()
	defer fake.goArchToSeccompArchMutex.RUnlock()
	return len(fake.goArchToSeccompArchArgsForCall)
}

func (fake *FakeImpl) GoArchToSeccompArchCalls(stub func(string) (seccomp.Arch, error)) {
	fake.goArchToSeccompArchMutex.Lock()
	defer fake.goArchToSeccompArchMutex.Unlock()
	fake.GoArchToSeccompArchStub = stub
}

func (fake *FakeImpl) GoArchToSeccompArchArgsForCall(i int) string {
	fake.goArchToSeccompArchMutex.RLock()
	defer fake.goArchToSeccompArchMutex.RUnlock()
	argsForCall := fake.goArchToSeccompArchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) GoArchToSeccompArchReturns(result1 seccomp.Arch, result2 error) {
	fake.goArchToSeccompArchMutex.Lock()
	defer fake.goArchToSeccompArchMutex.Unlock()
	fake.GoArchToSeccompArchStub = nil
	fake.goArchToSeccompArchReturns = struct {
		result1 seccomp.Arch
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GoArchToSeccompArchReturnsOnCall(i int, result1 seccomp.Arch, result2 error) {
	fake.goArchToSeccompArchMutex.Lock()
	defer fake.goArchToSeccompArchMutex.Unlock()
	fake.GoArchToSeccompArchStub = nil
	if fake.goArchToSeccompArchReturnsOnCall == nil {
		fake.goArchToSeccompArchReturnsOnCall = make(map[int]struct {
			result1 seccomp.Arch
			result2 error
		})
	}
	fake.goArchToSeccompArchReturnsOnCall[i] = struct {
		result1 seccomp.Arch
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ManagerGetClient(arg1 manager.Manager) client.Client {
	fake.managerGetClientMutex.Lock()
	ret, specificReturn := fake.managerGetClientReturnsOnCall[len(fake.managerGetClientArgsForCall)]
	fake.managerGetClientArgsForCall = append(fake.managerGetClientArgsForCall, struct {
		arg1 manager.Manager
	}{arg1})
	stub := fake.ManagerGetClientStub
	fakeReturns := fake.managerGetClientReturns
	fake.recordInvocation("ManagerGetClient", []interface{}{arg1})
	fake.managerGetClientMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) ManagerGetClientCallCount() int {
	fake.managerGetClientMutex.RLock()
	defer fake.managerGetClientMutex.RUnlock()
	return len(fake.managerGetClientArgsForCall)
}

func (fake *FakeImpl) ManagerGetClientCalls(stub func(manager.Manager) client.Client) {
	fake.managerGetClientMutex.Lock()
	defer fake.managerGetClientMutex.Unlock()
	fake.ManagerGetClientStub = stub
}

func (fake *FakeImpl) ManagerGetClientArgsForCall(i int) manager.Manager {
	fake.managerGetClientMutex.RLock()
	defer fake.managerGetClientMutex.RUnlock()
	argsForCall := fake.managerGetClientArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) ManagerGetClientReturns(result1 client.Client) {
	fake.managerGetClientMutex.Lock()
	defer fake.managerGetClientMutex.Unlock()
	fake.ManagerGetClientStub = nil
	fake.managerGetClientReturns = struct {
		result1 client.Client
	}{result1}
}

func (fake *FakeImpl) ManagerGetClientReturnsOnCall(i int, result1 client.Client) {
	fake.managerGetClientMutex.Lock()
	defer fake.managerGetClientMutex.Unlock()
	fake.ManagerGetClientStub = nil
	if fake.managerGetClientReturnsOnCall == nil {
		fake.managerGetClientReturnsOnCall = make(map[int]struct {
			result1 client.Client
		})
	}
	fake.managerGetClientReturnsOnCall[i] = struct {
		result1 client.Client
	}{result1}
}

func (fake *FakeImpl) ManagerGetEventRecorderFor(arg1 manager.Manager, arg2 string) record.EventRecorder {
	fake.managerGetEventRecorderForMutex.Lock()
	ret, specificReturn := fake.managerGetEventRecorderForReturnsOnCall[len(fake.managerGetEventRecorderForArgsForCall)]
	fake.managerGetEventRecorderForArgsForCall = append(fake.managerGetEventRecorderForArgsForCall, struct {
		arg1 manager.Manager
		arg2 string
	}{arg1, arg2})
	stub := fake.ManagerGetEventRecorderForStub
	fakeReturns := fake.managerGetEventRecorderForReturns
	fake.recordInvocation("ManagerGetEventRecorderFor", []interface{}{arg1, arg2})
	fake.managerGetEventRecorderForMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) ManagerGetEventRecorderForCallCount() int {
	fake.managerGetEventRecorderForMutex.RLock()
	defer fake.managerGetEventRecorderForMutex.RUnlock()
	return len(fake.managerGetEventRecorderForArgsForCall)
}

func (fake *FakeImpl) ManagerGetEventRecorderForCalls(stub func(manager.Manager, string) record.EventRecorder) {
	fake.managerGetEventRecorderForMutex.Lock()
	defer fake.managerGetEventRecorderForMutex.Unlock()
	fake.ManagerGetEventRecorderForStub = stub
}

func (fake *FakeImpl) ManagerGetEventRecorderForArgsForCall(i int) (manager.Manager, string) {
	fake.managerGetEventRecorderForMutex.RLock()
	defer fake.managerGetEventRecorderForMutex.RUnlock()
	argsForCall := fake.managerGetEventRecorderForArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) ManagerGetEventRecorderForReturns(result1 record.EventRecorder) {
	fake.managerGetEventRecorderForMutex.Lock()
	defer fake.managerGetEventRecorderForMutex.Unlock()
	fake.ManagerGetEventRecorderForStub = nil
	fake.managerGetEventRecorderForReturns = struct {
		result1 record.EventRecorder
	}{result1}
}

func (fake *FakeImpl) ManagerGetEventRecorderForReturnsOnCall(i int, result1 record.EventRecorder) {
	fake.managerGetEventRecorderForMutex.Lock()
	defer fake.managerGetEventRecorderForMutex.Unlock()
	fake.ManagerGetEventRecorderForStub = nil
	if fake.managerGetEventRecorderForReturnsOnCall == nil {
		fake.managerGetEventRecorderForReturnsOnCall = make(map[int]struct {
			result1 record.EventRecorder
		})
	}
	fake.managerGetEventRecorderForReturnsOnCall[i] = struct {
		result1 record.EventRecorder
	}{result1}
}

func (fake *FakeImpl) NewClient(arg1 controllerruntime.Manager) (client.Client, error) {
	fake.newClientMutex.Lock()
	ret, specificReturn := fake.newClientReturnsOnCall[len(fake.newClientArgsForCall)]
	fake.newClientArgsForCall = append(fake.newClientArgsForCall, struct {
		arg1 controllerruntime.Manager
	}{arg1})
	stub := fake.NewClientStub
	fakeReturns := fake.newClientReturns
	fake.recordInvocation("NewClient", []interface{}{arg1})
	fake.newClientMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) NewClientCallCount() int {
	fake.newClientMutex.RLock()
	defer fake.newClientMutex.RUnlock()
	return len(fake.newClientArgsForCall)
}

func (fake *FakeImpl) NewClientCalls(stub func(controllerruntime.Manager) (client.Client, error)) {
	fake.newClientMutex.Lock()
	defer fake.newClientMutex.Unlock()
	fake.NewClientStub = stub
}

func (fake *FakeImpl) NewClientArgsForCall(i int) controllerruntime.Manager {
	fake.newClientMutex.RLock()
	defer fake.newClientMutex.RUnlock()
	argsForCall := fake.newClientArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) NewClientReturns(result1 client.Client, result2 error) {
	fake.newClientMutex.Lock()
	defer fake.newClientMutex.Unlock()
	fake.NewClientStub = nil
	fake.newClientReturns = struct {
		result1 client.Client
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewClientReturnsOnCall(i int, result1 client.Client, result2 error) {
	fake.newClientMutex.Lock()
	defer fake.newClientMutex.Unlock()
	fake.NewClientStub = nil
	if fake.newClientReturnsOnCall == nil {
		fake.newClientReturnsOnCall = make(map[int]struct {
			result1 client.Client
			result2 error
		})
	}
	fake.newClientReturnsOnCall[i] = struct {
		result1 client.Client
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewControllerManagedBy(arg1 manager.Manager, arg2 string, arg3 func(obj runtime.Object) bool, arg4 func(obj runtime.Object) bool, arg5 reconcile.Reconciler) error {
	fake.newControllerManagedByMutex.Lock()
	ret, specificReturn := fake.newControllerManagedByReturnsOnCall[len(fake.newControllerManagedByArgsForCall)]
	fake.newControllerManagedByArgsForCall = append(fake.newControllerManagedByArgsForCall, struct {
		arg1 manager.Manager
		arg2 string
		arg3 func(obj runtime.Object) bool
		arg4 func(obj runtime.Object) bool
		arg5 reconcile.Reconciler
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.NewControllerManagedByStub
	fakeReturns := fake.newControllerManagedByReturns
	fake.recordInvocation("NewControllerManagedBy", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.newControllerManagedByMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) NewControllerManagedByCallCount() int {
	fake.newControllerManagedByMutex.RLock()
	defer fake.newControllerManagedByMutex.RUnlock()
	return len(fake.newControllerManagedByArgsForCall)
}

func (fake *FakeImpl) NewControllerManagedByCalls(stub func(manager.Manager, string, func(obj runtime.Object) bool, func(obj runtime.Object) bool, reconcile.Reconciler) error) {
	fake.newControllerManagedByMutex.Lock()
	defer fake.newControllerManagedByMutex.Unlock()
	fake.NewControllerManagedByStub = stub
}

func (fake *FakeImpl) NewControllerManagedByArgsForCall(i int) (manager.Manager, string, func(obj runtime.Object) bool, func(obj runtime.Object) bool, reconcile.Reconciler) {
	fake.newControllerManagedByMutex.RLock()
	defer fake.newControllerManagedByMutex.RUnlock()
	argsForCall := fake.newControllerManagedByArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeImpl) NewControllerManagedByReturns(result1 error) {
	fake.newControllerManagedByMutex.Lock()
	defer fake.newControllerManagedByMutex.Unlock()
	fake.NewControllerManagedByStub = nil
	fake.newControllerManagedByReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) NewControllerManagedByReturnsOnCall(i int, result1 error) {
	fake.newControllerManagedByMutex.Lock()
	defer fake.newControllerManagedByMutex.Unlock()
	fake.NewControllerManagedByStub = nil
	if fake.newControllerManagedByReturnsOnCall == nil {
		fake.newControllerManagedByReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.newControllerManagedByReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) ResetAvcs(arg1 context.Context, arg2 api_enricher.EnricherClient, arg3 *api_enricher.AvcRequest) error {
	fake.resetAvcsMutex.Lock()
	ret, specificReturn := fake.resetAvcsReturnsOnCall[len(fake.resetAvcsArgsForCall)]
	fake.resetAvcsArgsForCall = append(fake.resetAvcsArgsForCall, struct {
		arg1 context.Context
		arg2 api_enricher.EnricherClient
		arg3 *api_enricher.AvcRequest
	}{arg1, arg2, arg3})
	stub := fake.ResetAvcsStub
	fakeReturns := fake.resetAvcsReturns
	fake.recordInvocation("ResetAvcs", []interface{}{arg1, arg2, arg3})
	fake.resetAvcsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) ResetAvcsCallCount() int {
	fake.resetAvcsMutex.RLock()
	defer fake.resetAvcsMutex.RUnlock()
	return len(fake.resetAvcsArgsForCall)
}

func (fake *FakeImpl) ResetAvcsCalls(stub func(context.Context, api_enricher.EnricherClient, *api_enricher.AvcRequest) error) {
	fake.resetAvcsMutex.Lock()
	defer fake.resetAvcsMutex.Unlock()
	fake.ResetAvcsStub = stub
}

func (fake *FakeImpl) ResetAvcsArgsForCall(i int) (context.Context, api_enricher.EnricherClient, *api_enricher.AvcRequest) {
	fake.resetAvcsMutex.RLock()
	defer fake.resetAvcsMutex.RUnlock()
	argsForCall := fake.resetAvcsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) ResetAvcsReturns(result1 error) {
	fake.resetAvcsMutex.Lock()
	defer fake.resetAvcsMutex.Unlock()
	fake.ResetAvcsStub = nil
	fake.resetAvcsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) ResetAvcsReturnsOnCall(i int, result1 error) {
	fake.resetAvcsMutex.Lock()
	defer fake.resetAvcsMutex.Unlock()
	fake.ResetAvcsStub = nil
	if fake.resetAvcsReturnsOnCall == nil {
		fake.resetAvcsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetAvcsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) ResetSyscalls(arg1 context.Context, arg2 api_enricher.EnricherClient, arg3 *api_enricher.SyscallsRequest) error {
	fake.resetSyscallsMutex.Lock()
	ret, specificReturn := fake.resetSyscallsReturnsOnCall[len(fake.resetSyscallsArgsForCall)]
	fake.resetSyscallsArgsForCall = append(fake.resetSyscallsArgsForCall, struct {
		arg1 context.Context
		arg2 api_enricher.EnricherClient
		arg3 *api_enricher.SyscallsRequest
	}{arg1, arg2, arg3})
	stub := fake.ResetSyscallsStub
	fakeReturns := fake.resetSyscallsReturns
	fake.recordInvocation("ResetSyscalls", []interface{}{arg1, arg2, arg3})
	fake.resetSyscallsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) ResetSyscallsCallCount() int {
	fake.resetSyscallsMutex.RLock()
	defer fake.resetSyscallsMutex.RUnlock()
	return len(fake.resetSyscallsArgsForCall)
}

func (fake *FakeImpl) ResetSyscallsCalls(stub func(context.Context, api_enricher.EnricherClient, *api_enricher.SyscallsRequest) error) {
	fake.resetSyscallsMutex.Lock()
	defer fake.resetSyscallsMutex.Unlock()
	fake.ResetSyscallsStub = stub
}

func (fake *FakeImpl) ResetSyscallsArgsForCall(i int) (context.Context, api_enricher.EnricherClient, *api_enricher.SyscallsRequest) {
	fake.resetSyscallsMutex.RLock()
	defer fake.resetSyscallsMutex.RUnlock()
	argsForCall := fake.resetSyscallsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) ResetSyscallsReturns(result1 error) {
	fake.resetSyscallsMutex.Lock()
	defer fake.resetSyscallsMutex.Unlock()
	fake.ResetSyscallsStub = nil
	fake.resetSyscallsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) ResetSyscallsReturnsOnCall(i int, result1 error) {
	fake.resetSyscallsMutex.Lock()
	defer fake.resetSyscallsMutex.Unlock()
	fake.ResetSyscallsStub = nil
	if fake.resetSyscallsReturnsOnCall == nil {
		fake.resetSyscallsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetSyscallsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) StartBpfRecorder(arg1 context.Context, arg2 api_bpfrecorder.BpfRecorderClient) error {
	fake.startBpfRecorderMutex.Lock()
	ret, specificReturn := fake.startBpfRecorderReturnsOnCall[len(fake.startBpfRecorderArgsForCall)]
	fake.startBpfRecorderArgsForCall = append(fake.startBpfRecorderArgsForCall, struct {
		arg1 context.Context
		arg2 api_bpfrecorder.BpfRecorderClient
	}{arg1, arg2})
	stub := fake.StartBpfRecorderStub
	fakeReturns := fake.startBpfRecorderReturns
	fake.recordInvocation("StartBpfRecorder", []interface{}{arg1, arg2})
	fake.startBpfRecorderMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) StartBpfRecorderCallCount() int {
	fake.startBpfRecorderMutex.RLock()
	defer fake.startBpfRecorderMutex.RUnlock()
	return len(fake.startBpfRecorderArgsForCall)
}

func (fake *FakeImpl) StartBpfRecorderCalls(stub func(context.Context, api_bpfrecorder.BpfRecorderClient) error) {
	fake.startBpfRecorderMutex.Lock()
	defer fake.startBpfRecorderMutex.Unlock()
	fake.StartBpfRecorderStub = stub
}

func (fake *FakeImpl) StartBpfRecorderArgsForCall(i int) (context.Context, api_bpfrecorder.BpfRecorderClient) {
	fake.startBpfRecorderMutex.RLock()
	defer fake.startBpfRecorderMutex.RUnlock()
	argsForCall := fake.startBpfRecorderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) StartBpfRecorderReturns(result1 error) {
	fake.startBpfRecorderMutex.Lock()
	defer fake.startBpfRecorderMutex.Unlock()
	fake.StartBpfRecorderStub = nil
	fake.startBpfRecorderReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) StartBpfRecorderReturnsOnCall(i int, result1 error) {
	fake.startBpfRecorderMutex.Lock()
	defer fake.startBpfRecorderMutex.Unlock()
	fake.StartBpfRecorderStub = nil
	if fake.startBpfRecorderReturnsOnCall == nil {
		fake.startBpfRecorderReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startBpfRecorderReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) StopBpfRecorder(arg1 context.Context, arg2 api_bpfrecorder.BpfRecorderClient) error {
	fake.stopBpfRecorderMutex.Lock()
	ret, specificReturn := fake.stopBpfRecorderReturnsOnCall[len(fake.stopBpfRecorderArgsForCall)]
	fake.stopBpfRecorderArgsForCall = append(fake.stopBpfRecorderArgsForCall, struct {
		arg1 context.Context
		arg2 api_bpfrecorder.BpfRecorderClient
	}{arg1, arg2})
	stub := fake.StopBpfRecorderStub
	fakeReturns := fake.stopBpfRecorderReturns
	fake.recordInvocation("StopBpfRecorder", []interface{}{arg1, arg2})
	fake.stopBpfRecorderMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) StopBpfRecorderCallCount() int {
	fake.stopBpfRecorderMutex.RLock()
	defer fake.stopBpfRecorderMutex.RUnlock()
	return len(fake.stopBpfRecorderArgsForCall)
}

func (fake *FakeImpl) StopBpfRecorderCalls(stub func(context.Context, api_bpfrecorder.BpfRecorderClient) error) {
	fake.stopBpfRecorderMutex.Lock()
	defer fake.stopBpfRecorderMutex.Unlock()
	fake.StopBpfRecorderStub = stub
}

func (fake *FakeImpl) StopBpfRecorderArgsForCall(i int) (context.Context, api_bpfrecorder.BpfRecorderClient) {
	fake.stopBpfRecorderMutex.RLock()
	defer fake.stopBpfRecorderMutex.RUnlock()
	argsForCall := fake.stopBpfRecorderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) StopBpfRecorderReturns(result1 error) {
	fake.stopBpfRecorderMutex.Lock()
	defer fake.stopBpfRecorderMutex.Unlock()
	fake.StopBpfRecorderStub = nil
	fake.stopBpfRecorderReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) StopBpfRecorderReturnsOnCall(i int, result1 error) {
	fake.stopBpfRecorderMutex.Lock()
	defer fake.stopBpfRecorderMutex.Unlock()
	fake.StopBpfRecorderStub = nil
	if fake.stopBpfRecorderReturnsOnCall == nil {
		fake.stopBpfRecorderReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stopBpfRecorderReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) Syscalls(arg1 context.Context, arg2 api_enricher.EnricherClient, arg3 *api_enricher.SyscallsRequest) (*api_enricher.SyscallsResponse, error) {
	fake.syscallsMutex.Lock()
	ret, specificReturn := fake.syscallsReturnsOnCall[len(fake.syscallsArgsForCall)]
	fake.syscallsArgsForCall = append(fake.syscallsArgsForCall, struct {
		arg1 context.Context
		arg2 api_enricher.EnricherClient
		arg3 *api_enricher.SyscallsRequest
	}{arg1, arg2, arg3})
	stub := fake.SyscallsStub
	fakeReturns := fake.syscallsReturns
	fake.recordInvocation("Syscalls", []interface{}{arg1, arg2, arg3})
	fake.syscallsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) SyscallsCallCount() int {
	fake.syscallsMutex.RLock()
	defer fake.syscallsMutex.RUnlock()
	return len(fake.syscallsArgsForCall)
}

func (fake *FakeImpl) SyscallsCalls(stub func(context.Context, api_enricher.EnricherClient, *api_enricher.SyscallsRequest) (*api_enricher.SyscallsResponse, error)) {
	fake.syscallsMutex.Lock()
	defer fake.syscallsMutex.Unlock()
	fake.SyscallsStub = stub
}

func (fake *FakeImpl) SyscallsArgsForCall(i int) (context.Context, api_enricher.EnricherClient, *api_enricher.SyscallsRequest) {
	fake.syscallsMutex.RLock()
	defer fake.syscallsMutex.RUnlock()
	argsForCall := fake.syscallsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) SyscallsReturns(result1 *api_enricher.SyscallsResponse, result2 error) {
	fake.syscallsMutex.Lock()
	defer fake.syscallsMutex.Unlock()
	fake.SyscallsStub = nil
	fake.syscallsReturns = struct {
		result1 *api_enricher.SyscallsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) SyscallsReturnsOnCall(i int, result1 *api_enricher.SyscallsResponse, result2 error) {
	fake.syscallsMutex.Lock()
	defer fake.syscallsMutex.Unlock()
	fake.SyscallsStub = nil
	if fake.syscallsReturnsOnCall == nil {
		fake.syscallsReturnsOnCall = make(map[int]struct {
			result1 *api_enricher.SyscallsResponse
			result2 error
		})
	}
	fake.syscallsReturnsOnCall[i] = struct {
		result1 *api_enricher.SyscallsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) SyscallsForProfile(arg1 context.Context, arg2 api_bpfrecorder.BpfRecorderClient, arg3 *api_bpfrecorder.ProfileRequest) (*api_bpfrecorder.SyscallsResponse, error) {
	fake.syscallsForProfileMutex.Lock()
	ret, specificReturn := fake.syscallsForProfileReturnsOnCall[len(fake.syscallsForProfileArgsForCall)]
	fake.syscallsForProfileArgsForCall = append(fake.syscallsForProfileArgsForCall, struct {
		arg1 context.Context
		arg2 api_bpfrecorder.BpfRecorderClient
		arg3 *api_bpfrecorder.ProfileRequest
	}{arg1, arg2, arg3})
	stub := fake.SyscallsForProfileStub
	fakeReturns := fake.syscallsForProfileReturns
	fake.recordInvocation("SyscallsForProfile", []interface{}{arg1, arg2, arg3})
	fake.syscallsForProfileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) SyscallsForProfileCallCount() int {
	fake.syscallsForProfileMutex.RLock()
	defer fake.syscallsForProfileMutex.RUnlock()
	return len(fake.syscallsForProfileArgsForCall)
}

func (fake *FakeImpl) SyscallsForProfileCalls(stub func(context.Context, api_bpfrecorder.BpfRecorderClient, *api_bpfrecorder.ProfileRequest) (*api_bpfrecorder.SyscallsResponse, error)) {
	fake.syscallsForProfileMutex.Lock()
	defer fake.syscallsForProfileMutex.Unlock()
	fake.SyscallsForProfileStub = stub
}

func (fake *FakeImpl) SyscallsForProfileArgsForCall(i int) (context.Context, api_bpfrecorder.BpfRecorderClient, *api_bpfrecorder.ProfileRequest) {
	fake.syscallsForProfileMutex.RLock()
	defer fake.syscallsForProfileMutex.RUnlock()
	argsForCall := fake.syscallsForProfileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) SyscallsForProfileReturns(result1 *api_bpfrecorder.SyscallsResponse, result2 error) {
	fake.syscallsForProfileMutex.Lock()
	defer fake.syscallsForProfileMutex.Unlock()
	fake.SyscallsForProfileStub = nil
	fake.syscallsForProfileReturns = struct {
		result1 *api_bpfrecorder.SyscallsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) SyscallsForProfileReturnsOnCall(i int, result1 *api_bpfrecorder.SyscallsResponse, result2 error) {
	fake.syscallsForProfileMutex.Lock()
	defer fake.syscallsForProfileMutex.Unlock()
	fake.SyscallsForProfileStub = nil
	if fake.syscallsForProfileReturnsOnCall == nil {
		fake.syscallsForProfileReturnsOnCall = make(map[int]struct {
			result1 *api_bpfrecorder.SyscallsResponse
			result2 error
		})
	}
	fake.syscallsForProfileReturnsOnCall[i] = struct {
		result1 *api_bpfrecorder.SyscallsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.apparmorForProfileMutex.RLock()
	defer fake.apparmorForProfileMutex.RUnlock()
	fake.avcsMutex.RLock()
	defer fake.avcsMutex.RUnlock()
	fake.clientGetMutex.RLock()
	defer fake.clientGetMutex.RUnlock()
	fake.createOrUpdateMutex.RLock()
	defer fake.createOrUpdateMutex.RUnlock()
	fake.dialBpfRecorderMutex.RLock()
	defer fake.dialBpfRecorderMutex.RUnlock()
	fake.dialEnricherMutex.RLock()
	defer fake.dialEnricherMutex.RUnlock()
	fake.getPodMutex.RLock()
	defer fake.getPodMutex.RUnlock()
	fake.getRecordingMutex.RLock()
	defer fake.getRecordingMutex.RUnlock()
	fake.getSPODMutex.RLock()
	defer fake.getSPODMutex.RUnlock()
	fake.goArchToSeccompArchMutex.RLock()
	defer fake.goArchToSeccompArchMutex.RUnlock()
	fake.managerGetClientMutex.RLock()
	defer fake.managerGetClientMutex.RUnlock()
	fake.managerGetEventRecorderForMutex.RLock()
	defer fake.managerGetEventRecorderForMutex.RUnlock()
	fake.newClientMutex.RLock()
	defer fake.newClientMutex.RUnlock()
	fake.newControllerManagedByMutex.RLock()
	defer fake.newControllerManagedByMutex.RUnlock()
	fake.resetAvcsMutex.RLock()
	defer fake.resetAvcsMutex.RUnlock()
	fake.resetSyscallsMutex.RLock()
	defer fake.resetSyscallsMutex.RUnlock()
	fake.startBpfRecorderMutex.RLock()
	defer fake.startBpfRecorderMutex.RUnlock()
	fake.stopBpfRecorderMutex.RLock()
	defer fake.stopBpfRecorderMutex.RUnlock()
	fake.syscallsMutex.RLock()
	defer fake.syscallsMutex.RUnlock()
	fake.syscallsForProfileMutex.RLock()
	defer fake.syscallsForProfileMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeImpl) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
