/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by counterfeiter. DO NOT EDIT.
package enricherfakes

import (
	"context"
	"io"
	"net"
	"os"
	"sync"

	ttlcache "github.com/jellydator/ttlcache/v3"
	"github.com/nxadm/tail"
	"google.golang.org/grpc"
	v1 "k8s.io/api/core/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"

	api_metrics "sigs.k8s.io/security-profiles-operator/api/grpc/metrics"
	"sigs.k8s.io/security-profiles-operator/internal/pkg/daemon/enricher/auditsource"
	"sigs.k8s.io/security-profiles-operator/internal/pkg/daemon/enricher/types"
)

type FakeImpl struct {
	AddToBacklogStub        func(*ttlcache.Cache[string, []*types.AuditLine], string, []*types.AuditLine)
	addToBacklogMutex       sync.RWMutex
	addToBacklogArgsForCall []struct {
		arg1 *ttlcache.Cache[string, []*types.AuditLine]
		arg2 string
		arg3 []*types.AuditLine
	}
	AuditIncStub        func(api_metrics.MetricsClient) (api_metrics.Metrics_AuditIncClient, error)
	auditIncMutex       sync.RWMutex
	auditIncArgsForCall []struct {
		arg1 api_metrics.MetricsClient
	}
	auditIncReturns struct {
		result1 api_metrics.Metrics_AuditIncClient
		result2 error
	}
	auditIncReturnsOnCall map[int]struct {
		result1 api_metrics.Metrics_AuditIncClient
		result2 error
	}
	ChownStub        func(string, int, int) error
	chownMutex       sync.RWMutex
	chownArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	chownReturns struct {
		result1 error
	}
	chownReturnsOnCall map[int]struct {
		result1 error
	}
	CloseStub        func(*grpc.ClientConn) error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
		arg1 *grpc.ClientConn
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	CmdlineForPIDStub        func(int) (string, error)
	cmdlineForPIDMutex       sync.RWMutex
	cmdlineForPIDArgsForCall []struct {
		arg1 int
	}
	cmdlineForPIDReturns struct {
		result1 string
		result2 error
	}
	cmdlineForPIDReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ContainerIDForPIDStub        func(*ttlcache.Cache[string, string], int) (string, error)
	containerIDForPIDMutex       sync.RWMutex
	containerIDForPIDArgsForCall []struct {
		arg1 *ttlcache.Cache[string, string]
		arg2 int
	}
	containerIDForPIDReturns struct {
		result1 string
		result2 error
	}
	containerIDForPIDReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DialStub        func() (*grpc.ClientConn, context.CancelFunc, error)
	dialMutex       sync.RWMutex
	dialArgsForCall []struct {
	}
	dialReturns struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}
	dialReturnsOnCall map[int]struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}
	FlushBacklogStub        func(*ttlcache.Cache[string, []*types.AuditLine], string)
	flushBacklogMutex       sync.RWMutex
	flushBacklogArgsForCall []struct {
		arg1 *ttlcache.Cache[string, []*types.AuditLine]
		arg2 string
	}
	GetFromBacklogStub        func(*ttlcache.Cache[string, []*types.AuditLine], string) []*types.AuditLine
	getFromBacklogMutex       sync.RWMutex
	getFromBacklogArgsForCall []struct {
		arg1 *ttlcache.Cache[string, []*types.AuditLine]
		arg2 string
	}
	getFromBacklogReturns struct {
		result1 []*types.AuditLine
	}
	getFromBacklogReturnsOnCall map[int]struct {
		result1 []*types.AuditLine
	}
	GetenvStub        func(string) string
	getenvMutex       sync.RWMutex
	getenvArgsForCall []struct {
		arg1 string
	}
	getenvReturns struct {
		result1 string
	}
	getenvReturnsOnCall map[int]struct {
		result1 string
	}
	InClusterConfigStub        func() (*rest.Config, error)
	inClusterConfigMutex       sync.RWMutex
	inClusterConfigArgsForCall []struct {
	}
	inClusterConfigReturns struct {
		result1 *rest.Config
		result2 error
	}
	inClusterConfigReturnsOnCall map[int]struct {
		result1 *rest.Config
		result2 error
	}
	LinesStub        func(*tail.Tail) chan *tail.Line
	linesMutex       sync.RWMutex
	linesArgsForCall []struct {
		arg1 *tail.Tail
	}
	linesReturns struct {
		result1 chan *tail.Line
	}
	linesReturnsOnCall map[int]struct {
		result1 chan *tail.Line
	}
	ListPodsStub        func(context.Context, kubernetes.Interface, string) (*v1.PodList, error)
	listPodsMutex       sync.RWMutex
	listPodsArgsForCall []struct {
		arg1 context.Context
		arg2 kubernetes.Interface
		arg3 string
	}
	listPodsReturns struct {
		result1 *v1.PodList
		result2 error
	}
	listPodsReturnsOnCall map[int]struct {
		result1 *v1.PodList
		result2 error
	}
	ListenStub        func(string, string) (net.Listener, error)
	listenMutex       sync.RWMutex
	listenArgsForCall []struct {
		arg1 string
		arg2 string
	}
	listenReturns struct {
		result1 net.Listener
		result2 error
	}
	listenReturnsOnCall map[int]struct {
		result1 net.Listener
		result2 error
	}
	NewForConfigStub        func(*rest.Config) (*kubernetes.Clientset, error)
	newForConfigMutex       sync.RWMutex
	newForConfigArgsForCall []struct {
		arg1 *rest.Config
	}
	newForConfigReturns struct {
		result1 *kubernetes.Clientset
		result2 error
	}
	newForConfigReturnsOnCall map[int]struct {
		result1 *kubernetes.Clientset
		result2 error
	}
	PrintJsonOutputStub        func(io.Writer, string)
	printJsonOutputMutex       sync.RWMutex
	printJsonOutputArgsForCall []struct {
		arg1 io.Writer
		arg2 string
	}
	ReasonStub        func(*tail.Tail) error
	reasonMutex       sync.RWMutex
	reasonArgsForCall []struct {
		arg1 *tail.Tail
	}
	reasonReturns struct {
		result1 error
	}
	reasonReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveAllStub        func(string) error
	removeAllMutex       sync.RWMutex
	removeAllArgsForCall []struct {
		arg1 string
	}
	removeAllReturns struct {
		result1 error
	}
	removeAllReturnsOnCall map[int]struct {
		result1 error
	}
	SendMetricStub        func(api_metrics.Metrics_AuditIncClient, *api_metrics.AuditRequest) error
	sendMetricMutex       sync.RWMutex
	sendMetricArgsForCall []struct {
		arg1 api_metrics.Metrics_AuditIncClient
		arg2 *api_metrics.AuditRequest
	}
	sendMetricReturns struct {
		result1 error
	}
	sendMetricReturnsOnCall map[int]struct {
		result1 error
	}
	ServeStub        func(*grpc.Server, net.Listener) error
	serveMutex       sync.RWMutex
	serveArgsForCall []struct {
		arg1 *grpc.Server
		arg2 net.Listener
	}
	serveReturns struct {
		result1 error
	}
	serveReturnsOnCall map[int]struct {
		result1 error
	}
	StartTailStub        func(auditsource.AuditLineSource) (chan *types.AuditLine, error)
	startTailMutex       sync.RWMutex
	startTailArgsForCall []struct {
		arg1 auditsource.AuditLineSource
	}
	startTailReturns struct {
		result1 chan *types.AuditLine
		result2 error
	}
	startTailReturnsOnCall map[int]struct {
		result1 chan *types.AuditLine
		result2 error
	}
	StatStub        func(string) (os.FileInfo, error)
	statMutex       sync.RWMutex
	statArgsForCall []struct {
		arg1 string
	}
	statReturns struct {
		result1 os.FileInfo
		result2 error
	}
	statReturnsOnCall map[int]struct {
		result1 os.FileInfo
		result2 error
	}
	TailErrStub        func(auditsource.AuditLineSource) error
	tailErrMutex       sync.RWMutex
	tailErrArgsForCall []struct {
		arg1 auditsource.AuditLineSource
	}
	tailErrReturns struct {
		result1 error
	}
	tailErrReturnsOnCall map[int]struct {
		result1 error
	}
	TailFileStub        func(string, tail.Config) (*tail.Tail, error)
	tailFileMutex       sync.RWMutex
	tailFileArgsForCall []struct {
		arg1 string
		arg2 tail.Config
	}
	tailFileReturns struct {
		result1 *tail.Tail
		result2 error
	}
	tailFileReturnsOnCall map[int]struct {
		result1 *tail.Tail
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeImpl) AddToBacklog(arg1 *ttlcache.Cache[string, []*types.AuditLine], arg2 string, arg3 []*types.AuditLine) {
	var arg3Copy []*types.AuditLine
	if arg3 != nil {
		arg3Copy = make([]*types.AuditLine, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.addToBacklogMutex.Lock()
	fake.addToBacklogArgsForCall = append(fake.addToBacklogArgsForCall, struct {
		arg1 *ttlcache.Cache[string, []*types.AuditLine]
		arg2 string
		arg3 []*types.AuditLine
	}{arg1, arg2, arg3Copy})
	stub := fake.AddToBacklogStub
	fake.recordInvocation("AddToBacklog", []interface{}{arg1, arg2, arg3Copy})
	fake.addToBacklogMutex.Unlock()
	if stub != nil {
		fake.AddToBacklogStub(arg1, arg2, arg3)
	}
}

func (fake *FakeImpl) AddToBacklogCallCount() int {
	fake.addToBacklogMutex.RLock()
	defer fake.addToBacklogMutex.RUnlock()
	return len(fake.addToBacklogArgsForCall)
}

func (fake *FakeImpl) AddToBacklogCalls(stub func(*ttlcache.Cache[string, []*types.AuditLine], string, []*types.AuditLine)) {
	fake.addToBacklogMutex.Lock()
	defer fake.addToBacklogMutex.Unlock()
	fake.AddToBacklogStub = stub
}

func (fake *FakeImpl) AddToBacklogArgsForCall(i int) (*ttlcache.Cache[string, []*types.AuditLine], string, []*types.AuditLine) {
	fake.addToBacklogMutex.RLock()
	defer fake.addToBacklogMutex.RUnlock()
	argsForCall := fake.addToBacklogArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) AuditInc(arg1 api_metrics.MetricsClient) (api_metrics.Metrics_AuditIncClient, error) {
	fake.auditIncMutex.Lock()
	ret, specificReturn := fake.auditIncReturnsOnCall[len(fake.auditIncArgsForCall)]
	fake.auditIncArgsForCall = append(fake.auditIncArgsForCall, struct {
		arg1 api_metrics.MetricsClient
	}{arg1})
	stub := fake.AuditIncStub
	fakeReturns := fake.auditIncReturns
	fake.recordInvocation("AuditInc", []interface{}{arg1})
	fake.auditIncMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) AuditIncCallCount() int {
	fake.auditIncMutex.RLock()
	defer fake.auditIncMutex.RUnlock()
	return len(fake.auditIncArgsForCall)
}

func (fake *FakeImpl) AuditIncCalls(stub func(api_metrics.MetricsClient) (api_metrics.Metrics_AuditIncClient, error)) {
	fake.auditIncMutex.Lock()
	defer fake.auditIncMutex.Unlock()
	fake.AuditIncStub = stub
}

func (fake *FakeImpl) AuditIncArgsForCall(i int) api_metrics.MetricsClient {
	fake.auditIncMutex.RLock()
	defer fake.auditIncMutex.RUnlock()
	argsForCall := fake.auditIncArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) AuditIncReturns(result1 api_metrics.Metrics_AuditIncClient, result2 error) {
	fake.auditIncMutex.Lock()
	defer fake.auditIncMutex.Unlock()
	fake.AuditIncStub = nil
	fake.auditIncReturns = struct {
		result1 api_metrics.Metrics_AuditIncClient
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) AuditIncReturnsOnCall(i int, result1 api_metrics.Metrics_AuditIncClient, result2 error) {
	fake.auditIncMutex.Lock()
	defer fake.auditIncMutex.Unlock()
	fake.AuditIncStub = nil
	if fake.auditIncReturnsOnCall == nil {
		fake.auditIncReturnsOnCall = make(map[int]struct {
			result1 api_metrics.Metrics_AuditIncClient
			result2 error
		})
	}
	fake.auditIncReturnsOnCall[i] = struct {
		result1 api_metrics.Metrics_AuditIncClient
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Chown(arg1 string, arg2 int, arg3 int) error {
	fake.chownMutex.Lock()
	ret, specificReturn := fake.chownReturnsOnCall[len(fake.chownArgsForCall)]
	fake.chownArgsForCall = append(fake.chownArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.ChownStub
	fakeReturns := fake.chownReturns
	fake.recordInvocation("Chown", []interface{}{arg1, arg2, arg3})
	fake.chownMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) ChownCallCount() int {
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	return len(fake.chownArgsForCall)
}

func (fake *FakeImpl) ChownCalls(stub func(string, int, int) error) {
	fake.chownMutex.Lock()
	defer fake.chownMutex.Unlock()
	fake.ChownStub = stub
}

func (fake *FakeImpl) ChownArgsForCall(i int) (string, int, int) {
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	argsForCall := fake.chownArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) ChownReturns(result1 error) {
	fake.chownMutex.Lock()
	defer fake.chownMutex.Unlock()
	fake.ChownStub = nil
	fake.chownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) ChownReturnsOnCall(i int, result1 error) {
	fake.chownMutex.Lock()
	defer fake.chownMutex.Unlock()
	fake.ChownStub = nil
	if fake.chownReturnsOnCall == nil {
		fake.chownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) Close(arg1 *grpc.ClientConn) error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
		arg1 *grpc.ClientConn
	}{arg1})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{arg1})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeImpl) CloseCalls(stub func(*grpc.ClientConn) error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeImpl) CloseArgsForCall(i int) *grpc.ClientConn {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	argsForCall := fake.closeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) CmdlineForPID(arg1 int) (string, error) {
	fake.cmdlineForPIDMutex.Lock()
	ret, specificReturn := fake.cmdlineForPIDReturnsOnCall[len(fake.cmdlineForPIDArgsForCall)]
	fake.cmdlineForPIDArgsForCall = append(fake.cmdlineForPIDArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.CmdlineForPIDStub
	fakeReturns := fake.cmdlineForPIDReturns
	fake.recordInvocation("CmdlineForPID", []interface{}{arg1})
	fake.cmdlineForPIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) CmdlineForPIDCallCount() int {
	fake.cmdlineForPIDMutex.RLock()
	defer fake.cmdlineForPIDMutex.RUnlock()
	return len(fake.cmdlineForPIDArgsForCall)
}

func (fake *FakeImpl) CmdlineForPIDCalls(stub func(int) (string, error)) {
	fake.cmdlineForPIDMutex.Lock()
	defer fake.cmdlineForPIDMutex.Unlock()
	fake.CmdlineForPIDStub = stub
}

func (fake *FakeImpl) CmdlineForPIDArgsForCall(i int) int {
	fake.cmdlineForPIDMutex.RLock()
	defer fake.cmdlineForPIDMutex.RUnlock()
	argsForCall := fake.cmdlineForPIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) CmdlineForPIDReturns(result1 string, result2 error) {
	fake.cmdlineForPIDMutex.Lock()
	defer fake.cmdlineForPIDMutex.Unlock()
	fake.CmdlineForPIDStub = nil
	fake.cmdlineForPIDReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) CmdlineForPIDReturnsOnCall(i int, result1 string, result2 error) {
	fake.cmdlineForPIDMutex.Lock()
	defer fake.cmdlineForPIDMutex.Unlock()
	fake.CmdlineForPIDStub = nil
	if fake.cmdlineForPIDReturnsOnCall == nil {
		fake.cmdlineForPIDReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.cmdlineForPIDReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ContainerIDForPID(arg1 *ttlcache.Cache[string, string], arg2 int) (string, error) {
	fake.containerIDForPIDMutex.Lock()
	ret, specificReturn := fake.containerIDForPIDReturnsOnCall[len(fake.containerIDForPIDArgsForCall)]
	fake.containerIDForPIDArgsForCall = append(fake.containerIDForPIDArgsForCall, struct {
		arg1 *ttlcache.Cache[string, string]
		arg2 int
	}{arg1, arg2})
	stub := fake.ContainerIDForPIDStub
	fakeReturns := fake.containerIDForPIDReturns
	fake.recordInvocation("ContainerIDForPID", []interface{}{arg1, arg2})
	fake.containerIDForPIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ContainerIDForPIDCallCount() int {
	fake.containerIDForPIDMutex.RLock()
	defer fake.containerIDForPIDMutex.RUnlock()
	return len(fake.containerIDForPIDArgsForCall)
}

func (fake *FakeImpl) ContainerIDForPIDCalls(stub func(*ttlcache.Cache[string, string], int) (string, error)) {
	fake.containerIDForPIDMutex.Lock()
	defer fake.containerIDForPIDMutex.Unlock()
	fake.ContainerIDForPIDStub = stub
}

func (fake *FakeImpl) ContainerIDForPIDArgsForCall(i int) (*ttlcache.Cache[string, string], int) {
	fake.containerIDForPIDMutex.RLock()
	defer fake.containerIDForPIDMutex.RUnlock()
	argsForCall := fake.containerIDForPIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) ContainerIDForPIDReturns(result1 string, result2 error) {
	fake.containerIDForPIDMutex.Lock()
	defer fake.containerIDForPIDMutex.Unlock()
	fake.ContainerIDForPIDStub = nil
	fake.containerIDForPIDReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ContainerIDForPIDReturnsOnCall(i int, result1 string, result2 error) {
	fake.containerIDForPIDMutex.Lock()
	defer fake.containerIDForPIDMutex.Unlock()
	fake.ContainerIDForPIDStub = nil
	if fake.containerIDForPIDReturnsOnCall == nil {
		fake.containerIDForPIDReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.containerIDForPIDReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Dial() (*grpc.ClientConn, context.CancelFunc, error) {
	fake.dialMutex.Lock()
	ret, specificReturn := fake.dialReturnsOnCall[len(fake.dialArgsForCall)]
	fake.dialArgsForCall = append(fake.dialArgsForCall, struct {
	}{})
	stub := fake.DialStub
	fakeReturns := fake.dialReturns
	fake.recordInvocation("Dial", []interface{}{})
	fake.dialMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeImpl) DialCallCount() int {
	fake.dialMutex.RLock()
	defer fake.dialMutex.RUnlock()
	return len(fake.dialArgsForCall)
}

func (fake *FakeImpl) DialCalls(stub func() (*grpc.ClientConn, context.CancelFunc, error)) {
	fake.dialMutex.Lock()
	defer fake.dialMutex.Unlock()
	fake.DialStub = stub
}

func (fake *FakeImpl) DialReturns(result1 *grpc.ClientConn, result2 context.CancelFunc, result3 error) {
	fake.dialMutex.Lock()
	defer fake.dialMutex.Unlock()
	fake.DialStub = nil
	fake.dialReturns = struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeImpl) DialReturnsOnCall(i int, result1 *grpc.ClientConn, result2 context.CancelFunc, result3 error) {
	fake.dialMutex.Lock()
	defer fake.dialMutex.Unlock()
	fake.DialStub = nil
	if fake.dialReturnsOnCall == nil {
		fake.dialReturnsOnCall = make(map[int]struct {
			result1 *grpc.ClientConn
			result2 context.CancelFunc
			result3 error
		})
	}
	fake.dialReturnsOnCall[i] = struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeImpl) FlushBacklog(arg1 *ttlcache.Cache[string, []*types.AuditLine], arg2 string) {
	fake.flushBacklogMutex.Lock()
	fake.flushBacklogArgsForCall = append(fake.flushBacklogArgsForCall, struct {
		arg1 *ttlcache.Cache[string, []*types.AuditLine]
		arg2 string
	}{arg1, arg2})
	stub := fake.FlushBacklogStub
	fake.recordInvocation("FlushBacklog", []interface{}{arg1, arg2})
	fake.flushBacklogMutex.Unlock()
	if stub != nil {
		fake.FlushBacklogStub(arg1, arg2)
	}
}

func (fake *FakeImpl) FlushBacklogCallCount() int {
	fake.flushBacklogMutex.RLock()
	defer fake.flushBacklogMutex.RUnlock()
	return len(fake.flushBacklogArgsForCall)
}

func (fake *FakeImpl) FlushBacklogCalls(stub func(*ttlcache.Cache[string, []*types.AuditLine], string)) {
	fake.flushBacklogMutex.Lock()
	defer fake.flushBacklogMutex.Unlock()
	fake.FlushBacklogStub = stub
}

func (fake *FakeImpl) FlushBacklogArgsForCall(i int) (*ttlcache.Cache[string, []*types.AuditLine], string) {
	fake.flushBacklogMutex.RLock()
	defer fake.flushBacklogMutex.RUnlock()
	argsForCall := fake.flushBacklogArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) GetFromBacklog(arg1 *ttlcache.Cache[string, []*types.AuditLine], arg2 string) []*types.AuditLine {
	fake.getFromBacklogMutex.Lock()
	ret, specificReturn := fake.getFromBacklogReturnsOnCall[len(fake.getFromBacklogArgsForCall)]
	fake.getFromBacklogArgsForCall = append(fake.getFromBacklogArgsForCall, struct {
		arg1 *ttlcache.Cache[string, []*types.AuditLine]
		arg2 string
	}{arg1, arg2})
	stub := fake.GetFromBacklogStub
	fakeReturns := fake.getFromBacklogReturns
	fake.recordInvocation("GetFromBacklog", []interface{}{arg1, arg2})
	fake.getFromBacklogMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) GetFromBacklogCallCount() int {
	fake.getFromBacklogMutex.RLock()
	defer fake.getFromBacklogMutex.RUnlock()
	return len(fake.getFromBacklogArgsForCall)
}

func (fake *FakeImpl) GetFromBacklogCalls(stub func(*ttlcache.Cache[string, []*types.AuditLine], string) []*types.AuditLine) {
	fake.getFromBacklogMutex.Lock()
	defer fake.getFromBacklogMutex.Unlock()
	fake.GetFromBacklogStub = stub
}

func (fake *FakeImpl) GetFromBacklogArgsForCall(i int) (*ttlcache.Cache[string, []*types.AuditLine], string) {
	fake.getFromBacklogMutex.RLock()
	defer fake.getFromBacklogMutex.RUnlock()
	argsForCall := fake.getFromBacklogArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) GetFromBacklogReturns(result1 []*types.AuditLine) {
	fake.getFromBacklogMutex.Lock()
	defer fake.getFromBacklogMutex.Unlock()
	fake.GetFromBacklogStub = nil
	fake.getFromBacklogReturns = struct {
		result1 []*types.AuditLine
	}{result1}
}

func (fake *FakeImpl) GetFromBacklogReturnsOnCall(i int, result1 []*types.AuditLine) {
	fake.getFromBacklogMutex.Lock()
	defer fake.getFromBacklogMutex.Unlock()
	fake.GetFromBacklogStub = nil
	if fake.getFromBacklogReturnsOnCall == nil {
		fake.getFromBacklogReturnsOnCall = make(map[int]struct {
			result1 []*types.AuditLine
		})
	}
	fake.getFromBacklogReturnsOnCall[i] = struct {
		result1 []*types.AuditLine
	}{result1}
}

func (fake *FakeImpl) Getenv(arg1 string) string {
	fake.getenvMutex.Lock()
	ret, specificReturn := fake.getenvReturnsOnCall[len(fake.getenvArgsForCall)]
	fake.getenvArgsForCall = append(fake.getenvArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetenvStub
	fakeReturns := fake.getenvReturns
	fake.recordInvocation("Getenv", []interface{}{arg1})
	fake.getenvMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) GetenvCallCount() int {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	return len(fake.getenvArgsForCall)
}

func (fake *FakeImpl) GetenvCalls(stub func(string) string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = stub
}

func (fake *FakeImpl) GetenvArgsForCall(i int) string {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	argsForCall := fake.getenvArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) GetenvReturns(result1 string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = nil
	fake.getenvReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeImpl) GetenvReturnsOnCall(i int, result1 string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = nil
	if fake.getenvReturnsOnCall == nil {
		fake.getenvReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getenvReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeImpl) InClusterConfig() (*rest.Config, error) {
	fake.inClusterConfigMutex.Lock()
	ret, specificReturn := fake.inClusterConfigReturnsOnCall[len(fake.inClusterConfigArgsForCall)]
	fake.inClusterConfigArgsForCall = append(fake.inClusterConfigArgsForCall, struct {
	}{})
	stub := fake.InClusterConfigStub
	fakeReturns := fake.inClusterConfigReturns
	fake.recordInvocation("InClusterConfig", []interface{}{})
	fake.inClusterConfigMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) InClusterConfigCallCount() int {
	fake.inClusterConfigMutex.RLock()
	defer fake.inClusterConfigMutex.RUnlock()
	return len(fake.inClusterConfigArgsForCall)
}

func (fake *FakeImpl) InClusterConfigCalls(stub func() (*rest.Config, error)) {
	fake.inClusterConfigMutex.Lock()
	defer fake.inClusterConfigMutex.Unlock()
	fake.InClusterConfigStub = stub
}

func (fake *FakeImpl) InClusterConfigReturns(result1 *rest.Config, result2 error) {
	fake.inClusterConfigMutex.Lock()
	defer fake.inClusterConfigMutex.Unlock()
	fake.InClusterConfigStub = nil
	fake.inClusterConfigReturns = struct {
		result1 *rest.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) InClusterConfigReturnsOnCall(i int, result1 *rest.Config, result2 error) {
	fake.inClusterConfigMutex.Lock()
	defer fake.inClusterConfigMutex.Unlock()
	fake.InClusterConfigStub = nil
	if fake.inClusterConfigReturnsOnCall == nil {
		fake.inClusterConfigReturnsOnCall = make(map[int]struct {
			result1 *rest.Config
			result2 error
		})
	}
	fake.inClusterConfigReturnsOnCall[i] = struct {
		result1 *rest.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Lines(arg1 *tail.Tail) chan *tail.Line {
	fake.linesMutex.Lock()
	ret, specificReturn := fake.linesReturnsOnCall[len(fake.linesArgsForCall)]
	fake.linesArgsForCall = append(fake.linesArgsForCall, struct {
		arg1 *tail.Tail
	}{arg1})
	stub := fake.LinesStub
	fakeReturns := fake.linesReturns
	fake.recordInvocation("Lines", []interface{}{arg1})
	fake.linesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) LinesCallCount() int {
	fake.linesMutex.RLock()
	defer fake.linesMutex.RUnlock()
	return len(fake.linesArgsForCall)
}

func (fake *FakeImpl) LinesCalls(stub func(*tail.Tail) chan *tail.Line) {
	fake.linesMutex.Lock()
	defer fake.linesMutex.Unlock()
	fake.LinesStub = stub
}

func (fake *FakeImpl) LinesArgsForCall(i int) *tail.Tail {
	fake.linesMutex.RLock()
	defer fake.linesMutex.RUnlock()
	argsForCall := fake.linesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) LinesReturns(result1 chan *tail.Line) {
	fake.linesMutex.Lock()
	defer fake.linesMutex.Unlock()
	fake.LinesStub = nil
	fake.linesReturns = struct {
		result1 chan *tail.Line
	}{result1}
}

func (fake *FakeImpl) LinesReturnsOnCall(i int, result1 chan *tail.Line) {
	fake.linesMutex.Lock()
	defer fake.linesMutex.Unlock()
	fake.LinesStub = nil
	if fake.linesReturnsOnCall == nil {
		fake.linesReturnsOnCall = make(map[int]struct {
			result1 chan *tail.Line
		})
	}
	fake.linesReturnsOnCall[i] = struct {
		result1 chan *tail.Line
	}{result1}
}

func (fake *FakeImpl) ListPods(arg1 context.Context, arg2 kubernetes.Interface, arg3 string) (*v1.PodList, error) {
	fake.listPodsMutex.Lock()
	ret, specificReturn := fake.listPodsReturnsOnCall[len(fake.listPodsArgsForCall)]
	fake.listPodsArgsForCall = append(fake.listPodsArgsForCall, struct {
		arg1 context.Context
		arg2 kubernetes.Interface
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ListPodsStub
	fakeReturns := fake.listPodsReturns
	fake.recordInvocation("ListPods", []interface{}{arg1, arg2, arg3})
	fake.listPodsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ListPodsCallCount() int {
	fake.listPodsMutex.RLock()
	defer fake.listPodsMutex.RUnlock()
	return len(fake.listPodsArgsForCall)
}

func (fake *FakeImpl) ListPodsCalls(stub func(context.Context, kubernetes.Interface, string) (*v1.PodList, error)) {
	fake.listPodsMutex.Lock()
	defer fake.listPodsMutex.Unlock()
	fake.ListPodsStub = stub
}

func (fake *FakeImpl) ListPodsArgsForCall(i int) (context.Context, kubernetes.Interface, string) {
	fake.listPodsMutex.RLock()
	defer fake.listPodsMutex.RUnlock()
	argsForCall := fake.listPodsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) ListPodsReturns(result1 *v1.PodList, result2 error) {
	fake.listPodsMutex.Lock()
	defer fake.listPodsMutex.Unlock()
	fake.ListPodsStub = nil
	fake.listPodsReturns = struct {
		result1 *v1.PodList
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ListPodsReturnsOnCall(i int, result1 *v1.PodList, result2 error) {
	fake.listPodsMutex.Lock()
	defer fake.listPodsMutex.Unlock()
	fake.ListPodsStub = nil
	if fake.listPodsReturnsOnCall == nil {
		fake.listPodsReturnsOnCall = make(map[int]struct {
			result1 *v1.PodList
			result2 error
		})
	}
	fake.listPodsReturnsOnCall[i] = struct {
		result1 *v1.PodList
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Listen(arg1 string, arg2 string) (net.Listener, error) {
	fake.listenMutex.Lock()
	ret, specificReturn := fake.listenReturnsOnCall[len(fake.listenArgsForCall)]
	fake.listenArgsForCall = append(fake.listenArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ListenStub
	fakeReturns := fake.listenReturns
	fake.recordInvocation("Listen", []interface{}{arg1, arg2})
	fake.listenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ListenCallCount() int {
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	return len(fake.listenArgsForCall)
}

func (fake *FakeImpl) ListenCalls(stub func(string, string) (net.Listener, error)) {
	fake.listenMutex.Lock()
	defer fake.listenMutex.Unlock()
	fake.ListenStub = stub
}

func (fake *FakeImpl) ListenArgsForCall(i int) (string, string) {
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	argsForCall := fake.listenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) ListenReturns(result1 net.Listener, result2 error) {
	fake.listenMutex.Lock()
	defer fake.listenMutex.Unlock()
	fake.ListenStub = nil
	fake.listenReturns = struct {
		result1 net.Listener
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ListenReturnsOnCall(i int, result1 net.Listener, result2 error) {
	fake.listenMutex.Lock()
	defer fake.listenMutex.Unlock()
	fake.ListenStub = nil
	if fake.listenReturnsOnCall == nil {
		fake.listenReturnsOnCall = make(map[int]struct {
			result1 net.Listener
			result2 error
		})
	}
	fake.listenReturnsOnCall[i] = struct {
		result1 net.Listener
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewForConfig(arg1 *rest.Config) (*kubernetes.Clientset, error) {
	fake.newForConfigMutex.Lock()
	ret, specificReturn := fake.newForConfigReturnsOnCall[len(fake.newForConfigArgsForCall)]
	fake.newForConfigArgsForCall = append(fake.newForConfigArgsForCall, struct {
		arg1 *rest.Config
	}{arg1})
	stub := fake.NewForConfigStub
	fakeReturns := fake.newForConfigReturns
	fake.recordInvocation("NewForConfig", []interface{}{arg1})
	fake.newForConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) NewForConfigCallCount() int {
	fake.newForConfigMutex.RLock()
	defer fake.newForConfigMutex.RUnlock()
	return len(fake.newForConfigArgsForCall)
}

func (fake *FakeImpl) NewForConfigCalls(stub func(*rest.Config) (*kubernetes.Clientset, error)) {
	fake.newForConfigMutex.Lock()
	defer fake.newForConfigMutex.Unlock()
	fake.NewForConfigStub = stub
}

func (fake *FakeImpl) NewForConfigArgsForCall(i int) *rest.Config {
	fake.newForConfigMutex.RLock()
	defer fake.newForConfigMutex.RUnlock()
	argsForCall := fake.newForConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) NewForConfigReturns(result1 *kubernetes.Clientset, result2 error) {
	fake.newForConfigMutex.Lock()
	defer fake.newForConfigMutex.Unlock()
	fake.NewForConfigStub = nil
	fake.newForConfigReturns = struct {
		result1 *kubernetes.Clientset
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewForConfigReturnsOnCall(i int, result1 *kubernetes.Clientset, result2 error) {
	fake.newForConfigMutex.Lock()
	defer fake.newForConfigMutex.Unlock()
	fake.NewForConfigStub = nil
	if fake.newForConfigReturnsOnCall == nil {
		fake.newForConfigReturnsOnCall = make(map[int]struct {
			result1 *kubernetes.Clientset
			result2 error
		})
	}
	fake.newForConfigReturnsOnCall[i] = struct {
		result1 *kubernetes.Clientset
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) PrintJsonOutput(arg1 io.Writer, arg2 string) {
	fake.printJsonOutputMutex.Lock()
	fake.printJsonOutputArgsForCall = append(fake.printJsonOutputArgsForCall, struct {
		arg1 io.Writer
		arg2 string
	}{arg1, arg2})
	stub := fake.PrintJsonOutputStub
	fake.recordInvocation("PrintJsonOutput", []interface{}{arg1, arg2})
	fake.printJsonOutputMutex.Unlock()
	if stub != nil {
		fake.PrintJsonOutputStub(arg1, arg2)
	}
}

func (fake *FakeImpl) PrintJsonOutputCallCount() int {
	fake.printJsonOutputMutex.RLock()
	defer fake.printJsonOutputMutex.RUnlock()
	return len(fake.printJsonOutputArgsForCall)
}

func (fake *FakeImpl) PrintJsonOutputCalls(stub func(io.Writer, string)) {
	fake.printJsonOutputMutex.Lock()
	defer fake.printJsonOutputMutex.Unlock()
	fake.PrintJsonOutputStub = stub
}

func (fake *FakeImpl) PrintJsonOutputArgsForCall(i int) (io.Writer, string) {
	fake.printJsonOutputMutex.RLock()
	defer fake.printJsonOutputMutex.RUnlock()
	argsForCall := fake.printJsonOutputArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) Reason(arg1 *tail.Tail) error {
	fake.reasonMutex.Lock()
	ret, specificReturn := fake.reasonReturnsOnCall[len(fake.reasonArgsForCall)]
	fake.reasonArgsForCall = append(fake.reasonArgsForCall, struct {
		arg1 *tail.Tail
	}{arg1})
	stub := fake.ReasonStub
	fakeReturns := fake.reasonReturns
	fake.recordInvocation("Reason", []interface{}{arg1})
	fake.reasonMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) ReasonCallCount() int {
	fake.reasonMutex.RLock()
	defer fake.reasonMutex.RUnlock()
	return len(fake.reasonArgsForCall)
}

func (fake *FakeImpl) ReasonCalls(stub func(*tail.Tail) error) {
	fake.reasonMutex.Lock()
	defer fake.reasonMutex.Unlock()
	fake.ReasonStub = stub
}

func (fake *FakeImpl) ReasonArgsForCall(i int) *tail.Tail {
	fake.reasonMutex.RLock()
	defer fake.reasonMutex.RUnlock()
	argsForCall := fake.reasonArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) ReasonReturns(result1 error) {
	fake.reasonMutex.Lock()
	defer fake.reasonMutex.Unlock()
	fake.ReasonStub = nil
	fake.reasonReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) ReasonReturnsOnCall(i int, result1 error) {
	fake.reasonMutex.Lock()
	defer fake.reasonMutex.Unlock()
	fake.ReasonStub = nil
	if fake.reasonReturnsOnCall == nil {
		fake.reasonReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.reasonReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) RemoveAll(arg1 string) error {
	fake.removeAllMutex.Lock()
	ret, specificReturn := fake.removeAllReturnsOnCall[len(fake.removeAllArgsForCall)]
	fake.removeAllArgsForCall = append(fake.removeAllArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveAllStub
	fakeReturns := fake.removeAllReturns
	fake.recordInvocation("RemoveAll", []interface{}{arg1})
	fake.removeAllMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) RemoveAllCallCount() int {
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	return len(fake.removeAllArgsForCall)
}

func (fake *FakeImpl) RemoveAllCalls(stub func(string) error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = stub
}

func (fake *FakeImpl) RemoveAllArgsForCall(i int) string {
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	argsForCall := fake.removeAllArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) RemoveAllReturns(result1 error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = nil
	fake.removeAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) RemoveAllReturnsOnCall(i int, result1 error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = nil
	if fake.removeAllReturnsOnCall == nil {
		fake.removeAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SendMetric(arg1 api_metrics.Metrics_AuditIncClient, arg2 *api_metrics.AuditRequest) error {
	fake.sendMetricMutex.Lock()
	ret, specificReturn := fake.sendMetricReturnsOnCall[len(fake.sendMetricArgsForCall)]
	fake.sendMetricArgsForCall = append(fake.sendMetricArgsForCall, struct {
		arg1 api_metrics.Metrics_AuditIncClient
		arg2 *api_metrics.AuditRequest
	}{arg1, arg2})
	stub := fake.SendMetricStub
	fakeReturns := fake.sendMetricReturns
	fake.recordInvocation("SendMetric", []interface{}{arg1, arg2})
	fake.sendMetricMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) SendMetricCallCount() int {
	fake.sendMetricMutex.RLock()
	defer fake.sendMetricMutex.RUnlock()
	return len(fake.sendMetricArgsForCall)
}

func (fake *FakeImpl) SendMetricCalls(stub func(api_metrics.Metrics_AuditIncClient, *api_metrics.AuditRequest) error) {
	fake.sendMetricMutex.Lock()
	defer fake.sendMetricMutex.Unlock()
	fake.SendMetricStub = stub
}

func (fake *FakeImpl) SendMetricArgsForCall(i int) (api_metrics.Metrics_AuditIncClient, *api_metrics.AuditRequest) {
	fake.sendMetricMutex.RLock()
	defer fake.sendMetricMutex.RUnlock()
	argsForCall := fake.sendMetricArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) SendMetricReturns(result1 error) {
	fake.sendMetricMutex.Lock()
	defer fake.sendMetricMutex.Unlock()
	fake.SendMetricStub = nil
	fake.sendMetricReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SendMetricReturnsOnCall(i int, result1 error) {
	fake.sendMetricMutex.Lock()
	defer fake.sendMetricMutex.Unlock()
	fake.SendMetricStub = nil
	if fake.sendMetricReturnsOnCall == nil {
		fake.sendMetricReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendMetricReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) Serve(arg1 *grpc.Server, arg2 net.Listener) error {
	fake.serveMutex.Lock()
	ret, specificReturn := fake.serveReturnsOnCall[len(fake.serveArgsForCall)]
	fake.serveArgsForCall = append(fake.serveArgsForCall, struct {
		arg1 *grpc.Server
		arg2 net.Listener
	}{arg1, arg2})
	stub := fake.ServeStub
	fakeReturns := fake.serveReturns
	fake.recordInvocation("Serve", []interface{}{arg1, arg2})
	fake.serveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) ServeCallCount() int {
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	return len(fake.serveArgsForCall)
}

func (fake *FakeImpl) ServeCalls(stub func(*grpc.Server, net.Listener) error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = stub
}

func (fake *FakeImpl) ServeArgsForCall(i int) (*grpc.Server, net.Listener) {
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	argsForCall := fake.serveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) ServeReturns(result1 error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = nil
	fake.serveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) ServeReturnsOnCall(i int, result1 error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = nil
	if fake.serveReturnsOnCall == nil {
		fake.serveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) StartTail(arg1 auditsource.AuditLineSource) (chan *types.AuditLine, error) {
	fake.startTailMutex.Lock()
	ret, specificReturn := fake.startTailReturnsOnCall[len(fake.startTailArgsForCall)]
	fake.startTailArgsForCall = append(fake.startTailArgsForCall, struct {
		arg1 auditsource.AuditLineSource
	}{arg1})
	stub := fake.StartTailStub
	fakeReturns := fake.startTailReturns
	fake.recordInvocation("StartTail", []interface{}{arg1})
	fake.startTailMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) StartTailCallCount() int {
	fake.startTailMutex.RLock()
	defer fake.startTailMutex.RUnlock()
	return len(fake.startTailArgsForCall)
}

func (fake *FakeImpl) StartTailCalls(stub func(auditsource.AuditLineSource) (chan *types.AuditLine, error)) {
	fake.startTailMutex.Lock()
	defer fake.startTailMutex.Unlock()
	fake.StartTailStub = stub
}

func (fake *FakeImpl) StartTailArgsForCall(i int) auditsource.AuditLineSource {
	fake.startTailMutex.RLock()
	defer fake.startTailMutex.RUnlock()
	argsForCall := fake.startTailArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) StartTailReturns(result1 chan *types.AuditLine, result2 error) {
	fake.startTailMutex.Lock()
	defer fake.startTailMutex.Unlock()
	fake.StartTailStub = nil
	fake.startTailReturns = struct {
		result1 chan *types.AuditLine
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) StartTailReturnsOnCall(i int, result1 chan *types.AuditLine, result2 error) {
	fake.startTailMutex.Lock()
	defer fake.startTailMutex.Unlock()
	fake.StartTailStub = nil
	if fake.startTailReturnsOnCall == nil {
		fake.startTailReturnsOnCall = make(map[int]struct {
			result1 chan *types.AuditLine
			result2 error
		})
	}
	fake.startTailReturnsOnCall[i] = struct {
		result1 chan *types.AuditLine
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Stat(arg1 string) (os.FileInfo, error) {
	fake.statMutex.Lock()
	ret, specificReturn := fake.statReturnsOnCall[len(fake.statArgsForCall)]
	fake.statArgsForCall = append(fake.statArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StatStub
	fakeReturns := fake.statReturns
	fake.recordInvocation("Stat", []interface{}{arg1})
	fake.statMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) StatCallCount() int {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	return len(fake.statArgsForCall)
}

func (fake *FakeImpl) StatCalls(stub func(string) (os.FileInfo, error)) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = stub
}

func (fake *FakeImpl) StatArgsForCall(i int) string {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	argsForCall := fake.statArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) StatReturns(result1 os.FileInfo, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	fake.statReturns = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) StatReturnsOnCall(i int, result1 os.FileInfo, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	if fake.statReturnsOnCall == nil {
		fake.statReturnsOnCall = make(map[int]struct {
			result1 os.FileInfo
			result2 error
		})
	}
	fake.statReturnsOnCall[i] = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) TailErr(arg1 auditsource.AuditLineSource) error {
	fake.tailErrMutex.Lock()
	ret, specificReturn := fake.tailErrReturnsOnCall[len(fake.tailErrArgsForCall)]
	fake.tailErrArgsForCall = append(fake.tailErrArgsForCall, struct {
		arg1 auditsource.AuditLineSource
	}{arg1})
	stub := fake.TailErrStub
	fakeReturns := fake.tailErrReturns
	fake.recordInvocation("TailErr", []interface{}{arg1})
	fake.tailErrMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) TailErrCallCount() int {
	fake.tailErrMutex.RLock()
	defer fake.tailErrMutex.RUnlock()
	return len(fake.tailErrArgsForCall)
}

func (fake *FakeImpl) TailErrCalls(stub func(auditsource.AuditLineSource) error) {
	fake.tailErrMutex.Lock()
	defer fake.tailErrMutex.Unlock()
	fake.TailErrStub = stub
}

func (fake *FakeImpl) TailErrArgsForCall(i int) auditsource.AuditLineSource {
	fake.tailErrMutex.RLock()
	defer fake.tailErrMutex.RUnlock()
	argsForCall := fake.tailErrArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) TailErrReturns(result1 error) {
	fake.tailErrMutex.Lock()
	defer fake.tailErrMutex.Unlock()
	fake.TailErrStub = nil
	fake.tailErrReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) TailErrReturnsOnCall(i int, result1 error) {
	fake.tailErrMutex.Lock()
	defer fake.tailErrMutex.Unlock()
	fake.TailErrStub = nil
	if fake.tailErrReturnsOnCall == nil {
		fake.tailErrReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.tailErrReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) TailFile(arg1 string, arg2 tail.Config) (*tail.Tail, error) {
	fake.tailFileMutex.Lock()
	ret, specificReturn := fake.tailFileReturnsOnCall[len(fake.tailFileArgsForCall)]
	fake.tailFileArgsForCall = append(fake.tailFileArgsForCall, struct {
		arg1 string
		arg2 tail.Config
	}{arg1, arg2})
	stub := fake.TailFileStub
	fakeReturns := fake.tailFileReturns
	fake.recordInvocation("TailFile", []interface{}{arg1, arg2})
	fake.tailFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) TailFileCallCount() int {
	fake.tailFileMutex.RLock()
	defer fake.tailFileMutex.RUnlock()
	return len(fake.tailFileArgsForCall)
}

func (fake *FakeImpl) TailFileCalls(stub func(string, tail.Config) (*tail.Tail, error)) {
	fake.tailFileMutex.Lock()
	defer fake.tailFileMutex.Unlock()
	fake.TailFileStub = stub
}

func (fake *FakeImpl) TailFileArgsForCall(i int) (string, tail.Config) {
	fake.tailFileMutex.RLock()
	defer fake.tailFileMutex.RUnlock()
	argsForCall := fake.tailFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) TailFileReturns(result1 *tail.Tail, result2 error) {
	fake.tailFileMutex.Lock()
	defer fake.tailFileMutex.Unlock()
	fake.TailFileStub = nil
	fake.tailFileReturns = struct {
		result1 *tail.Tail
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) TailFileReturnsOnCall(i int, result1 *tail.Tail, result2 error) {
	fake.tailFileMutex.Lock()
	defer fake.tailFileMutex.Unlock()
	fake.TailFileStub = nil
	if fake.tailFileReturnsOnCall == nil {
		fake.tailFileReturnsOnCall = make(map[int]struct {
			result1 *tail.Tail
			result2 error
		})
	}
	fake.tailFileReturnsOnCall[i] = struct {
		result1 *tail.Tail
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addToBacklogMutex.RLock()
	defer fake.addToBacklogMutex.RUnlock()
	fake.auditIncMutex.RLock()
	defer fake.auditIncMutex.RUnlock()
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.cmdlineForPIDMutex.RLock()
	defer fake.cmdlineForPIDMutex.RUnlock()
	fake.containerIDForPIDMutex.RLock()
	defer fake.containerIDForPIDMutex.RUnlock()
	fake.dialMutex.RLock()
	defer fake.dialMutex.RUnlock()
	fake.flushBacklogMutex.RLock()
	defer fake.flushBacklogMutex.RUnlock()
	fake.getFromBacklogMutex.RLock()
	defer fake.getFromBacklogMutex.RUnlock()
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	fake.inClusterConfigMutex.RLock()
	defer fake.inClusterConfigMutex.RUnlock()
	fake.linesMutex.RLock()
	defer fake.linesMutex.RUnlock()
	fake.listPodsMutex.RLock()
	defer fake.listPodsMutex.RUnlock()
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	fake.newForConfigMutex.RLock()
	defer fake.newForConfigMutex.RUnlock()
	fake.printJsonOutputMutex.RLock()
	defer fake.printJsonOutputMutex.RUnlock()
	fake.reasonMutex.RLock()
	defer fake.reasonMutex.RUnlock()
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	fake.sendMetricMutex.RLock()
	defer fake.sendMetricMutex.RUnlock()
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	fake.startTailMutex.RLock()
	defer fake.startTailMutex.RUnlock()
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	fake.tailErrMutex.RLock()
	defer fake.tailErrMutex.RUnlock()
	fake.tailFileMutex.RLock()
	defer fake.tailFileMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeImpl) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
