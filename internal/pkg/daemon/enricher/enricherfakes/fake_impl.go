/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by counterfeiter. DO NOT EDIT.
package enricherfakes

import (
	"context"
	"net"
	"os"
	"sync"
	"time"

	ttlcache "github.com/ReneKroon/ttlcache/v2"
	"github.com/nxadm/tail"
	"google.golang.org/grpc"
	v1 "k8s.io/api/core/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	api_metrics "sigs.k8s.io/security-profiles-operator/api/grpc/metrics"
)

type FakeImpl struct {
	AddToBacklogStub        func(*ttlcache.Cache, string, interface{}) error
	addToBacklogMutex       sync.RWMutex
	addToBacklogArgsForCall []struct {
		arg1 *ttlcache.Cache
		arg2 string
		arg3 interface{}
	}
	addToBacklogReturns struct {
		result1 error
	}
	addToBacklogReturnsOnCall map[int]struct {
		result1 error
	}
	AuditIncStub        func(api_metrics.MetricsClient) (api_metrics.Metrics_AuditIncClient, error)
	auditIncMutex       sync.RWMutex
	auditIncArgsForCall []struct {
		arg1 api_metrics.MetricsClient
	}
	auditIncReturns struct {
		result1 api_metrics.Metrics_AuditIncClient
		result2 error
	}
	auditIncReturnsOnCall map[int]struct {
		result1 api_metrics.Metrics_AuditIncClient
		result2 error
	}
	CloseStub        func(*grpc.ClientConn) error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
		arg1 *grpc.ClientConn
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	DialStub        func() (*grpc.ClientConn, context.CancelFunc, error)
	dialMutex       sync.RWMutex
	dialArgsForCall []struct {
	}
	dialReturns struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}
	dialReturnsOnCall map[int]struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}
	FlushBacklogStub        func(*ttlcache.Cache, string) error
	flushBacklogMutex       sync.RWMutex
	flushBacklogArgsForCall []struct {
		arg1 *ttlcache.Cache
		arg2 string
	}
	flushBacklogReturns struct {
		result1 error
	}
	flushBacklogReturnsOnCall map[int]struct {
		result1 error
	}
	GetFromBacklogStub        func(*ttlcache.Cache, string) (interface{}, error)
	getFromBacklogMutex       sync.RWMutex
	getFromBacklogArgsForCall []struct {
		arg1 *ttlcache.Cache
		arg2 string
	}
	getFromBacklogReturns struct {
		result1 interface{}
		result2 error
	}
	getFromBacklogReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	GetenvStub        func(string) string
	getenvMutex       sync.RWMutex
	getenvArgsForCall []struct {
		arg1 string
	}
	getenvReturns struct {
		result1 string
	}
	getenvReturnsOnCall map[int]struct {
		result1 string
	}
	InClusterConfigStub        func() (*rest.Config, error)
	inClusterConfigMutex       sync.RWMutex
	inClusterConfigArgsForCall []struct {
	}
	inClusterConfigReturns struct {
		result1 *rest.Config
		result2 error
	}
	inClusterConfigReturnsOnCall map[int]struct {
		result1 *rest.Config
		result2 error
	}
	LinesStub        func(*tail.Tail) chan *tail.Line
	linesMutex       sync.RWMutex
	linesArgsForCall []struct {
		arg1 *tail.Tail
	}
	linesReturns struct {
		result1 chan *tail.Line
	}
	linesReturnsOnCall map[int]struct {
		result1 chan *tail.Line
	}
	ListPodsStub        func(*kubernetes.Clientset, string) (*v1.PodList, error)
	listPodsMutex       sync.RWMutex
	listPodsArgsForCall []struct {
		arg1 *kubernetes.Clientset
		arg2 string
	}
	listPodsReturns struct {
		result1 *v1.PodList
		result2 error
	}
	listPodsReturnsOnCall map[int]struct {
		result1 *v1.PodList
		result2 error
	}
	ListenStub        func(string, string) (net.Listener, error)
	listenMutex       sync.RWMutex
	listenArgsForCall []struct {
		arg1 string
		arg2 string
	}
	listenReturns struct {
		result1 net.Listener
		result2 error
	}
	listenReturnsOnCall map[int]struct {
		result1 net.Listener
		result2 error
	}
	NewForConfigStub        func(*rest.Config) (*kubernetes.Clientset, error)
	newForConfigMutex       sync.RWMutex
	newForConfigArgsForCall []struct {
		arg1 *rest.Config
	}
	newForConfigReturns struct {
		result1 *kubernetes.Clientset
		result2 error
	}
	newForConfigReturnsOnCall map[int]struct {
		result1 *kubernetes.Clientset
		result2 error
	}
	OpenStub        func(string) (*os.File, error)
	openMutex       sync.RWMutex
	openArgsForCall []struct {
		arg1 string
	}
	openReturns struct {
		result1 *os.File
		result2 error
	}
	openReturnsOnCall map[int]struct {
		result1 *os.File
		result2 error
	}
	ReasonStub        func(*tail.Tail) error
	reasonMutex       sync.RWMutex
	reasonArgsForCall []struct {
		arg1 *tail.Tail
	}
	reasonReturns struct {
		result1 error
	}
	reasonReturnsOnCall map[int]struct {
		result1 error
	}
	SendMetricStub        func(api_metrics.Metrics_AuditIncClient, *api_metrics.AuditRequest) error
	sendMetricMutex       sync.RWMutex
	sendMetricArgsForCall []struct {
		arg1 api_metrics.Metrics_AuditIncClient
		arg2 *api_metrics.AuditRequest
	}
	sendMetricReturns struct {
		result1 error
	}
	sendMetricReturnsOnCall map[int]struct {
		result1 error
	}
	ServeStub        func(*grpc.Server, net.Listener) error
	serveMutex       sync.RWMutex
	serveArgsForCall []struct {
		arg1 *grpc.Server
		arg2 net.Listener
	}
	serveReturns struct {
		result1 error
	}
	serveReturnsOnCall map[int]struct {
		result1 error
	}
	SetTTLStub        func(ttlcache.SimpleCache, time.Duration) error
	setTTLMutex       sync.RWMutex
	setTTLArgsForCall []struct {
		arg1 ttlcache.SimpleCache
		arg2 time.Duration
	}
	setTTLReturns struct {
		result1 error
	}
	setTTLReturnsOnCall map[int]struct {
		result1 error
	}
	TailFileStub        func(string, tail.Config) (*tail.Tail, error)
	tailFileMutex       sync.RWMutex
	tailFileArgsForCall []struct {
		arg1 string
		arg2 tail.Config
	}
	tailFileReturns struct {
		result1 *tail.Tail
		result2 error
	}
	tailFileReturnsOnCall map[int]struct {
		result1 *tail.Tail
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeImpl) AddToBacklog(arg1 *ttlcache.Cache, arg2 string, arg3 interface{}) error {
	fake.addToBacklogMutex.Lock()
	ret, specificReturn := fake.addToBacklogReturnsOnCall[len(fake.addToBacklogArgsForCall)]
	fake.addToBacklogArgsForCall = append(fake.addToBacklogArgsForCall, struct {
		arg1 *ttlcache.Cache
		arg2 string
		arg3 interface{}
	}{arg1, arg2, arg3})
	stub := fake.AddToBacklogStub
	fakeReturns := fake.addToBacklogReturns
	fake.recordInvocation("AddToBacklog", []interface{}{arg1, arg2, arg3})
	fake.addToBacklogMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) AddToBacklogCallCount() int {
	fake.addToBacklogMutex.RLock()
	defer fake.addToBacklogMutex.RUnlock()
	return len(fake.addToBacklogArgsForCall)
}

func (fake *FakeImpl) AddToBacklogCalls(stub func(*ttlcache.Cache, string, interface{}) error) {
	fake.addToBacklogMutex.Lock()
	defer fake.addToBacklogMutex.Unlock()
	fake.AddToBacklogStub = stub
}

func (fake *FakeImpl) AddToBacklogArgsForCall(i int) (*ttlcache.Cache, string, interface{}) {
	fake.addToBacklogMutex.RLock()
	defer fake.addToBacklogMutex.RUnlock()
	argsForCall := fake.addToBacklogArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) AddToBacklogReturns(result1 error) {
	fake.addToBacklogMutex.Lock()
	defer fake.addToBacklogMutex.Unlock()
	fake.AddToBacklogStub = nil
	fake.addToBacklogReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) AddToBacklogReturnsOnCall(i int, result1 error) {
	fake.addToBacklogMutex.Lock()
	defer fake.addToBacklogMutex.Unlock()
	fake.AddToBacklogStub = nil
	if fake.addToBacklogReturnsOnCall == nil {
		fake.addToBacklogReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addToBacklogReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) AuditInc(arg1 api_metrics.MetricsClient) (api_metrics.Metrics_AuditIncClient, error) {
	fake.auditIncMutex.Lock()
	ret, specificReturn := fake.auditIncReturnsOnCall[len(fake.auditIncArgsForCall)]
	fake.auditIncArgsForCall = append(fake.auditIncArgsForCall, struct {
		arg1 api_metrics.MetricsClient
	}{arg1})
	stub := fake.AuditIncStub
	fakeReturns := fake.auditIncReturns
	fake.recordInvocation("AuditInc", []interface{}{arg1})
	fake.auditIncMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) AuditIncCallCount() int {
	fake.auditIncMutex.RLock()
	defer fake.auditIncMutex.RUnlock()
	return len(fake.auditIncArgsForCall)
}

func (fake *FakeImpl) AuditIncCalls(stub func(api_metrics.MetricsClient) (api_metrics.Metrics_AuditIncClient, error)) {
	fake.auditIncMutex.Lock()
	defer fake.auditIncMutex.Unlock()
	fake.AuditIncStub = stub
}

func (fake *FakeImpl) AuditIncArgsForCall(i int) api_metrics.MetricsClient {
	fake.auditIncMutex.RLock()
	defer fake.auditIncMutex.RUnlock()
	argsForCall := fake.auditIncArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) AuditIncReturns(result1 api_metrics.Metrics_AuditIncClient, result2 error) {
	fake.auditIncMutex.Lock()
	defer fake.auditIncMutex.Unlock()
	fake.AuditIncStub = nil
	fake.auditIncReturns = struct {
		result1 api_metrics.Metrics_AuditIncClient
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) AuditIncReturnsOnCall(i int, result1 api_metrics.Metrics_AuditIncClient, result2 error) {
	fake.auditIncMutex.Lock()
	defer fake.auditIncMutex.Unlock()
	fake.AuditIncStub = nil
	if fake.auditIncReturnsOnCall == nil {
		fake.auditIncReturnsOnCall = make(map[int]struct {
			result1 api_metrics.Metrics_AuditIncClient
			result2 error
		})
	}
	fake.auditIncReturnsOnCall[i] = struct {
		result1 api_metrics.Metrics_AuditIncClient
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Close(arg1 *grpc.ClientConn) error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
		arg1 *grpc.ClientConn
	}{arg1})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{arg1})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeImpl) CloseCalls(stub func(*grpc.ClientConn) error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeImpl) CloseArgsForCall(i int) *grpc.ClientConn {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	argsForCall := fake.closeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) Dial() (*grpc.ClientConn, context.CancelFunc, error) {
	fake.dialMutex.Lock()
	ret, specificReturn := fake.dialReturnsOnCall[len(fake.dialArgsForCall)]
	fake.dialArgsForCall = append(fake.dialArgsForCall, struct {
	}{})
	stub := fake.DialStub
	fakeReturns := fake.dialReturns
	fake.recordInvocation("Dial", []interface{}{})
	fake.dialMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeImpl) DialCallCount() int {
	fake.dialMutex.RLock()
	defer fake.dialMutex.RUnlock()
	return len(fake.dialArgsForCall)
}

func (fake *FakeImpl) DialCalls(stub func() (*grpc.ClientConn, context.CancelFunc, error)) {
	fake.dialMutex.Lock()
	defer fake.dialMutex.Unlock()
	fake.DialStub = stub
}

func (fake *FakeImpl) DialReturns(result1 *grpc.ClientConn, result2 context.CancelFunc, result3 error) {
	fake.dialMutex.Lock()
	defer fake.dialMutex.Unlock()
	fake.DialStub = nil
	fake.dialReturns = struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeImpl) DialReturnsOnCall(i int, result1 *grpc.ClientConn, result2 context.CancelFunc, result3 error) {
	fake.dialMutex.Lock()
	defer fake.dialMutex.Unlock()
	fake.DialStub = nil
	if fake.dialReturnsOnCall == nil {
		fake.dialReturnsOnCall = make(map[int]struct {
			result1 *grpc.ClientConn
			result2 context.CancelFunc
			result3 error
		})
	}
	fake.dialReturnsOnCall[i] = struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeImpl) FlushBacklog(arg1 *ttlcache.Cache, arg2 string) error {
	fake.flushBacklogMutex.Lock()
	ret, specificReturn := fake.flushBacklogReturnsOnCall[len(fake.flushBacklogArgsForCall)]
	fake.flushBacklogArgsForCall = append(fake.flushBacklogArgsForCall, struct {
		arg1 *ttlcache.Cache
		arg2 string
	}{arg1, arg2})
	stub := fake.FlushBacklogStub
	fakeReturns := fake.flushBacklogReturns
	fake.recordInvocation("FlushBacklog", []interface{}{arg1, arg2})
	fake.flushBacklogMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) FlushBacklogCallCount() int {
	fake.flushBacklogMutex.RLock()
	defer fake.flushBacklogMutex.RUnlock()
	return len(fake.flushBacklogArgsForCall)
}

func (fake *FakeImpl) FlushBacklogCalls(stub func(*ttlcache.Cache, string) error) {
	fake.flushBacklogMutex.Lock()
	defer fake.flushBacklogMutex.Unlock()
	fake.FlushBacklogStub = stub
}

func (fake *FakeImpl) FlushBacklogArgsForCall(i int) (*ttlcache.Cache, string) {
	fake.flushBacklogMutex.RLock()
	defer fake.flushBacklogMutex.RUnlock()
	argsForCall := fake.flushBacklogArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) FlushBacklogReturns(result1 error) {
	fake.flushBacklogMutex.Lock()
	defer fake.flushBacklogMutex.Unlock()
	fake.FlushBacklogStub = nil
	fake.flushBacklogReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) FlushBacklogReturnsOnCall(i int, result1 error) {
	fake.flushBacklogMutex.Lock()
	defer fake.flushBacklogMutex.Unlock()
	fake.FlushBacklogStub = nil
	if fake.flushBacklogReturnsOnCall == nil {
		fake.flushBacklogReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.flushBacklogReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) GetFromBacklog(arg1 *ttlcache.Cache, arg2 string) (interface{}, error) {
	fake.getFromBacklogMutex.Lock()
	ret, specificReturn := fake.getFromBacklogReturnsOnCall[len(fake.getFromBacklogArgsForCall)]
	fake.getFromBacklogArgsForCall = append(fake.getFromBacklogArgsForCall, struct {
		arg1 *ttlcache.Cache
		arg2 string
	}{arg1, arg2})
	stub := fake.GetFromBacklogStub
	fakeReturns := fake.getFromBacklogReturns
	fake.recordInvocation("GetFromBacklog", []interface{}{arg1, arg2})
	fake.getFromBacklogMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) GetFromBacklogCallCount() int {
	fake.getFromBacklogMutex.RLock()
	defer fake.getFromBacklogMutex.RUnlock()
	return len(fake.getFromBacklogArgsForCall)
}

func (fake *FakeImpl) GetFromBacklogCalls(stub func(*ttlcache.Cache, string) (interface{}, error)) {
	fake.getFromBacklogMutex.Lock()
	defer fake.getFromBacklogMutex.Unlock()
	fake.GetFromBacklogStub = stub
}

func (fake *FakeImpl) GetFromBacklogArgsForCall(i int) (*ttlcache.Cache, string) {
	fake.getFromBacklogMutex.RLock()
	defer fake.getFromBacklogMutex.RUnlock()
	argsForCall := fake.getFromBacklogArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) GetFromBacklogReturns(result1 interface{}, result2 error) {
	fake.getFromBacklogMutex.Lock()
	defer fake.getFromBacklogMutex.Unlock()
	fake.GetFromBacklogStub = nil
	fake.getFromBacklogReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetFromBacklogReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.getFromBacklogMutex.Lock()
	defer fake.getFromBacklogMutex.Unlock()
	fake.GetFromBacklogStub = nil
	if fake.getFromBacklogReturnsOnCall == nil {
		fake.getFromBacklogReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.getFromBacklogReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Getenv(arg1 string) string {
	fake.getenvMutex.Lock()
	ret, specificReturn := fake.getenvReturnsOnCall[len(fake.getenvArgsForCall)]
	fake.getenvArgsForCall = append(fake.getenvArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetenvStub
	fakeReturns := fake.getenvReturns
	fake.recordInvocation("Getenv", []interface{}{arg1})
	fake.getenvMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) GetenvCallCount() int {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	return len(fake.getenvArgsForCall)
}

func (fake *FakeImpl) GetenvCalls(stub func(string) string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = stub
}

func (fake *FakeImpl) GetenvArgsForCall(i int) string {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	argsForCall := fake.getenvArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) GetenvReturns(result1 string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = nil
	fake.getenvReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeImpl) GetenvReturnsOnCall(i int, result1 string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = nil
	if fake.getenvReturnsOnCall == nil {
		fake.getenvReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getenvReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeImpl) InClusterConfig() (*rest.Config, error) {
	fake.inClusterConfigMutex.Lock()
	ret, specificReturn := fake.inClusterConfigReturnsOnCall[len(fake.inClusterConfigArgsForCall)]
	fake.inClusterConfigArgsForCall = append(fake.inClusterConfigArgsForCall, struct {
	}{})
	stub := fake.InClusterConfigStub
	fakeReturns := fake.inClusterConfigReturns
	fake.recordInvocation("InClusterConfig", []interface{}{})
	fake.inClusterConfigMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) InClusterConfigCallCount() int {
	fake.inClusterConfigMutex.RLock()
	defer fake.inClusterConfigMutex.RUnlock()
	return len(fake.inClusterConfigArgsForCall)
}

func (fake *FakeImpl) InClusterConfigCalls(stub func() (*rest.Config, error)) {
	fake.inClusterConfigMutex.Lock()
	defer fake.inClusterConfigMutex.Unlock()
	fake.InClusterConfigStub = stub
}

func (fake *FakeImpl) InClusterConfigReturns(result1 *rest.Config, result2 error) {
	fake.inClusterConfigMutex.Lock()
	defer fake.inClusterConfigMutex.Unlock()
	fake.InClusterConfigStub = nil
	fake.inClusterConfigReturns = struct {
		result1 *rest.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) InClusterConfigReturnsOnCall(i int, result1 *rest.Config, result2 error) {
	fake.inClusterConfigMutex.Lock()
	defer fake.inClusterConfigMutex.Unlock()
	fake.InClusterConfigStub = nil
	if fake.inClusterConfigReturnsOnCall == nil {
		fake.inClusterConfigReturnsOnCall = make(map[int]struct {
			result1 *rest.Config
			result2 error
		})
	}
	fake.inClusterConfigReturnsOnCall[i] = struct {
		result1 *rest.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Lines(arg1 *tail.Tail) chan *tail.Line {
	fake.linesMutex.Lock()
	ret, specificReturn := fake.linesReturnsOnCall[len(fake.linesArgsForCall)]
	fake.linesArgsForCall = append(fake.linesArgsForCall, struct {
		arg1 *tail.Tail
	}{arg1})
	stub := fake.LinesStub
	fakeReturns := fake.linesReturns
	fake.recordInvocation("Lines", []interface{}{arg1})
	fake.linesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) LinesCallCount() int {
	fake.linesMutex.RLock()
	defer fake.linesMutex.RUnlock()
	return len(fake.linesArgsForCall)
}

func (fake *FakeImpl) LinesCalls(stub func(*tail.Tail) chan *tail.Line) {
	fake.linesMutex.Lock()
	defer fake.linesMutex.Unlock()
	fake.LinesStub = stub
}

func (fake *FakeImpl) LinesArgsForCall(i int) *tail.Tail {
	fake.linesMutex.RLock()
	defer fake.linesMutex.RUnlock()
	argsForCall := fake.linesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) LinesReturns(result1 chan *tail.Line) {
	fake.linesMutex.Lock()
	defer fake.linesMutex.Unlock()
	fake.LinesStub = nil
	fake.linesReturns = struct {
		result1 chan *tail.Line
	}{result1}
}

func (fake *FakeImpl) LinesReturnsOnCall(i int, result1 chan *tail.Line) {
	fake.linesMutex.Lock()
	defer fake.linesMutex.Unlock()
	fake.LinesStub = nil
	if fake.linesReturnsOnCall == nil {
		fake.linesReturnsOnCall = make(map[int]struct {
			result1 chan *tail.Line
		})
	}
	fake.linesReturnsOnCall[i] = struct {
		result1 chan *tail.Line
	}{result1}
}

func (fake *FakeImpl) ListPods(arg1 *kubernetes.Clientset, arg2 string) (*v1.PodList, error) {
	fake.listPodsMutex.Lock()
	ret, specificReturn := fake.listPodsReturnsOnCall[len(fake.listPodsArgsForCall)]
	fake.listPodsArgsForCall = append(fake.listPodsArgsForCall, struct {
		arg1 *kubernetes.Clientset
		arg2 string
	}{arg1, arg2})
	stub := fake.ListPodsStub
	fakeReturns := fake.listPodsReturns
	fake.recordInvocation("ListPods", []interface{}{arg1, arg2})
	fake.listPodsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ListPodsCallCount() int {
	fake.listPodsMutex.RLock()
	defer fake.listPodsMutex.RUnlock()
	return len(fake.listPodsArgsForCall)
}

func (fake *FakeImpl) ListPodsCalls(stub func(*kubernetes.Clientset, string) (*v1.PodList, error)) {
	fake.listPodsMutex.Lock()
	defer fake.listPodsMutex.Unlock()
	fake.ListPodsStub = stub
}

func (fake *FakeImpl) ListPodsArgsForCall(i int) (*kubernetes.Clientset, string) {
	fake.listPodsMutex.RLock()
	defer fake.listPodsMutex.RUnlock()
	argsForCall := fake.listPodsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) ListPodsReturns(result1 *v1.PodList, result2 error) {
	fake.listPodsMutex.Lock()
	defer fake.listPodsMutex.Unlock()
	fake.ListPodsStub = nil
	fake.listPodsReturns = struct {
		result1 *v1.PodList
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ListPodsReturnsOnCall(i int, result1 *v1.PodList, result2 error) {
	fake.listPodsMutex.Lock()
	defer fake.listPodsMutex.Unlock()
	fake.ListPodsStub = nil
	if fake.listPodsReturnsOnCall == nil {
		fake.listPodsReturnsOnCall = make(map[int]struct {
			result1 *v1.PodList
			result2 error
		})
	}
	fake.listPodsReturnsOnCall[i] = struct {
		result1 *v1.PodList
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Listen(arg1 string, arg2 string) (net.Listener, error) {
	fake.listenMutex.Lock()
	ret, specificReturn := fake.listenReturnsOnCall[len(fake.listenArgsForCall)]
	fake.listenArgsForCall = append(fake.listenArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ListenStub
	fakeReturns := fake.listenReturns
	fake.recordInvocation("Listen", []interface{}{arg1, arg2})
	fake.listenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ListenCallCount() int {
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	return len(fake.listenArgsForCall)
}

func (fake *FakeImpl) ListenCalls(stub func(string, string) (net.Listener, error)) {
	fake.listenMutex.Lock()
	defer fake.listenMutex.Unlock()
	fake.ListenStub = stub
}

func (fake *FakeImpl) ListenArgsForCall(i int) (string, string) {
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	argsForCall := fake.listenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) ListenReturns(result1 net.Listener, result2 error) {
	fake.listenMutex.Lock()
	defer fake.listenMutex.Unlock()
	fake.ListenStub = nil
	fake.listenReturns = struct {
		result1 net.Listener
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ListenReturnsOnCall(i int, result1 net.Listener, result2 error) {
	fake.listenMutex.Lock()
	defer fake.listenMutex.Unlock()
	fake.ListenStub = nil
	if fake.listenReturnsOnCall == nil {
		fake.listenReturnsOnCall = make(map[int]struct {
			result1 net.Listener
			result2 error
		})
	}
	fake.listenReturnsOnCall[i] = struct {
		result1 net.Listener
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewForConfig(arg1 *rest.Config) (*kubernetes.Clientset, error) {
	fake.newForConfigMutex.Lock()
	ret, specificReturn := fake.newForConfigReturnsOnCall[len(fake.newForConfigArgsForCall)]
	fake.newForConfigArgsForCall = append(fake.newForConfigArgsForCall, struct {
		arg1 *rest.Config
	}{arg1})
	stub := fake.NewForConfigStub
	fakeReturns := fake.newForConfigReturns
	fake.recordInvocation("NewForConfig", []interface{}{arg1})
	fake.newForConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) NewForConfigCallCount() int {
	fake.newForConfigMutex.RLock()
	defer fake.newForConfigMutex.RUnlock()
	return len(fake.newForConfigArgsForCall)
}

func (fake *FakeImpl) NewForConfigCalls(stub func(*rest.Config) (*kubernetes.Clientset, error)) {
	fake.newForConfigMutex.Lock()
	defer fake.newForConfigMutex.Unlock()
	fake.NewForConfigStub = stub
}

func (fake *FakeImpl) NewForConfigArgsForCall(i int) *rest.Config {
	fake.newForConfigMutex.RLock()
	defer fake.newForConfigMutex.RUnlock()
	argsForCall := fake.newForConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) NewForConfigReturns(result1 *kubernetes.Clientset, result2 error) {
	fake.newForConfigMutex.Lock()
	defer fake.newForConfigMutex.Unlock()
	fake.NewForConfigStub = nil
	fake.newForConfigReturns = struct {
		result1 *kubernetes.Clientset
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewForConfigReturnsOnCall(i int, result1 *kubernetes.Clientset, result2 error) {
	fake.newForConfigMutex.Lock()
	defer fake.newForConfigMutex.Unlock()
	fake.NewForConfigStub = nil
	if fake.newForConfigReturnsOnCall == nil {
		fake.newForConfigReturnsOnCall = make(map[int]struct {
			result1 *kubernetes.Clientset
			result2 error
		})
	}
	fake.newForConfigReturnsOnCall[i] = struct {
		result1 *kubernetes.Clientset
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Open(arg1 string) (*os.File, error) {
	fake.openMutex.Lock()
	ret, specificReturn := fake.openReturnsOnCall[len(fake.openArgsForCall)]
	fake.openArgsForCall = append(fake.openArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.OpenStub
	fakeReturns := fake.openReturns
	fake.recordInvocation("Open", []interface{}{arg1})
	fake.openMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) OpenCallCount() int {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	return len(fake.openArgsForCall)
}

func (fake *FakeImpl) OpenCalls(stub func(string) (*os.File, error)) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = stub
}

func (fake *FakeImpl) OpenArgsForCall(i int) string {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	argsForCall := fake.openArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) OpenReturns(result1 *os.File, result2 error) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = nil
	fake.openReturns = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) OpenReturnsOnCall(i int, result1 *os.File, result2 error) {
	fake.openMutex.Lock()
	defer fake.openMutex.Unlock()
	fake.OpenStub = nil
	if fake.openReturnsOnCall == nil {
		fake.openReturnsOnCall = make(map[int]struct {
			result1 *os.File
			result2 error
		})
	}
	fake.openReturnsOnCall[i] = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Reason(arg1 *tail.Tail) error {
	fake.reasonMutex.Lock()
	ret, specificReturn := fake.reasonReturnsOnCall[len(fake.reasonArgsForCall)]
	fake.reasonArgsForCall = append(fake.reasonArgsForCall, struct {
		arg1 *tail.Tail
	}{arg1})
	stub := fake.ReasonStub
	fakeReturns := fake.reasonReturns
	fake.recordInvocation("Reason", []interface{}{arg1})
	fake.reasonMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) ReasonCallCount() int {
	fake.reasonMutex.RLock()
	defer fake.reasonMutex.RUnlock()
	return len(fake.reasonArgsForCall)
}

func (fake *FakeImpl) ReasonCalls(stub func(*tail.Tail) error) {
	fake.reasonMutex.Lock()
	defer fake.reasonMutex.Unlock()
	fake.ReasonStub = stub
}

func (fake *FakeImpl) ReasonArgsForCall(i int) *tail.Tail {
	fake.reasonMutex.RLock()
	defer fake.reasonMutex.RUnlock()
	argsForCall := fake.reasonArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) ReasonReturns(result1 error) {
	fake.reasonMutex.Lock()
	defer fake.reasonMutex.Unlock()
	fake.ReasonStub = nil
	fake.reasonReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) ReasonReturnsOnCall(i int, result1 error) {
	fake.reasonMutex.Lock()
	defer fake.reasonMutex.Unlock()
	fake.ReasonStub = nil
	if fake.reasonReturnsOnCall == nil {
		fake.reasonReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.reasonReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SendMetric(arg1 api_metrics.Metrics_AuditIncClient, arg2 *api_metrics.AuditRequest) error {
	fake.sendMetricMutex.Lock()
	ret, specificReturn := fake.sendMetricReturnsOnCall[len(fake.sendMetricArgsForCall)]
	fake.sendMetricArgsForCall = append(fake.sendMetricArgsForCall, struct {
		arg1 api_metrics.Metrics_AuditIncClient
		arg2 *api_metrics.AuditRequest
	}{arg1, arg2})
	stub := fake.SendMetricStub
	fakeReturns := fake.sendMetricReturns
	fake.recordInvocation("SendMetric", []interface{}{arg1, arg2})
	fake.sendMetricMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) SendMetricCallCount() int {
	fake.sendMetricMutex.RLock()
	defer fake.sendMetricMutex.RUnlock()
	return len(fake.sendMetricArgsForCall)
}

func (fake *FakeImpl) SendMetricCalls(stub func(api_metrics.Metrics_AuditIncClient, *api_metrics.AuditRequest) error) {
	fake.sendMetricMutex.Lock()
	defer fake.sendMetricMutex.Unlock()
	fake.SendMetricStub = stub
}

func (fake *FakeImpl) SendMetricArgsForCall(i int) (api_metrics.Metrics_AuditIncClient, *api_metrics.AuditRequest) {
	fake.sendMetricMutex.RLock()
	defer fake.sendMetricMutex.RUnlock()
	argsForCall := fake.sendMetricArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) SendMetricReturns(result1 error) {
	fake.sendMetricMutex.Lock()
	defer fake.sendMetricMutex.Unlock()
	fake.SendMetricStub = nil
	fake.sendMetricReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SendMetricReturnsOnCall(i int, result1 error) {
	fake.sendMetricMutex.Lock()
	defer fake.sendMetricMutex.Unlock()
	fake.SendMetricStub = nil
	if fake.sendMetricReturnsOnCall == nil {
		fake.sendMetricReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendMetricReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) Serve(arg1 *grpc.Server, arg2 net.Listener) error {
	fake.serveMutex.Lock()
	ret, specificReturn := fake.serveReturnsOnCall[len(fake.serveArgsForCall)]
	fake.serveArgsForCall = append(fake.serveArgsForCall, struct {
		arg1 *grpc.Server
		arg2 net.Listener
	}{arg1, arg2})
	stub := fake.ServeStub
	fakeReturns := fake.serveReturns
	fake.recordInvocation("Serve", []interface{}{arg1, arg2})
	fake.serveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) ServeCallCount() int {
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	return len(fake.serveArgsForCall)
}

func (fake *FakeImpl) ServeCalls(stub func(*grpc.Server, net.Listener) error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = stub
}

func (fake *FakeImpl) ServeArgsForCall(i int) (*grpc.Server, net.Listener) {
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	argsForCall := fake.serveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) ServeReturns(result1 error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = nil
	fake.serveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) ServeReturnsOnCall(i int, result1 error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = nil
	if fake.serveReturnsOnCall == nil {
		fake.serveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SetTTL(arg1 ttlcache.SimpleCache, arg2 time.Duration) error {
	fake.setTTLMutex.Lock()
	ret, specificReturn := fake.setTTLReturnsOnCall[len(fake.setTTLArgsForCall)]
	fake.setTTLArgsForCall = append(fake.setTTLArgsForCall, struct {
		arg1 ttlcache.SimpleCache
		arg2 time.Duration
	}{arg1, arg2})
	stub := fake.SetTTLStub
	fakeReturns := fake.setTTLReturns
	fake.recordInvocation("SetTTL", []interface{}{arg1, arg2})
	fake.setTTLMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) SetTTLCallCount() int {
	fake.setTTLMutex.RLock()
	defer fake.setTTLMutex.RUnlock()
	return len(fake.setTTLArgsForCall)
}

func (fake *FakeImpl) SetTTLCalls(stub func(ttlcache.SimpleCache, time.Duration) error) {
	fake.setTTLMutex.Lock()
	defer fake.setTTLMutex.Unlock()
	fake.SetTTLStub = stub
}

func (fake *FakeImpl) SetTTLArgsForCall(i int) (ttlcache.SimpleCache, time.Duration) {
	fake.setTTLMutex.RLock()
	defer fake.setTTLMutex.RUnlock()
	argsForCall := fake.setTTLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) SetTTLReturns(result1 error) {
	fake.setTTLMutex.Lock()
	defer fake.setTTLMutex.Unlock()
	fake.SetTTLStub = nil
	fake.setTTLReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SetTTLReturnsOnCall(i int, result1 error) {
	fake.setTTLMutex.Lock()
	defer fake.setTTLMutex.Unlock()
	fake.SetTTLStub = nil
	if fake.setTTLReturnsOnCall == nil {
		fake.setTTLReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setTTLReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) TailFile(arg1 string, arg2 tail.Config) (*tail.Tail, error) {
	fake.tailFileMutex.Lock()
	ret, specificReturn := fake.tailFileReturnsOnCall[len(fake.tailFileArgsForCall)]
	fake.tailFileArgsForCall = append(fake.tailFileArgsForCall, struct {
		arg1 string
		arg2 tail.Config
	}{arg1, arg2})
	stub := fake.TailFileStub
	fakeReturns := fake.tailFileReturns
	fake.recordInvocation("TailFile", []interface{}{arg1, arg2})
	fake.tailFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) TailFileCallCount() int {
	fake.tailFileMutex.RLock()
	defer fake.tailFileMutex.RUnlock()
	return len(fake.tailFileArgsForCall)
}

func (fake *FakeImpl) TailFileCalls(stub func(string, tail.Config) (*tail.Tail, error)) {
	fake.tailFileMutex.Lock()
	defer fake.tailFileMutex.Unlock()
	fake.TailFileStub = stub
}

func (fake *FakeImpl) TailFileArgsForCall(i int) (string, tail.Config) {
	fake.tailFileMutex.RLock()
	defer fake.tailFileMutex.RUnlock()
	argsForCall := fake.tailFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) TailFileReturns(result1 *tail.Tail, result2 error) {
	fake.tailFileMutex.Lock()
	defer fake.tailFileMutex.Unlock()
	fake.TailFileStub = nil
	fake.tailFileReturns = struct {
		result1 *tail.Tail
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) TailFileReturnsOnCall(i int, result1 *tail.Tail, result2 error) {
	fake.tailFileMutex.Lock()
	defer fake.tailFileMutex.Unlock()
	fake.TailFileStub = nil
	if fake.tailFileReturnsOnCall == nil {
		fake.tailFileReturnsOnCall = make(map[int]struct {
			result1 *tail.Tail
			result2 error
		})
	}
	fake.tailFileReturnsOnCall[i] = struct {
		result1 *tail.Tail
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addToBacklogMutex.RLock()
	defer fake.addToBacklogMutex.RUnlock()
	fake.auditIncMutex.RLock()
	defer fake.auditIncMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.dialMutex.RLock()
	defer fake.dialMutex.RUnlock()
	fake.flushBacklogMutex.RLock()
	defer fake.flushBacklogMutex.RUnlock()
	fake.getFromBacklogMutex.RLock()
	defer fake.getFromBacklogMutex.RUnlock()
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	fake.inClusterConfigMutex.RLock()
	defer fake.inClusterConfigMutex.RUnlock()
	fake.linesMutex.RLock()
	defer fake.linesMutex.RUnlock()
	fake.listPodsMutex.RLock()
	defer fake.listPodsMutex.RUnlock()
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	fake.newForConfigMutex.RLock()
	defer fake.newForConfigMutex.RUnlock()
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	fake.reasonMutex.RLock()
	defer fake.reasonMutex.RUnlock()
	fake.sendMetricMutex.RLock()
	defer fake.sendMetricMutex.RUnlock()
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	fake.setTTLMutex.RLock()
	defer fake.setTTLMutex.RUnlock()
	fake.tailFileMutex.RLock()
	defer fake.tailFileMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeImpl) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
