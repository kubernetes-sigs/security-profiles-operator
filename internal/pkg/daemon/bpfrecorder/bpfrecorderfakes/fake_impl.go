// +build linux

/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by counterfeiter. DO NOT EDIT.
package bpfrecorderfakes

import (
	"context"
	"io/fs"
	"net"
	"os"
	"sync"
	"syscall"
	"time"

	ttlcache "github.com/ReneKroon/ttlcache/v2"
	"github.com/aquasecurity/libbpfgo"
	seccomp "github.com/seccomp/libseccomp-golang"
	"google.golang.org/grpc"
	v1 "k8s.io/api/core/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
)

type FakeImpl struct {
	AttachTracepointStub        func(*libbpfgo.BPFProg, string, string) (*libbpfgo.BPFLink, error)
	attachTracepointMutex       sync.RWMutex
	attachTracepointArgsForCall []struct {
		arg1 *libbpfgo.BPFProg
		arg2 string
		arg3 string
	}
	attachTracepointReturns struct {
		result1 *libbpfgo.BPFLink
		result2 error
	}
	attachTracepointReturnsOnCall map[int]struct {
		result1 *libbpfgo.BPFLink
		result2 error
	}
	BPFLoadObjectStub        func(*libbpfgo.Module) error
	bPFLoadObjectMutex       sync.RWMutex
	bPFLoadObjectArgsForCall []struct {
		arg1 *libbpfgo.Module
	}
	bPFLoadObjectReturns struct {
		result1 error
	}
	bPFLoadObjectReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerIDForPIDStub        func(ttlcache.SimpleCache, int) (string, error)
	containerIDForPIDMutex       sync.RWMutex
	containerIDForPIDArgsForCall []struct {
		arg1 ttlcache.SimpleCache
		arg2 int
	}
	containerIDForPIDReturns struct {
		result1 string
		result2 error
	}
	containerIDForPIDReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DeleteKeyStub        func(*libbpfgo.BPFMap, uint32) error
	deleteKeyMutex       sync.RWMutex
	deleteKeyArgsForCall []struct {
		arg1 *libbpfgo.BPFMap
		arg2 uint32
	}
	deleteKeyReturns struct {
		result1 error
	}
	deleteKeyReturnsOnCall map[int]struct {
		result1 error
	}
	GetMapStub        func(*libbpfgo.Module, string) (*libbpfgo.BPFMap, error)
	getMapMutex       sync.RWMutex
	getMapArgsForCall []struct {
		arg1 *libbpfgo.Module
		arg2 string
	}
	getMapReturns struct {
		result1 *libbpfgo.BPFMap
		result2 error
	}
	getMapReturnsOnCall map[int]struct {
		result1 *libbpfgo.BPFMap
		result2 error
	}
	GetNameStub        func(seccomp.ScmpSyscall) (string, error)
	getNameMutex       sync.RWMutex
	getNameArgsForCall []struct {
		arg1 seccomp.ScmpSyscall
	}
	getNameReturns struct {
		result1 string
		result2 error
	}
	getNameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetProgramStub        func(*libbpfgo.Module, string) (*libbpfgo.BPFProg, error)
	getProgramMutex       sync.RWMutex
	getProgramArgsForCall []struct {
		arg1 *libbpfgo.Module
		arg2 string
	}
	getProgramReturns struct {
		result1 *libbpfgo.BPFProg
		result2 error
	}
	getProgramReturnsOnCall map[int]struct {
		result1 *libbpfgo.BPFProg
		result2 error
	}
	GetValueStub        func(*libbpfgo.BPFMap, uint32) ([]byte, error)
	getValueMutex       sync.RWMutex
	getValueArgsForCall []struct {
		arg1 *libbpfgo.BPFMap
		arg2 uint32
	}
	getValueReturns struct {
		result1 []byte
		result2 error
	}
	getValueReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetenvStub        func(string) string
	getenvMutex       sync.RWMutex
	getenvArgsForCall []struct {
		arg1 string
	}
	getenvReturns struct {
		result1 string
	}
	getenvReturnsOnCall map[int]struct {
		result1 string
	}
	InClusterConfigStub        func() (*rest.Config, error)
	inClusterConfigMutex       sync.RWMutex
	inClusterConfigArgsForCall []struct {
	}
	inClusterConfigReturns struct {
		result1 *rest.Config
		result2 error
	}
	inClusterConfigReturnsOnCall map[int]struct {
		result1 *rest.Config
		result2 error
	}
	InitRingBufStub        func(*libbpfgo.Module, string, chan []byte) (*libbpfgo.RingBuffer, error)
	initRingBufMutex       sync.RWMutex
	initRingBufArgsForCall []struct {
		arg1 *libbpfgo.Module
		arg2 string
		arg3 chan []byte
	}
	initRingBufReturns struct {
		result1 *libbpfgo.RingBuffer
		result2 error
	}
	initRingBufReturnsOnCall map[int]struct {
		result1 *libbpfgo.RingBuffer
		result2 error
	}
	ListPodsStub        func(context.Context, *kubernetes.Clientset, string) (*v1.PodList, error)
	listPodsMutex       sync.RWMutex
	listPodsArgsForCall []struct {
		arg1 context.Context
		arg2 *kubernetes.Clientset
		arg3 string
	}
	listPodsReturns struct {
		result1 *v1.PodList
		result2 error
	}
	listPodsReturnsOnCall map[int]struct {
		result1 *v1.PodList
		result2 error
	}
	ListenStub        func(string, string) (net.Listener, error)
	listenMutex       sync.RWMutex
	listenArgsForCall []struct {
		arg1 string
		arg2 string
	}
	listenReturns struct {
		result1 net.Listener
		result2 error
	}
	listenReturnsOnCall map[int]struct {
		result1 net.Listener
		result2 error
	}
	NewForConfigStub        func(*rest.Config) (*kubernetes.Clientset, error)
	newForConfigMutex       sync.RWMutex
	newForConfigArgsForCall []struct {
		arg1 *rest.Config
	}
	newForConfigReturns struct {
		result1 *kubernetes.Clientset
		result2 error
	}
	newForConfigReturnsOnCall map[int]struct {
		result1 *kubernetes.Clientset
		result2 error
	}
	NewModuleFromBufferArgsStub        func(*libbpfgo.NewModuleArgs) (*libbpfgo.Module, error)
	newModuleFromBufferArgsMutex       sync.RWMutex
	newModuleFromBufferArgsArgsForCall []struct {
		arg1 *libbpfgo.NewModuleArgs
	}
	newModuleFromBufferArgsReturns struct {
		result1 *libbpfgo.Module
		result2 error
	}
	newModuleFromBufferArgsReturnsOnCall map[int]struct {
		result1 *libbpfgo.Module
		result2 error
	}
	ReadOSReleaseStub        func() (map[string]string, error)
	readOSReleaseMutex       sync.RWMutex
	readOSReleaseArgsForCall []struct {
	}
	readOSReleaseReturns struct {
		result1 map[string]string
		result2 error
	}
	readOSReleaseReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	ServeStub        func(*grpc.Server, net.Listener) error
	serveMutex       sync.RWMutex
	serveArgsForCall []struct {
		arg1 *grpc.Server
		arg2 net.Listener
	}
	serveReturns struct {
		result1 error
	}
	serveReturnsOnCall map[int]struct {
		result1 error
	}
	SetTTLStub        func(ttlcache.SimpleCache, time.Duration) error
	setTTLMutex       sync.RWMutex
	setTTLArgsForCall []struct {
		arg1 ttlcache.SimpleCache
		arg2 time.Duration
	}
	setTTLReturns struct {
		result1 error
	}
	setTTLReturnsOnCall map[int]struct {
		result1 error
	}
	StatStub        func(string) (fs.FileInfo, error)
	statMutex       sync.RWMutex
	statArgsForCall []struct {
		arg1 string
	}
	statReturns struct {
		result1 fs.FileInfo
		result2 error
	}
	statReturnsOnCall map[int]struct {
		result1 fs.FileInfo
		result2 error
	}
	TempFileStub        func(string, string) (*os.File, error)
	tempFileMutex       sync.RWMutex
	tempFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	tempFileReturns struct {
		result1 *os.File
		result2 error
	}
	tempFileReturnsOnCall map[int]struct {
		result1 *os.File
		result2 error
	}
	UnameStub        func(*syscall.Utsname) error
	unameMutex       sync.RWMutex
	unameArgsForCall []struct {
		arg1 *syscall.Utsname
	}
	unameReturns struct {
		result1 error
	}
	unameReturnsOnCall map[int]struct {
		result1 error
	}
	UnmarshalStub        func([]byte, interface{}) error
	unmarshalMutex       sync.RWMutex
	unmarshalArgsForCall []struct {
		arg1 []byte
		arg2 interface{}
	}
	unmarshalReturns struct {
		result1 error
	}
	unmarshalReturnsOnCall map[int]struct {
		result1 error
	}
	WriteStub        func(*os.File, []byte) (int, error)
	writeMutex       sync.RWMutex
	writeArgsForCall []struct {
		arg1 *os.File
		arg2 []byte
	}
	writeReturns struct {
		result1 int
		result2 error
	}
	writeReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeImpl) AttachTracepoint(arg1 *libbpfgo.BPFProg, arg2 string, arg3 string) (*libbpfgo.BPFLink, error) {
	fake.attachTracepointMutex.Lock()
	ret, specificReturn := fake.attachTracepointReturnsOnCall[len(fake.attachTracepointArgsForCall)]
	fake.attachTracepointArgsForCall = append(fake.attachTracepointArgsForCall, struct {
		arg1 *libbpfgo.BPFProg
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.AttachTracepointStub
	fakeReturns := fake.attachTracepointReturns
	fake.recordInvocation("AttachTracepoint", []interface{}{arg1, arg2, arg3})
	fake.attachTracepointMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) AttachTracepointCallCount() int {
	fake.attachTracepointMutex.RLock()
	defer fake.attachTracepointMutex.RUnlock()
	return len(fake.attachTracepointArgsForCall)
}

func (fake *FakeImpl) AttachTracepointCalls(stub func(*libbpfgo.BPFProg, string, string) (*libbpfgo.BPFLink, error)) {
	fake.attachTracepointMutex.Lock()
	defer fake.attachTracepointMutex.Unlock()
	fake.AttachTracepointStub = stub
}

func (fake *FakeImpl) AttachTracepointArgsForCall(i int) (*libbpfgo.BPFProg, string, string) {
	fake.attachTracepointMutex.RLock()
	defer fake.attachTracepointMutex.RUnlock()
	argsForCall := fake.attachTracepointArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) AttachTracepointReturns(result1 *libbpfgo.BPFLink, result2 error) {
	fake.attachTracepointMutex.Lock()
	defer fake.attachTracepointMutex.Unlock()
	fake.AttachTracepointStub = nil
	fake.attachTracepointReturns = struct {
		result1 *libbpfgo.BPFLink
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) AttachTracepointReturnsOnCall(i int, result1 *libbpfgo.BPFLink, result2 error) {
	fake.attachTracepointMutex.Lock()
	defer fake.attachTracepointMutex.Unlock()
	fake.AttachTracepointStub = nil
	if fake.attachTracepointReturnsOnCall == nil {
		fake.attachTracepointReturnsOnCall = make(map[int]struct {
			result1 *libbpfgo.BPFLink
			result2 error
		})
	}
	fake.attachTracepointReturnsOnCall[i] = struct {
		result1 *libbpfgo.BPFLink
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) BPFLoadObject(arg1 *libbpfgo.Module) error {
	fake.bPFLoadObjectMutex.Lock()
	ret, specificReturn := fake.bPFLoadObjectReturnsOnCall[len(fake.bPFLoadObjectArgsForCall)]
	fake.bPFLoadObjectArgsForCall = append(fake.bPFLoadObjectArgsForCall, struct {
		arg1 *libbpfgo.Module
	}{arg1})
	stub := fake.BPFLoadObjectStub
	fakeReturns := fake.bPFLoadObjectReturns
	fake.recordInvocation("BPFLoadObject", []interface{}{arg1})
	fake.bPFLoadObjectMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) BPFLoadObjectCallCount() int {
	fake.bPFLoadObjectMutex.RLock()
	defer fake.bPFLoadObjectMutex.RUnlock()
	return len(fake.bPFLoadObjectArgsForCall)
}

func (fake *FakeImpl) BPFLoadObjectCalls(stub func(*libbpfgo.Module) error) {
	fake.bPFLoadObjectMutex.Lock()
	defer fake.bPFLoadObjectMutex.Unlock()
	fake.BPFLoadObjectStub = stub
}

func (fake *FakeImpl) BPFLoadObjectArgsForCall(i int) *libbpfgo.Module {
	fake.bPFLoadObjectMutex.RLock()
	defer fake.bPFLoadObjectMutex.RUnlock()
	argsForCall := fake.bPFLoadObjectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) BPFLoadObjectReturns(result1 error) {
	fake.bPFLoadObjectMutex.Lock()
	defer fake.bPFLoadObjectMutex.Unlock()
	fake.BPFLoadObjectStub = nil
	fake.bPFLoadObjectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) BPFLoadObjectReturnsOnCall(i int, result1 error) {
	fake.bPFLoadObjectMutex.Lock()
	defer fake.bPFLoadObjectMutex.Unlock()
	fake.BPFLoadObjectStub = nil
	if fake.bPFLoadObjectReturnsOnCall == nil {
		fake.bPFLoadObjectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.bPFLoadObjectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) ContainerIDForPID(arg1 ttlcache.SimpleCache, arg2 int) (string, error) {
	fake.containerIDForPIDMutex.Lock()
	ret, specificReturn := fake.containerIDForPIDReturnsOnCall[len(fake.containerIDForPIDArgsForCall)]
	fake.containerIDForPIDArgsForCall = append(fake.containerIDForPIDArgsForCall, struct {
		arg1 ttlcache.SimpleCache
		arg2 int
	}{arg1, arg2})
	stub := fake.ContainerIDForPIDStub
	fakeReturns := fake.containerIDForPIDReturns
	fake.recordInvocation("ContainerIDForPID", []interface{}{arg1, arg2})
	fake.containerIDForPIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ContainerIDForPIDCallCount() int {
	fake.containerIDForPIDMutex.RLock()
	defer fake.containerIDForPIDMutex.RUnlock()
	return len(fake.containerIDForPIDArgsForCall)
}

func (fake *FakeImpl) ContainerIDForPIDCalls(stub func(ttlcache.SimpleCache, int) (string, error)) {
	fake.containerIDForPIDMutex.Lock()
	defer fake.containerIDForPIDMutex.Unlock()
	fake.ContainerIDForPIDStub = stub
}

func (fake *FakeImpl) ContainerIDForPIDArgsForCall(i int) (ttlcache.SimpleCache, int) {
	fake.containerIDForPIDMutex.RLock()
	defer fake.containerIDForPIDMutex.RUnlock()
	argsForCall := fake.containerIDForPIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) ContainerIDForPIDReturns(result1 string, result2 error) {
	fake.containerIDForPIDMutex.Lock()
	defer fake.containerIDForPIDMutex.Unlock()
	fake.ContainerIDForPIDStub = nil
	fake.containerIDForPIDReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ContainerIDForPIDReturnsOnCall(i int, result1 string, result2 error) {
	fake.containerIDForPIDMutex.Lock()
	defer fake.containerIDForPIDMutex.Unlock()
	fake.ContainerIDForPIDStub = nil
	if fake.containerIDForPIDReturnsOnCall == nil {
		fake.containerIDForPIDReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.containerIDForPIDReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) DeleteKey(arg1 *libbpfgo.BPFMap, arg2 uint32) error {
	fake.deleteKeyMutex.Lock()
	ret, specificReturn := fake.deleteKeyReturnsOnCall[len(fake.deleteKeyArgsForCall)]
	fake.deleteKeyArgsForCall = append(fake.deleteKeyArgsForCall, struct {
		arg1 *libbpfgo.BPFMap
		arg2 uint32
	}{arg1, arg2})
	stub := fake.DeleteKeyStub
	fakeReturns := fake.deleteKeyReturns
	fake.recordInvocation("DeleteKey", []interface{}{arg1, arg2})
	fake.deleteKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) DeleteKeyCallCount() int {
	fake.deleteKeyMutex.RLock()
	defer fake.deleteKeyMutex.RUnlock()
	return len(fake.deleteKeyArgsForCall)
}

func (fake *FakeImpl) DeleteKeyCalls(stub func(*libbpfgo.BPFMap, uint32) error) {
	fake.deleteKeyMutex.Lock()
	defer fake.deleteKeyMutex.Unlock()
	fake.DeleteKeyStub = stub
}

func (fake *FakeImpl) DeleteKeyArgsForCall(i int) (*libbpfgo.BPFMap, uint32) {
	fake.deleteKeyMutex.RLock()
	defer fake.deleteKeyMutex.RUnlock()
	argsForCall := fake.deleteKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) DeleteKeyReturns(result1 error) {
	fake.deleteKeyMutex.Lock()
	defer fake.deleteKeyMutex.Unlock()
	fake.DeleteKeyStub = nil
	fake.deleteKeyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) DeleteKeyReturnsOnCall(i int, result1 error) {
	fake.deleteKeyMutex.Lock()
	defer fake.deleteKeyMutex.Unlock()
	fake.DeleteKeyStub = nil
	if fake.deleteKeyReturnsOnCall == nil {
		fake.deleteKeyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteKeyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) GetMap(arg1 *libbpfgo.Module, arg2 string) (*libbpfgo.BPFMap, error) {
	fake.getMapMutex.Lock()
	ret, specificReturn := fake.getMapReturnsOnCall[len(fake.getMapArgsForCall)]
	fake.getMapArgsForCall = append(fake.getMapArgsForCall, struct {
		arg1 *libbpfgo.Module
		arg2 string
	}{arg1, arg2})
	stub := fake.GetMapStub
	fakeReturns := fake.getMapReturns
	fake.recordInvocation("GetMap", []interface{}{arg1, arg2})
	fake.getMapMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) GetMapCallCount() int {
	fake.getMapMutex.RLock()
	defer fake.getMapMutex.RUnlock()
	return len(fake.getMapArgsForCall)
}

func (fake *FakeImpl) GetMapCalls(stub func(*libbpfgo.Module, string) (*libbpfgo.BPFMap, error)) {
	fake.getMapMutex.Lock()
	defer fake.getMapMutex.Unlock()
	fake.GetMapStub = stub
}

func (fake *FakeImpl) GetMapArgsForCall(i int) (*libbpfgo.Module, string) {
	fake.getMapMutex.RLock()
	defer fake.getMapMutex.RUnlock()
	argsForCall := fake.getMapArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) GetMapReturns(result1 *libbpfgo.BPFMap, result2 error) {
	fake.getMapMutex.Lock()
	defer fake.getMapMutex.Unlock()
	fake.GetMapStub = nil
	fake.getMapReturns = struct {
		result1 *libbpfgo.BPFMap
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetMapReturnsOnCall(i int, result1 *libbpfgo.BPFMap, result2 error) {
	fake.getMapMutex.Lock()
	defer fake.getMapMutex.Unlock()
	fake.GetMapStub = nil
	if fake.getMapReturnsOnCall == nil {
		fake.getMapReturnsOnCall = make(map[int]struct {
			result1 *libbpfgo.BPFMap
			result2 error
		})
	}
	fake.getMapReturnsOnCall[i] = struct {
		result1 *libbpfgo.BPFMap
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetName(arg1 seccomp.ScmpSyscall) (string, error) {
	fake.getNameMutex.Lock()
	ret, specificReturn := fake.getNameReturnsOnCall[len(fake.getNameArgsForCall)]
	fake.getNameArgsForCall = append(fake.getNameArgsForCall, struct {
		arg1 seccomp.ScmpSyscall
	}{arg1})
	stub := fake.GetNameStub
	fakeReturns := fake.getNameReturns
	fake.recordInvocation("GetName", []interface{}{arg1})
	fake.getNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) GetNameCallCount() int {
	fake.getNameMutex.RLock()
	defer fake.getNameMutex.RUnlock()
	return len(fake.getNameArgsForCall)
}

func (fake *FakeImpl) GetNameCalls(stub func(seccomp.ScmpSyscall) (string, error)) {
	fake.getNameMutex.Lock()
	defer fake.getNameMutex.Unlock()
	fake.GetNameStub = stub
}

func (fake *FakeImpl) GetNameArgsForCall(i int) seccomp.ScmpSyscall {
	fake.getNameMutex.RLock()
	defer fake.getNameMutex.RUnlock()
	argsForCall := fake.getNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) GetNameReturns(result1 string, result2 error) {
	fake.getNameMutex.Lock()
	defer fake.getNameMutex.Unlock()
	fake.GetNameStub = nil
	fake.getNameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetNameReturnsOnCall(i int, result1 string, result2 error) {
	fake.getNameMutex.Lock()
	defer fake.getNameMutex.Unlock()
	fake.GetNameStub = nil
	if fake.getNameReturnsOnCall == nil {
		fake.getNameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getNameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetProgram(arg1 *libbpfgo.Module, arg2 string) (*libbpfgo.BPFProg, error) {
	fake.getProgramMutex.Lock()
	ret, specificReturn := fake.getProgramReturnsOnCall[len(fake.getProgramArgsForCall)]
	fake.getProgramArgsForCall = append(fake.getProgramArgsForCall, struct {
		arg1 *libbpfgo.Module
		arg2 string
	}{arg1, arg2})
	stub := fake.GetProgramStub
	fakeReturns := fake.getProgramReturns
	fake.recordInvocation("GetProgram", []interface{}{arg1, arg2})
	fake.getProgramMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) GetProgramCallCount() int {
	fake.getProgramMutex.RLock()
	defer fake.getProgramMutex.RUnlock()
	return len(fake.getProgramArgsForCall)
}

func (fake *FakeImpl) GetProgramCalls(stub func(*libbpfgo.Module, string) (*libbpfgo.BPFProg, error)) {
	fake.getProgramMutex.Lock()
	defer fake.getProgramMutex.Unlock()
	fake.GetProgramStub = stub
}

func (fake *FakeImpl) GetProgramArgsForCall(i int) (*libbpfgo.Module, string) {
	fake.getProgramMutex.RLock()
	defer fake.getProgramMutex.RUnlock()
	argsForCall := fake.getProgramArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) GetProgramReturns(result1 *libbpfgo.BPFProg, result2 error) {
	fake.getProgramMutex.Lock()
	defer fake.getProgramMutex.Unlock()
	fake.GetProgramStub = nil
	fake.getProgramReturns = struct {
		result1 *libbpfgo.BPFProg
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetProgramReturnsOnCall(i int, result1 *libbpfgo.BPFProg, result2 error) {
	fake.getProgramMutex.Lock()
	defer fake.getProgramMutex.Unlock()
	fake.GetProgramStub = nil
	if fake.getProgramReturnsOnCall == nil {
		fake.getProgramReturnsOnCall = make(map[int]struct {
			result1 *libbpfgo.BPFProg
			result2 error
		})
	}
	fake.getProgramReturnsOnCall[i] = struct {
		result1 *libbpfgo.BPFProg
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetValue(arg1 *libbpfgo.BPFMap, arg2 uint32) ([]byte, error) {
	fake.getValueMutex.Lock()
	ret, specificReturn := fake.getValueReturnsOnCall[len(fake.getValueArgsForCall)]
	fake.getValueArgsForCall = append(fake.getValueArgsForCall, struct {
		arg1 *libbpfgo.BPFMap
		arg2 uint32
	}{arg1, arg2})
	stub := fake.GetValueStub
	fakeReturns := fake.getValueReturns
	fake.recordInvocation("GetValue", []interface{}{arg1, arg2})
	fake.getValueMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) GetValueCallCount() int {
	fake.getValueMutex.RLock()
	defer fake.getValueMutex.RUnlock()
	return len(fake.getValueArgsForCall)
}

func (fake *FakeImpl) GetValueCalls(stub func(*libbpfgo.BPFMap, uint32) ([]byte, error)) {
	fake.getValueMutex.Lock()
	defer fake.getValueMutex.Unlock()
	fake.GetValueStub = stub
}

func (fake *FakeImpl) GetValueArgsForCall(i int) (*libbpfgo.BPFMap, uint32) {
	fake.getValueMutex.RLock()
	defer fake.getValueMutex.RUnlock()
	argsForCall := fake.getValueArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) GetValueReturns(result1 []byte, result2 error) {
	fake.getValueMutex.Lock()
	defer fake.getValueMutex.Unlock()
	fake.GetValueStub = nil
	fake.getValueReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetValueReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.getValueMutex.Lock()
	defer fake.getValueMutex.Unlock()
	fake.GetValueStub = nil
	if fake.getValueReturnsOnCall == nil {
		fake.getValueReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getValueReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Getenv(arg1 string) string {
	fake.getenvMutex.Lock()
	ret, specificReturn := fake.getenvReturnsOnCall[len(fake.getenvArgsForCall)]
	fake.getenvArgsForCall = append(fake.getenvArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetenvStub
	fakeReturns := fake.getenvReturns
	fake.recordInvocation("Getenv", []interface{}{arg1})
	fake.getenvMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) GetenvCallCount() int {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	return len(fake.getenvArgsForCall)
}

func (fake *FakeImpl) GetenvCalls(stub func(string) string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = stub
}

func (fake *FakeImpl) GetenvArgsForCall(i int) string {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	argsForCall := fake.getenvArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) GetenvReturns(result1 string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = nil
	fake.getenvReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeImpl) GetenvReturnsOnCall(i int, result1 string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = nil
	if fake.getenvReturnsOnCall == nil {
		fake.getenvReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getenvReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeImpl) InClusterConfig() (*rest.Config, error) {
	fake.inClusterConfigMutex.Lock()
	ret, specificReturn := fake.inClusterConfigReturnsOnCall[len(fake.inClusterConfigArgsForCall)]
	fake.inClusterConfigArgsForCall = append(fake.inClusterConfigArgsForCall, struct {
	}{})
	stub := fake.InClusterConfigStub
	fakeReturns := fake.inClusterConfigReturns
	fake.recordInvocation("InClusterConfig", []interface{}{})
	fake.inClusterConfigMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) InClusterConfigCallCount() int {
	fake.inClusterConfigMutex.RLock()
	defer fake.inClusterConfigMutex.RUnlock()
	return len(fake.inClusterConfigArgsForCall)
}

func (fake *FakeImpl) InClusterConfigCalls(stub func() (*rest.Config, error)) {
	fake.inClusterConfigMutex.Lock()
	defer fake.inClusterConfigMutex.Unlock()
	fake.InClusterConfigStub = stub
}

func (fake *FakeImpl) InClusterConfigReturns(result1 *rest.Config, result2 error) {
	fake.inClusterConfigMutex.Lock()
	defer fake.inClusterConfigMutex.Unlock()
	fake.InClusterConfigStub = nil
	fake.inClusterConfigReturns = struct {
		result1 *rest.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) InClusterConfigReturnsOnCall(i int, result1 *rest.Config, result2 error) {
	fake.inClusterConfigMutex.Lock()
	defer fake.inClusterConfigMutex.Unlock()
	fake.InClusterConfigStub = nil
	if fake.inClusterConfigReturnsOnCall == nil {
		fake.inClusterConfigReturnsOnCall = make(map[int]struct {
			result1 *rest.Config
			result2 error
		})
	}
	fake.inClusterConfigReturnsOnCall[i] = struct {
		result1 *rest.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) InitRingBuf(arg1 *libbpfgo.Module, arg2 string, arg3 chan []byte) (*libbpfgo.RingBuffer, error) {
	fake.initRingBufMutex.Lock()
	ret, specificReturn := fake.initRingBufReturnsOnCall[len(fake.initRingBufArgsForCall)]
	fake.initRingBufArgsForCall = append(fake.initRingBufArgsForCall, struct {
		arg1 *libbpfgo.Module
		arg2 string
		arg3 chan []byte
	}{arg1, arg2, arg3})
	stub := fake.InitRingBufStub
	fakeReturns := fake.initRingBufReturns
	fake.recordInvocation("InitRingBuf", []interface{}{arg1, arg2, arg3})
	fake.initRingBufMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) InitRingBufCallCount() int {
	fake.initRingBufMutex.RLock()
	defer fake.initRingBufMutex.RUnlock()
	return len(fake.initRingBufArgsForCall)
}

func (fake *FakeImpl) InitRingBufCalls(stub func(*libbpfgo.Module, string, chan []byte) (*libbpfgo.RingBuffer, error)) {
	fake.initRingBufMutex.Lock()
	defer fake.initRingBufMutex.Unlock()
	fake.InitRingBufStub = stub
}

func (fake *FakeImpl) InitRingBufArgsForCall(i int) (*libbpfgo.Module, string, chan []byte) {
	fake.initRingBufMutex.RLock()
	defer fake.initRingBufMutex.RUnlock()
	argsForCall := fake.initRingBufArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) InitRingBufReturns(result1 *libbpfgo.RingBuffer, result2 error) {
	fake.initRingBufMutex.Lock()
	defer fake.initRingBufMutex.Unlock()
	fake.InitRingBufStub = nil
	fake.initRingBufReturns = struct {
		result1 *libbpfgo.RingBuffer
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) InitRingBufReturnsOnCall(i int, result1 *libbpfgo.RingBuffer, result2 error) {
	fake.initRingBufMutex.Lock()
	defer fake.initRingBufMutex.Unlock()
	fake.InitRingBufStub = nil
	if fake.initRingBufReturnsOnCall == nil {
		fake.initRingBufReturnsOnCall = make(map[int]struct {
			result1 *libbpfgo.RingBuffer
			result2 error
		})
	}
	fake.initRingBufReturnsOnCall[i] = struct {
		result1 *libbpfgo.RingBuffer
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ListPods(arg1 context.Context, arg2 *kubernetes.Clientset, arg3 string) (*v1.PodList, error) {
	fake.listPodsMutex.Lock()
	ret, specificReturn := fake.listPodsReturnsOnCall[len(fake.listPodsArgsForCall)]
	fake.listPodsArgsForCall = append(fake.listPodsArgsForCall, struct {
		arg1 context.Context
		arg2 *kubernetes.Clientset
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ListPodsStub
	fakeReturns := fake.listPodsReturns
	fake.recordInvocation("ListPods", []interface{}{arg1, arg2, arg3})
	fake.listPodsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ListPodsCallCount() int {
	fake.listPodsMutex.RLock()
	defer fake.listPodsMutex.RUnlock()
	return len(fake.listPodsArgsForCall)
}

func (fake *FakeImpl) ListPodsCalls(stub func(context.Context, *kubernetes.Clientset, string) (*v1.PodList, error)) {
	fake.listPodsMutex.Lock()
	defer fake.listPodsMutex.Unlock()
	fake.ListPodsStub = stub
}

func (fake *FakeImpl) ListPodsArgsForCall(i int) (context.Context, *kubernetes.Clientset, string) {
	fake.listPodsMutex.RLock()
	defer fake.listPodsMutex.RUnlock()
	argsForCall := fake.listPodsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) ListPodsReturns(result1 *v1.PodList, result2 error) {
	fake.listPodsMutex.Lock()
	defer fake.listPodsMutex.Unlock()
	fake.ListPodsStub = nil
	fake.listPodsReturns = struct {
		result1 *v1.PodList
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ListPodsReturnsOnCall(i int, result1 *v1.PodList, result2 error) {
	fake.listPodsMutex.Lock()
	defer fake.listPodsMutex.Unlock()
	fake.ListPodsStub = nil
	if fake.listPodsReturnsOnCall == nil {
		fake.listPodsReturnsOnCall = make(map[int]struct {
			result1 *v1.PodList
			result2 error
		})
	}
	fake.listPodsReturnsOnCall[i] = struct {
		result1 *v1.PodList
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Listen(arg1 string, arg2 string) (net.Listener, error) {
	fake.listenMutex.Lock()
	ret, specificReturn := fake.listenReturnsOnCall[len(fake.listenArgsForCall)]
	fake.listenArgsForCall = append(fake.listenArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ListenStub
	fakeReturns := fake.listenReturns
	fake.recordInvocation("Listen", []interface{}{arg1, arg2})
	fake.listenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ListenCallCount() int {
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	return len(fake.listenArgsForCall)
}

func (fake *FakeImpl) ListenCalls(stub func(string, string) (net.Listener, error)) {
	fake.listenMutex.Lock()
	defer fake.listenMutex.Unlock()
	fake.ListenStub = stub
}

func (fake *FakeImpl) ListenArgsForCall(i int) (string, string) {
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	argsForCall := fake.listenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) ListenReturns(result1 net.Listener, result2 error) {
	fake.listenMutex.Lock()
	defer fake.listenMutex.Unlock()
	fake.ListenStub = nil
	fake.listenReturns = struct {
		result1 net.Listener
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ListenReturnsOnCall(i int, result1 net.Listener, result2 error) {
	fake.listenMutex.Lock()
	defer fake.listenMutex.Unlock()
	fake.ListenStub = nil
	if fake.listenReturnsOnCall == nil {
		fake.listenReturnsOnCall = make(map[int]struct {
			result1 net.Listener
			result2 error
		})
	}
	fake.listenReturnsOnCall[i] = struct {
		result1 net.Listener
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewForConfig(arg1 *rest.Config) (*kubernetes.Clientset, error) {
	fake.newForConfigMutex.Lock()
	ret, specificReturn := fake.newForConfigReturnsOnCall[len(fake.newForConfigArgsForCall)]
	fake.newForConfigArgsForCall = append(fake.newForConfigArgsForCall, struct {
		arg1 *rest.Config
	}{arg1})
	stub := fake.NewForConfigStub
	fakeReturns := fake.newForConfigReturns
	fake.recordInvocation("NewForConfig", []interface{}{arg1})
	fake.newForConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) NewForConfigCallCount() int {
	fake.newForConfigMutex.RLock()
	defer fake.newForConfigMutex.RUnlock()
	return len(fake.newForConfigArgsForCall)
}

func (fake *FakeImpl) NewForConfigCalls(stub func(*rest.Config) (*kubernetes.Clientset, error)) {
	fake.newForConfigMutex.Lock()
	defer fake.newForConfigMutex.Unlock()
	fake.NewForConfigStub = stub
}

func (fake *FakeImpl) NewForConfigArgsForCall(i int) *rest.Config {
	fake.newForConfigMutex.RLock()
	defer fake.newForConfigMutex.RUnlock()
	argsForCall := fake.newForConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) NewForConfigReturns(result1 *kubernetes.Clientset, result2 error) {
	fake.newForConfigMutex.Lock()
	defer fake.newForConfigMutex.Unlock()
	fake.NewForConfigStub = nil
	fake.newForConfigReturns = struct {
		result1 *kubernetes.Clientset
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewForConfigReturnsOnCall(i int, result1 *kubernetes.Clientset, result2 error) {
	fake.newForConfigMutex.Lock()
	defer fake.newForConfigMutex.Unlock()
	fake.NewForConfigStub = nil
	if fake.newForConfigReturnsOnCall == nil {
		fake.newForConfigReturnsOnCall = make(map[int]struct {
			result1 *kubernetes.Clientset
			result2 error
		})
	}
	fake.newForConfigReturnsOnCall[i] = struct {
		result1 *kubernetes.Clientset
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewModuleFromBufferArgs(arg1 *libbpfgo.NewModuleArgs) (*libbpfgo.Module, error) {
	fake.newModuleFromBufferArgsMutex.Lock()
	ret, specificReturn := fake.newModuleFromBufferArgsReturnsOnCall[len(fake.newModuleFromBufferArgsArgsForCall)]
	fake.newModuleFromBufferArgsArgsForCall = append(fake.newModuleFromBufferArgsArgsForCall, struct {
		arg1 *libbpfgo.NewModuleArgs
	}{arg1})
	stub := fake.NewModuleFromBufferArgsStub
	fakeReturns := fake.newModuleFromBufferArgsReturns
	fake.recordInvocation("NewModuleFromBufferArgs", []interface{}{arg1})
	fake.newModuleFromBufferArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) NewModuleFromBufferArgsCallCount() int {
	fake.newModuleFromBufferArgsMutex.RLock()
	defer fake.newModuleFromBufferArgsMutex.RUnlock()
	return len(fake.newModuleFromBufferArgsArgsForCall)
}

func (fake *FakeImpl) NewModuleFromBufferArgsCalls(stub func(*libbpfgo.NewModuleArgs) (*libbpfgo.Module, error)) {
	fake.newModuleFromBufferArgsMutex.Lock()
	defer fake.newModuleFromBufferArgsMutex.Unlock()
	fake.NewModuleFromBufferArgsStub = stub
}

func (fake *FakeImpl) NewModuleFromBufferArgsArgsForCall(i int) *libbpfgo.NewModuleArgs {
	fake.newModuleFromBufferArgsMutex.RLock()
	defer fake.newModuleFromBufferArgsMutex.RUnlock()
	argsForCall := fake.newModuleFromBufferArgsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) NewModuleFromBufferArgsReturns(result1 *libbpfgo.Module, result2 error) {
	fake.newModuleFromBufferArgsMutex.Lock()
	defer fake.newModuleFromBufferArgsMutex.Unlock()
	fake.NewModuleFromBufferArgsStub = nil
	fake.newModuleFromBufferArgsReturns = struct {
		result1 *libbpfgo.Module
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewModuleFromBufferArgsReturnsOnCall(i int, result1 *libbpfgo.Module, result2 error) {
	fake.newModuleFromBufferArgsMutex.Lock()
	defer fake.newModuleFromBufferArgsMutex.Unlock()
	fake.NewModuleFromBufferArgsStub = nil
	if fake.newModuleFromBufferArgsReturnsOnCall == nil {
		fake.newModuleFromBufferArgsReturnsOnCall = make(map[int]struct {
			result1 *libbpfgo.Module
			result2 error
		})
	}
	fake.newModuleFromBufferArgsReturnsOnCall[i] = struct {
		result1 *libbpfgo.Module
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ReadOSRelease() (map[string]string, error) {
	fake.readOSReleaseMutex.Lock()
	ret, specificReturn := fake.readOSReleaseReturnsOnCall[len(fake.readOSReleaseArgsForCall)]
	fake.readOSReleaseArgsForCall = append(fake.readOSReleaseArgsForCall, struct {
	}{})
	stub := fake.ReadOSReleaseStub
	fakeReturns := fake.readOSReleaseReturns
	fake.recordInvocation("ReadOSRelease", []interface{}{})
	fake.readOSReleaseMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ReadOSReleaseCallCount() int {
	fake.readOSReleaseMutex.RLock()
	defer fake.readOSReleaseMutex.RUnlock()
	return len(fake.readOSReleaseArgsForCall)
}

func (fake *FakeImpl) ReadOSReleaseCalls(stub func() (map[string]string, error)) {
	fake.readOSReleaseMutex.Lock()
	defer fake.readOSReleaseMutex.Unlock()
	fake.ReadOSReleaseStub = stub
}

func (fake *FakeImpl) ReadOSReleaseReturns(result1 map[string]string, result2 error) {
	fake.readOSReleaseMutex.Lock()
	defer fake.readOSReleaseMutex.Unlock()
	fake.ReadOSReleaseStub = nil
	fake.readOSReleaseReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ReadOSReleaseReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.readOSReleaseMutex.Lock()
	defer fake.readOSReleaseMutex.Unlock()
	fake.ReadOSReleaseStub = nil
	if fake.readOSReleaseReturnsOnCall == nil {
		fake.readOSReleaseReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.readOSReleaseReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Serve(arg1 *grpc.Server, arg2 net.Listener) error {
	fake.serveMutex.Lock()
	ret, specificReturn := fake.serveReturnsOnCall[len(fake.serveArgsForCall)]
	fake.serveArgsForCall = append(fake.serveArgsForCall, struct {
		arg1 *grpc.Server
		arg2 net.Listener
	}{arg1, arg2})
	stub := fake.ServeStub
	fakeReturns := fake.serveReturns
	fake.recordInvocation("Serve", []interface{}{arg1, arg2})
	fake.serveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) ServeCallCount() int {
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	return len(fake.serveArgsForCall)
}

func (fake *FakeImpl) ServeCalls(stub func(*grpc.Server, net.Listener) error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = stub
}

func (fake *FakeImpl) ServeArgsForCall(i int) (*grpc.Server, net.Listener) {
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	argsForCall := fake.serveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) ServeReturns(result1 error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = nil
	fake.serveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) ServeReturnsOnCall(i int, result1 error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = nil
	if fake.serveReturnsOnCall == nil {
		fake.serveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SetTTL(arg1 ttlcache.SimpleCache, arg2 time.Duration) error {
	fake.setTTLMutex.Lock()
	ret, specificReturn := fake.setTTLReturnsOnCall[len(fake.setTTLArgsForCall)]
	fake.setTTLArgsForCall = append(fake.setTTLArgsForCall, struct {
		arg1 ttlcache.SimpleCache
		arg2 time.Duration
	}{arg1, arg2})
	stub := fake.SetTTLStub
	fakeReturns := fake.setTTLReturns
	fake.recordInvocation("SetTTL", []interface{}{arg1, arg2})
	fake.setTTLMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) SetTTLCallCount() int {
	fake.setTTLMutex.RLock()
	defer fake.setTTLMutex.RUnlock()
	return len(fake.setTTLArgsForCall)
}

func (fake *FakeImpl) SetTTLCalls(stub func(ttlcache.SimpleCache, time.Duration) error) {
	fake.setTTLMutex.Lock()
	defer fake.setTTLMutex.Unlock()
	fake.SetTTLStub = stub
}

func (fake *FakeImpl) SetTTLArgsForCall(i int) (ttlcache.SimpleCache, time.Duration) {
	fake.setTTLMutex.RLock()
	defer fake.setTTLMutex.RUnlock()
	argsForCall := fake.setTTLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) SetTTLReturns(result1 error) {
	fake.setTTLMutex.Lock()
	defer fake.setTTLMutex.Unlock()
	fake.SetTTLStub = nil
	fake.setTTLReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SetTTLReturnsOnCall(i int, result1 error) {
	fake.setTTLMutex.Lock()
	defer fake.setTTLMutex.Unlock()
	fake.SetTTLStub = nil
	if fake.setTTLReturnsOnCall == nil {
		fake.setTTLReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setTTLReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) Stat(arg1 string) (fs.FileInfo, error) {
	fake.statMutex.Lock()
	ret, specificReturn := fake.statReturnsOnCall[len(fake.statArgsForCall)]
	fake.statArgsForCall = append(fake.statArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StatStub
	fakeReturns := fake.statReturns
	fake.recordInvocation("Stat", []interface{}{arg1})
	fake.statMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) StatCallCount() int {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	return len(fake.statArgsForCall)
}

func (fake *FakeImpl) StatCalls(stub func(string) (fs.FileInfo, error)) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = stub
}

func (fake *FakeImpl) StatArgsForCall(i int) string {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	argsForCall := fake.statArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) StatReturns(result1 fs.FileInfo, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	fake.statReturns = struct {
		result1 fs.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) StatReturnsOnCall(i int, result1 fs.FileInfo, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	if fake.statReturnsOnCall == nil {
		fake.statReturnsOnCall = make(map[int]struct {
			result1 fs.FileInfo
			result2 error
		})
	}
	fake.statReturnsOnCall[i] = struct {
		result1 fs.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) TempFile(arg1 string, arg2 string) (*os.File, error) {
	fake.tempFileMutex.Lock()
	ret, specificReturn := fake.tempFileReturnsOnCall[len(fake.tempFileArgsForCall)]
	fake.tempFileArgsForCall = append(fake.tempFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.TempFileStub
	fakeReturns := fake.tempFileReturns
	fake.recordInvocation("TempFile", []interface{}{arg1, arg2})
	fake.tempFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) TempFileCallCount() int {
	fake.tempFileMutex.RLock()
	defer fake.tempFileMutex.RUnlock()
	return len(fake.tempFileArgsForCall)
}

func (fake *FakeImpl) TempFileCalls(stub func(string, string) (*os.File, error)) {
	fake.tempFileMutex.Lock()
	defer fake.tempFileMutex.Unlock()
	fake.TempFileStub = stub
}

func (fake *FakeImpl) TempFileArgsForCall(i int) (string, string) {
	fake.tempFileMutex.RLock()
	defer fake.tempFileMutex.RUnlock()
	argsForCall := fake.tempFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) TempFileReturns(result1 *os.File, result2 error) {
	fake.tempFileMutex.Lock()
	defer fake.tempFileMutex.Unlock()
	fake.TempFileStub = nil
	fake.tempFileReturns = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) TempFileReturnsOnCall(i int, result1 *os.File, result2 error) {
	fake.tempFileMutex.Lock()
	defer fake.tempFileMutex.Unlock()
	fake.TempFileStub = nil
	if fake.tempFileReturnsOnCall == nil {
		fake.tempFileReturnsOnCall = make(map[int]struct {
			result1 *os.File
			result2 error
		})
	}
	fake.tempFileReturnsOnCall[i] = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Uname(arg1 *syscall.Utsname) error {
	fake.unameMutex.Lock()
	ret, specificReturn := fake.unameReturnsOnCall[len(fake.unameArgsForCall)]
	fake.unameArgsForCall = append(fake.unameArgsForCall, struct {
		arg1 *syscall.Utsname
	}{arg1})
	stub := fake.UnameStub
	fakeReturns := fake.unameReturns
	fake.recordInvocation("Uname", []interface{}{arg1})
	fake.unameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) UnameCallCount() int {
	fake.unameMutex.RLock()
	defer fake.unameMutex.RUnlock()
	return len(fake.unameArgsForCall)
}

func (fake *FakeImpl) UnameCalls(stub func(*syscall.Utsname) error) {
	fake.unameMutex.Lock()
	defer fake.unameMutex.Unlock()
	fake.UnameStub = stub
}

func (fake *FakeImpl) UnameArgsForCall(i int) *syscall.Utsname {
	fake.unameMutex.RLock()
	defer fake.unameMutex.RUnlock()
	argsForCall := fake.unameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) UnameReturns(result1 error) {
	fake.unameMutex.Lock()
	defer fake.unameMutex.Unlock()
	fake.UnameStub = nil
	fake.unameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) UnameReturnsOnCall(i int, result1 error) {
	fake.unameMutex.Lock()
	defer fake.unameMutex.Unlock()
	fake.UnameStub = nil
	if fake.unameReturnsOnCall == nil {
		fake.unameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) Unmarshal(arg1 []byte, arg2 interface{}) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.unmarshalMutex.Lock()
	ret, specificReturn := fake.unmarshalReturnsOnCall[len(fake.unmarshalArgsForCall)]
	fake.unmarshalArgsForCall = append(fake.unmarshalArgsForCall, struct {
		arg1 []byte
		arg2 interface{}
	}{arg1Copy, arg2})
	stub := fake.UnmarshalStub
	fakeReturns := fake.unmarshalReturns
	fake.recordInvocation("Unmarshal", []interface{}{arg1Copy, arg2})
	fake.unmarshalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) UnmarshalCallCount() int {
	fake.unmarshalMutex.RLock()
	defer fake.unmarshalMutex.RUnlock()
	return len(fake.unmarshalArgsForCall)
}

func (fake *FakeImpl) UnmarshalCalls(stub func([]byte, interface{}) error) {
	fake.unmarshalMutex.Lock()
	defer fake.unmarshalMutex.Unlock()
	fake.UnmarshalStub = stub
}

func (fake *FakeImpl) UnmarshalArgsForCall(i int) ([]byte, interface{}) {
	fake.unmarshalMutex.RLock()
	defer fake.unmarshalMutex.RUnlock()
	argsForCall := fake.unmarshalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) UnmarshalReturns(result1 error) {
	fake.unmarshalMutex.Lock()
	defer fake.unmarshalMutex.Unlock()
	fake.UnmarshalStub = nil
	fake.unmarshalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) UnmarshalReturnsOnCall(i int, result1 error) {
	fake.unmarshalMutex.Lock()
	defer fake.unmarshalMutex.Unlock()
	fake.UnmarshalStub = nil
	if fake.unmarshalReturnsOnCall == nil {
		fake.unmarshalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unmarshalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) Write(arg1 *os.File, arg2 []byte) (int, error) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.writeMutex.Lock()
	ret, specificReturn := fake.writeReturnsOnCall[len(fake.writeArgsForCall)]
	fake.writeArgsForCall = append(fake.writeArgsForCall, struct {
		arg1 *os.File
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.WriteStub
	fakeReturns := fake.writeReturns
	fake.recordInvocation("Write", []interface{}{arg1, arg2Copy})
	fake.writeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) WriteCallCount() int {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	return len(fake.writeArgsForCall)
}

func (fake *FakeImpl) WriteCalls(stub func(*os.File, []byte) (int, error)) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = stub
}

func (fake *FakeImpl) WriteArgsForCall(i int) (*os.File, []byte) {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	argsForCall := fake.writeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) WriteReturns(result1 int, result2 error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = nil
	fake.writeReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) WriteReturnsOnCall(i int, result1 int, result2 error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = nil
	if fake.writeReturnsOnCall == nil {
		fake.writeReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.writeReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attachTracepointMutex.RLock()
	defer fake.attachTracepointMutex.RUnlock()
	fake.bPFLoadObjectMutex.RLock()
	defer fake.bPFLoadObjectMutex.RUnlock()
	fake.containerIDForPIDMutex.RLock()
	defer fake.containerIDForPIDMutex.RUnlock()
	fake.deleteKeyMutex.RLock()
	defer fake.deleteKeyMutex.RUnlock()
	fake.getMapMutex.RLock()
	defer fake.getMapMutex.RUnlock()
	fake.getNameMutex.RLock()
	defer fake.getNameMutex.RUnlock()
	fake.getProgramMutex.RLock()
	defer fake.getProgramMutex.RUnlock()
	fake.getValueMutex.RLock()
	defer fake.getValueMutex.RUnlock()
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	fake.inClusterConfigMutex.RLock()
	defer fake.inClusterConfigMutex.RUnlock()
	fake.initRingBufMutex.RLock()
	defer fake.initRingBufMutex.RUnlock()
	fake.listPodsMutex.RLock()
	defer fake.listPodsMutex.RUnlock()
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	fake.newForConfigMutex.RLock()
	defer fake.newForConfigMutex.RUnlock()
	fake.newModuleFromBufferArgsMutex.RLock()
	defer fake.newModuleFromBufferArgsMutex.RUnlock()
	fake.readOSReleaseMutex.RLock()
	defer fake.readOSReleaseMutex.RUnlock()
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	fake.setTTLMutex.RLock()
	defer fake.setTTLMutex.RUnlock()
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	fake.tempFileMutex.RLock()
	defer fake.tempFileMutex.RUnlock()
	fake.unameMutex.RLock()
	defer fake.unameMutex.RUnlock()
	fake.unmarshalMutex.RLock()
	defer fake.unmarshalMutex.RUnlock()
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeImpl) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
