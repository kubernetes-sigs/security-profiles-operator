//go:build linux && !no_bpf
// +build linux,!no_bpf

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by counterfeiter. DO NOT EDIT.
package bpfrecorderfakes

import (
	"context"
	"io/fs"
	"net"
	"os"
	"sync"
	"syscall"

	"github.com/aquasecurity/libbpfgo"
	ttlcache "github.com/jellydator/ttlcache/v3"
	seccomp "github.com/seccomp/libseccomp-golang"
	"google.golang.org/grpc"
	v1 "k8s.io/api/core/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	api_metrics "sigs.k8s.io/security-profiles-operator/api/grpc/metrics"
)

type FakeImpl struct {
	AttachGenericStub        func(*libbpfgo.BPFProg) (*libbpfgo.BPFLink, error)
	attachGenericMutex       sync.RWMutex
	attachGenericArgsForCall []struct {
		arg1 *libbpfgo.BPFProg
	}
	attachGenericReturns struct {
		result1 *libbpfgo.BPFLink
		result2 error
	}
	attachGenericReturnsOnCall map[int]struct {
		result1 *libbpfgo.BPFLink
		result2 error
	}
	BPFLoadObjectStub        func(*libbpfgo.Module) error
	bPFLoadObjectMutex       sync.RWMutex
	bPFLoadObjectArgsForCall []struct {
		arg1 *libbpfgo.Module
	}
	bPFLoadObjectReturns struct {
		result1 error
	}
	bPFLoadObjectReturnsOnCall map[int]struct {
		result1 error
	}
	BpfIncClientStub        func(api_metrics.MetricsClient) (api_metrics.Metrics_BpfIncClient, error)
	bpfIncClientMutex       sync.RWMutex
	bpfIncClientArgsForCall []struct {
		arg1 api_metrics.MetricsClient
	}
	bpfIncClientReturns struct {
		result1 api_metrics.Metrics_BpfIncClient
		result2 error
	}
	bpfIncClientReturnsOnCall map[int]struct {
		result1 api_metrics.Metrics_BpfIncClient
		result2 error
	}
	ChownStub        func(string, int, int) error
	chownMutex       sync.RWMutex
	chownArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	chownReturns struct {
		result1 error
	}
	chownReturnsOnCall map[int]struct {
		result1 error
	}
	CloseGRPCStub        func(*grpc.ClientConn) error
	closeGRPCMutex       sync.RWMutex
	closeGRPCArgsForCall []struct {
		arg1 *grpc.ClientConn
	}
	closeGRPCReturns struct {
		result1 error
	}
	closeGRPCReturnsOnCall map[int]struct {
		result1 error
	}
	CloseModuleStub        func(*libbpfgo.Module)
	closeModuleMutex       sync.RWMutex
	closeModuleArgsForCall []struct {
		arg1 *libbpfgo.Module
	}
	ContainerIDForPIDStub        func(*ttlcache.Cache[string, string], int) (string, error)
	containerIDForPIDMutex       sync.RWMutex
	containerIDForPIDArgsForCall []struct {
		arg1 *ttlcache.Cache[string, string]
		arg2 int
	}
	containerIDForPIDReturns struct {
		result1 string
		result2 error
	}
	containerIDForPIDReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DeleteKeyStub        func(*libbpfgo.BPFMap, uint32) error
	deleteKeyMutex       sync.RWMutex
	deleteKeyArgsForCall []struct {
		arg1 *libbpfgo.BPFMap
		arg2 uint32
	}
	deleteKeyReturns struct {
		result1 error
	}
	deleteKeyReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteKey64Stub        func(*libbpfgo.BPFMap, uint64) error
	deleteKey64Mutex       sync.RWMutex
	deleteKey64ArgsForCall []struct {
		arg1 *libbpfgo.BPFMap
		arg2 uint64
	}
	deleteKey64Returns struct {
		result1 error
	}
	deleteKey64ReturnsOnCall map[int]struct {
		result1 error
	}
	DialMetricsStub        func() (*grpc.ClientConn, context.CancelFunc, error)
	dialMetricsMutex       sync.RWMutex
	dialMetricsArgsForCall []struct {
	}
	dialMetricsReturns struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}
	dialMetricsReturnsOnCall map[int]struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}
	GetMapStub        func(*libbpfgo.Module, string) (*libbpfgo.BPFMap, error)
	getMapMutex       sync.RWMutex
	getMapArgsForCall []struct {
		arg1 *libbpfgo.Module
		arg2 string
	}
	getMapReturns struct {
		result1 *libbpfgo.BPFMap
		result2 error
	}
	getMapReturnsOnCall map[int]struct {
		result1 *libbpfgo.BPFMap
		result2 error
	}
	GetNameStub        func(seccomp.ScmpSyscall) (string, error)
	getNameMutex       sync.RWMutex
	getNameArgsForCall []struct {
		arg1 seccomp.ScmpSyscall
	}
	getNameReturns struct {
		result1 string
		result2 error
	}
	getNameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetProgramStub        func(*libbpfgo.Module, string) (*libbpfgo.BPFProg, error)
	getProgramMutex       sync.RWMutex
	getProgramArgsForCall []struct {
		arg1 *libbpfgo.Module
		arg2 string
	}
	getProgramReturns struct {
		result1 *libbpfgo.BPFProg
		result2 error
	}
	getProgramReturnsOnCall map[int]struct {
		result1 *libbpfgo.BPFProg
		result2 error
	}
	GetValueStub        func(*libbpfgo.BPFMap, uint32) ([]byte, error)
	getValueMutex       sync.RWMutex
	getValueArgsForCall []struct {
		arg1 *libbpfgo.BPFMap
		arg2 uint32
	}
	getValueReturns struct {
		result1 []byte
		result2 error
	}
	getValueReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetValue64Stub        func(*libbpfgo.BPFMap, uint64) ([]byte, error)
	getValue64Mutex       sync.RWMutex
	getValue64ArgsForCall []struct {
		arg1 *libbpfgo.BPFMap
		arg2 uint64
	}
	getValue64Returns struct {
		result1 []byte
		result2 error
	}
	getValue64ReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetenvStub        func(string) string
	getenvMutex       sync.RWMutex
	getenvArgsForCall []struct {
		arg1 string
	}
	getenvReturns struct {
		result1 string
	}
	getenvReturnsOnCall map[int]struct {
		result1 string
	}
	GoArchStub        func() string
	goArchMutex       sync.RWMutex
	goArchArgsForCall []struct {
	}
	goArchReturns struct {
		result1 string
	}
	goArchReturnsOnCall map[int]struct {
		result1 string
	}
	InClusterConfigStub        func() (*rest.Config, error)
	inClusterConfigMutex       sync.RWMutex
	inClusterConfigArgsForCall []struct {
	}
	inClusterConfigReturns struct {
		result1 *rest.Config
		result2 error
	}
	inClusterConfigReturnsOnCall map[int]struct {
		result1 *rest.Config
		result2 error
	}
	InitGlobalVariableStub        func(*libbpfgo.Module, string, interface{}) error
	initGlobalVariableMutex       sync.RWMutex
	initGlobalVariableArgsForCall []struct {
		arg1 *libbpfgo.Module
		arg2 string
		arg3 interface{}
	}
	initGlobalVariableReturns struct {
		result1 error
	}
	initGlobalVariableReturnsOnCall map[int]struct {
		result1 error
	}
	InitRingBufStub        func(*libbpfgo.Module, string, chan []byte) (*libbpfgo.RingBuffer, error)
	initRingBufMutex       sync.RWMutex
	initRingBufArgsForCall []struct {
		arg1 *libbpfgo.Module
		arg2 string
		arg3 chan []byte
	}
	initRingBufReturns struct {
		result1 *libbpfgo.RingBuffer
		result2 error
	}
	initRingBufReturnsOnCall map[int]struct {
		result1 *libbpfgo.RingBuffer
		result2 error
	}
	ListPodsStub        func(context.Context, *kubernetes.Clientset, string) (*v1.PodList, error)
	listPodsMutex       sync.RWMutex
	listPodsArgsForCall []struct {
		arg1 context.Context
		arg2 *kubernetes.Clientset
		arg3 string
	}
	listPodsReturns struct {
		result1 *v1.PodList
		result2 error
	}
	listPodsReturnsOnCall map[int]struct {
		result1 *v1.PodList
		result2 error
	}
	ListenStub        func(string, string) (net.Listener, error)
	listenMutex       sync.RWMutex
	listenArgsForCall []struct {
		arg1 string
		arg2 string
	}
	listenReturns struct {
		result1 net.Listener
		result2 error
	}
	listenReturnsOnCall map[int]struct {
		result1 net.Listener
		result2 error
	}
	NewForConfigStub        func(*rest.Config) (*kubernetes.Clientset, error)
	newForConfigMutex       sync.RWMutex
	newForConfigArgsForCall []struct {
		arg1 *rest.Config
	}
	newForConfigReturns struct {
		result1 *kubernetes.Clientset
		result2 error
	}
	newForConfigReturnsOnCall map[int]struct {
		result1 *kubernetes.Clientset
		result2 error
	}
	NewModuleFromBufferArgsStub        func(*libbpfgo.NewModuleArgs) (*libbpfgo.Module, error)
	newModuleFromBufferArgsMutex       sync.RWMutex
	newModuleFromBufferArgsArgsForCall []struct {
		arg1 *libbpfgo.NewModuleArgs
	}
	newModuleFromBufferArgsReturns struct {
		result1 *libbpfgo.Module
		result2 error
	}
	newModuleFromBufferArgsReturnsOnCall map[int]struct {
		result1 *libbpfgo.Module
		result2 error
	}
	ParseUintStub        func(string) (uint32, error)
	parseUintMutex       sync.RWMutex
	parseUintArgsForCall []struct {
		arg1 string
	}
	parseUintReturns struct {
		result1 uint32
		result2 error
	}
	parseUintReturnsOnCall map[int]struct {
		result1 uint32
		result2 error
	}
	PollRingBufferStub        func(*libbpfgo.RingBuffer, int)
	pollRingBufferMutex       sync.RWMutex
	pollRingBufferArgsForCall []struct {
		arg1 *libbpfgo.RingBuffer
		arg2 int
	}
	ReadOSReleaseStub        func() (map[string]string, error)
	readOSReleaseMutex       sync.RWMutex
	readOSReleaseArgsForCall []struct {
	}
	readOSReleaseReturns struct {
		result1 map[string]string
		result2 error
	}
	readOSReleaseReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	ReadlinkStub        func(string) (string, error)
	readlinkMutex       sync.RWMutex
	readlinkArgsForCall []struct {
		arg1 string
	}
	readlinkReturns struct {
		result1 string
		result2 error
	}
	readlinkReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	RemoveAllStub        func(string) error
	removeAllMutex       sync.RWMutex
	removeAllArgsForCall []struct {
		arg1 string
	}
	removeAllReturns struct {
		result1 error
	}
	removeAllReturnsOnCall map[int]struct {
		result1 error
	}
	SendMetricStub        func(api_metrics.Metrics_BpfIncClient, *api_metrics.BpfRequest) error
	sendMetricMutex       sync.RWMutex
	sendMetricArgsForCall []struct {
		arg1 api_metrics.Metrics_BpfIncClient
		arg2 *api_metrics.BpfRequest
	}
	sendMetricReturns struct {
		result1 error
	}
	sendMetricReturnsOnCall map[int]struct {
		result1 error
	}
	ServeStub        func(*grpc.Server, net.Listener) error
	serveMutex       sync.RWMutex
	serveArgsForCall []struct {
		arg1 *grpc.Server
		arg2 net.Listener
	}
	serveReturns struct {
		result1 error
	}
	serveReturnsOnCall map[int]struct {
		result1 error
	}
	StatStub        func(string) (fs.FileInfo, error)
	statMutex       sync.RWMutex
	statArgsForCall []struct {
		arg1 string
	}
	statReturns struct {
		result1 fs.FileInfo
		result2 error
	}
	statReturnsOnCall map[int]struct {
		result1 fs.FileInfo
		result2 error
	}
	TempFileStub        func(string, string) (*os.File, error)
	tempFileMutex       sync.RWMutex
	tempFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	tempFileReturns struct {
		result1 *os.File
		result2 error
	}
	tempFileReturnsOnCall map[int]struct {
		result1 *os.File
		result2 error
	}
	UnameStub        func(*syscall.Utsname) error
	unameMutex       sync.RWMutex
	unameArgsForCall []struct {
		arg1 *syscall.Utsname
	}
	unameReturns struct {
		result1 error
	}
	unameReturnsOnCall map[int]struct {
		result1 error
	}
	UnmarshalStub        func([]byte, interface{}) error
	unmarshalMutex       sync.RWMutex
	unmarshalArgsForCall []struct {
		arg1 []byte
		arg2 interface{}
	}
	unmarshalReturns struct {
		result1 error
	}
	unmarshalReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateValueStub        func(*libbpfgo.BPFMap, uint32, []byte) error
	updateValueMutex       sync.RWMutex
	updateValueArgsForCall []struct {
		arg1 *libbpfgo.BPFMap
		arg2 uint32
		arg3 []byte
	}
	updateValueReturns struct {
		result1 error
	}
	updateValueReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateValue64Stub        func(*libbpfgo.BPFMap, uint64, []byte) error
	updateValue64Mutex       sync.RWMutex
	updateValue64ArgsForCall []struct {
		arg1 *libbpfgo.BPFMap
		arg2 uint64
		arg3 []byte
	}
	updateValue64Returns struct {
		result1 error
	}
	updateValue64ReturnsOnCall map[int]struct {
		result1 error
	}
	WriteStub        func(*os.File, []byte) (int, error)
	writeMutex       sync.RWMutex
	writeArgsForCall []struct {
		arg1 *os.File
		arg2 []byte
	}
	writeReturns struct {
		result1 int
		result2 error
	}
	writeReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeImpl) AttachGeneric(arg1 *libbpfgo.BPFProg) (*libbpfgo.BPFLink, error) {
	fake.attachGenericMutex.Lock()
	ret, specificReturn := fake.attachGenericReturnsOnCall[len(fake.attachGenericArgsForCall)]
	fake.attachGenericArgsForCall = append(fake.attachGenericArgsForCall, struct {
		arg1 *libbpfgo.BPFProg
	}{arg1})
	stub := fake.AttachGenericStub
	fakeReturns := fake.attachGenericReturns
	fake.recordInvocation("AttachGeneric", []interface{}{arg1})
	fake.attachGenericMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) AttachGenericCallCount() int {
	fake.attachGenericMutex.RLock()
	defer fake.attachGenericMutex.RUnlock()
	return len(fake.attachGenericArgsForCall)
}

func (fake *FakeImpl) AttachGenericCalls(stub func(*libbpfgo.BPFProg) (*libbpfgo.BPFLink, error)) {
	fake.attachGenericMutex.Lock()
	defer fake.attachGenericMutex.Unlock()
	fake.AttachGenericStub = stub
}

func (fake *FakeImpl) AttachGenericArgsForCall(i int) *libbpfgo.BPFProg {
	fake.attachGenericMutex.RLock()
	defer fake.attachGenericMutex.RUnlock()
	argsForCall := fake.attachGenericArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) AttachGenericReturns(result1 *libbpfgo.BPFLink, result2 error) {
	fake.attachGenericMutex.Lock()
	defer fake.attachGenericMutex.Unlock()
	fake.AttachGenericStub = nil
	fake.attachGenericReturns = struct {
		result1 *libbpfgo.BPFLink
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) AttachGenericReturnsOnCall(i int, result1 *libbpfgo.BPFLink, result2 error) {
	fake.attachGenericMutex.Lock()
	defer fake.attachGenericMutex.Unlock()
	fake.AttachGenericStub = nil
	if fake.attachGenericReturnsOnCall == nil {
		fake.attachGenericReturnsOnCall = make(map[int]struct {
			result1 *libbpfgo.BPFLink
			result2 error
		})
	}
	fake.attachGenericReturnsOnCall[i] = struct {
		result1 *libbpfgo.BPFLink
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) BPFLoadObject(arg1 *libbpfgo.Module) error {
	fake.bPFLoadObjectMutex.Lock()
	ret, specificReturn := fake.bPFLoadObjectReturnsOnCall[len(fake.bPFLoadObjectArgsForCall)]
	fake.bPFLoadObjectArgsForCall = append(fake.bPFLoadObjectArgsForCall, struct {
		arg1 *libbpfgo.Module
	}{arg1})
	stub := fake.BPFLoadObjectStub
	fakeReturns := fake.bPFLoadObjectReturns
	fake.recordInvocation("BPFLoadObject", []interface{}{arg1})
	fake.bPFLoadObjectMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) BPFLoadObjectCallCount() int {
	fake.bPFLoadObjectMutex.RLock()
	defer fake.bPFLoadObjectMutex.RUnlock()
	return len(fake.bPFLoadObjectArgsForCall)
}

func (fake *FakeImpl) BPFLoadObjectCalls(stub func(*libbpfgo.Module) error) {
	fake.bPFLoadObjectMutex.Lock()
	defer fake.bPFLoadObjectMutex.Unlock()
	fake.BPFLoadObjectStub = stub
}

func (fake *FakeImpl) BPFLoadObjectArgsForCall(i int) *libbpfgo.Module {
	fake.bPFLoadObjectMutex.RLock()
	defer fake.bPFLoadObjectMutex.RUnlock()
	argsForCall := fake.bPFLoadObjectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) BPFLoadObjectReturns(result1 error) {
	fake.bPFLoadObjectMutex.Lock()
	defer fake.bPFLoadObjectMutex.Unlock()
	fake.BPFLoadObjectStub = nil
	fake.bPFLoadObjectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) BPFLoadObjectReturnsOnCall(i int, result1 error) {
	fake.bPFLoadObjectMutex.Lock()
	defer fake.bPFLoadObjectMutex.Unlock()
	fake.BPFLoadObjectStub = nil
	if fake.bPFLoadObjectReturnsOnCall == nil {
		fake.bPFLoadObjectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.bPFLoadObjectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) BpfIncClient(arg1 api_metrics.MetricsClient) (api_metrics.Metrics_BpfIncClient, error) {
	fake.bpfIncClientMutex.Lock()
	ret, specificReturn := fake.bpfIncClientReturnsOnCall[len(fake.bpfIncClientArgsForCall)]
	fake.bpfIncClientArgsForCall = append(fake.bpfIncClientArgsForCall, struct {
		arg1 api_metrics.MetricsClient
	}{arg1})
	stub := fake.BpfIncClientStub
	fakeReturns := fake.bpfIncClientReturns
	fake.recordInvocation("BpfIncClient", []interface{}{arg1})
	fake.bpfIncClientMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) BpfIncClientCallCount() int {
	fake.bpfIncClientMutex.RLock()
	defer fake.bpfIncClientMutex.RUnlock()
	return len(fake.bpfIncClientArgsForCall)
}

func (fake *FakeImpl) BpfIncClientCalls(stub func(api_metrics.MetricsClient) (api_metrics.Metrics_BpfIncClient, error)) {
	fake.bpfIncClientMutex.Lock()
	defer fake.bpfIncClientMutex.Unlock()
	fake.BpfIncClientStub = stub
}

func (fake *FakeImpl) BpfIncClientArgsForCall(i int) api_metrics.MetricsClient {
	fake.bpfIncClientMutex.RLock()
	defer fake.bpfIncClientMutex.RUnlock()
	argsForCall := fake.bpfIncClientArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) BpfIncClientReturns(result1 api_metrics.Metrics_BpfIncClient, result2 error) {
	fake.bpfIncClientMutex.Lock()
	defer fake.bpfIncClientMutex.Unlock()
	fake.BpfIncClientStub = nil
	fake.bpfIncClientReturns = struct {
		result1 api_metrics.Metrics_BpfIncClient
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) BpfIncClientReturnsOnCall(i int, result1 api_metrics.Metrics_BpfIncClient, result2 error) {
	fake.bpfIncClientMutex.Lock()
	defer fake.bpfIncClientMutex.Unlock()
	fake.BpfIncClientStub = nil
	if fake.bpfIncClientReturnsOnCall == nil {
		fake.bpfIncClientReturnsOnCall = make(map[int]struct {
			result1 api_metrics.Metrics_BpfIncClient
			result2 error
		})
	}
	fake.bpfIncClientReturnsOnCall[i] = struct {
		result1 api_metrics.Metrics_BpfIncClient
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Chown(arg1 string, arg2 int, arg3 int) error {
	fake.chownMutex.Lock()
	ret, specificReturn := fake.chownReturnsOnCall[len(fake.chownArgsForCall)]
	fake.chownArgsForCall = append(fake.chownArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.ChownStub
	fakeReturns := fake.chownReturns
	fake.recordInvocation("Chown", []interface{}{arg1, arg2, arg3})
	fake.chownMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) ChownCallCount() int {
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	return len(fake.chownArgsForCall)
}

func (fake *FakeImpl) ChownCalls(stub func(string, int, int) error) {
	fake.chownMutex.Lock()
	defer fake.chownMutex.Unlock()
	fake.ChownStub = stub
}

func (fake *FakeImpl) ChownArgsForCall(i int) (string, int, int) {
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	argsForCall := fake.chownArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) ChownReturns(result1 error) {
	fake.chownMutex.Lock()
	defer fake.chownMutex.Unlock()
	fake.ChownStub = nil
	fake.chownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) ChownReturnsOnCall(i int, result1 error) {
	fake.chownMutex.Lock()
	defer fake.chownMutex.Unlock()
	fake.ChownStub = nil
	if fake.chownReturnsOnCall == nil {
		fake.chownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) CloseGRPC(arg1 *grpc.ClientConn) error {
	fake.closeGRPCMutex.Lock()
	ret, specificReturn := fake.closeGRPCReturnsOnCall[len(fake.closeGRPCArgsForCall)]
	fake.closeGRPCArgsForCall = append(fake.closeGRPCArgsForCall, struct {
		arg1 *grpc.ClientConn
	}{arg1})
	stub := fake.CloseGRPCStub
	fakeReturns := fake.closeGRPCReturns
	fake.recordInvocation("CloseGRPC", []interface{}{arg1})
	fake.closeGRPCMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) CloseGRPCCallCount() int {
	fake.closeGRPCMutex.RLock()
	defer fake.closeGRPCMutex.RUnlock()
	return len(fake.closeGRPCArgsForCall)
}

func (fake *FakeImpl) CloseGRPCCalls(stub func(*grpc.ClientConn) error) {
	fake.closeGRPCMutex.Lock()
	defer fake.closeGRPCMutex.Unlock()
	fake.CloseGRPCStub = stub
}

func (fake *FakeImpl) CloseGRPCArgsForCall(i int) *grpc.ClientConn {
	fake.closeGRPCMutex.RLock()
	defer fake.closeGRPCMutex.RUnlock()
	argsForCall := fake.closeGRPCArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) CloseGRPCReturns(result1 error) {
	fake.closeGRPCMutex.Lock()
	defer fake.closeGRPCMutex.Unlock()
	fake.CloseGRPCStub = nil
	fake.closeGRPCReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) CloseGRPCReturnsOnCall(i int, result1 error) {
	fake.closeGRPCMutex.Lock()
	defer fake.closeGRPCMutex.Unlock()
	fake.CloseGRPCStub = nil
	if fake.closeGRPCReturnsOnCall == nil {
		fake.closeGRPCReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeGRPCReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) CloseModule(arg1 *libbpfgo.Module) {
	fake.closeModuleMutex.Lock()
	fake.closeModuleArgsForCall = append(fake.closeModuleArgsForCall, struct {
		arg1 *libbpfgo.Module
	}{arg1})
	stub := fake.CloseModuleStub
	fake.recordInvocation("CloseModule", []interface{}{arg1})
	fake.closeModuleMutex.Unlock()
	if stub != nil {
		fake.CloseModuleStub(arg1)
	}
}

func (fake *FakeImpl) CloseModuleCallCount() int {
	fake.closeModuleMutex.RLock()
	defer fake.closeModuleMutex.RUnlock()
	return len(fake.closeModuleArgsForCall)
}

func (fake *FakeImpl) CloseModuleCalls(stub func(*libbpfgo.Module)) {
	fake.closeModuleMutex.Lock()
	defer fake.closeModuleMutex.Unlock()
	fake.CloseModuleStub = stub
}

func (fake *FakeImpl) CloseModuleArgsForCall(i int) *libbpfgo.Module {
	fake.closeModuleMutex.RLock()
	defer fake.closeModuleMutex.RUnlock()
	argsForCall := fake.closeModuleArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) ContainerIDForPID(arg1 *ttlcache.Cache[string, string], arg2 int) (string, error) {
	fake.containerIDForPIDMutex.Lock()
	ret, specificReturn := fake.containerIDForPIDReturnsOnCall[len(fake.containerIDForPIDArgsForCall)]
	fake.containerIDForPIDArgsForCall = append(fake.containerIDForPIDArgsForCall, struct {
		arg1 *ttlcache.Cache[string, string]
		arg2 int
	}{arg1, arg2})
	stub := fake.ContainerIDForPIDStub
	fakeReturns := fake.containerIDForPIDReturns
	fake.recordInvocation("ContainerIDForPID", []interface{}{arg1, arg2})
	fake.containerIDForPIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ContainerIDForPIDCallCount() int {
	fake.containerIDForPIDMutex.RLock()
	defer fake.containerIDForPIDMutex.RUnlock()
	return len(fake.containerIDForPIDArgsForCall)
}

func (fake *FakeImpl) ContainerIDForPIDCalls(stub func(*ttlcache.Cache[string, string], int) (string, error)) {
	fake.containerIDForPIDMutex.Lock()
	defer fake.containerIDForPIDMutex.Unlock()
	fake.ContainerIDForPIDStub = stub
}

func (fake *FakeImpl) ContainerIDForPIDArgsForCall(i int) (*ttlcache.Cache[string, string], int) {
	fake.containerIDForPIDMutex.RLock()
	defer fake.containerIDForPIDMutex.RUnlock()
	argsForCall := fake.containerIDForPIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) ContainerIDForPIDReturns(result1 string, result2 error) {
	fake.containerIDForPIDMutex.Lock()
	defer fake.containerIDForPIDMutex.Unlock()
	fake.ContainerIDForPIDStub = nil
	fake.containerIDForPIDReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ContainerIDForPIDReturnsOnCall(i int, result1 string, result2 error) {
	fake.containerIDForPIDMutex.Lock()
	defer fake.containerIDForPIDMutex.Unlock()
	fake.ContainerIDForPIDStub = nil
	if fake.containerIDForPIDReturnsOnCall == nil {
		fake.containerIDForPIDReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.containerIDForPIDReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) DeleteKey(arg1 *libbpfgo.BPFMap, arg2 uint32) error {
	fake.deleteKeyMutex.Lock()
	ret, specificReturn := fake.deleteKeyReturnsOnCall[len(fake.deleteKeyArgsForCall)]
	fake.deleteKeyArgsForCall = append(fake.deleteKeyArgsForCall, struct {
		arg1 *libbpfgo.BPFMap
		arg2 uint32
	}{arg1, arg2})
	stub := fake.DeleteKeyStub
	fakeReturns := fake.deleteKeyReturns
	fake.recordInvocation("DeleteKey", []interface{}{arg1, arg2})
	fake.deleteKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) DeleteKeyCallCount() int {
	fake.deleteKeyMutex.RLock()
	defer fake.deleteKeyMutex.RUnlock()
	return len(fake.deleteKeyArgsForCall)
}

func (fake *FakeImpl) DeleteKeyCalls(stub func(*libbpfgo.BPFMap, uint32) error) {
	fake.deleteKeyMutex.Lock()
	defer fake.deleteKeyMutex.Unlock()
	fake.DeleteKeyStub = stub
}

func (fake *FakeImpl) DeleteKeyArgsForCall(i int) (*libbpfgo.BPFMap, uint32) {
	fake.deleteKeyMutex.RLock()
	defer fake.deleteKeyMutex.RUnlock()
	argsForCall := fake.deleteKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) DeleteKeyReturns(result1 error) {
	fake.deleteKeyMutex.Lock()
	defer fake.deleteKeyMutex.Unlock()
	fake.DeleteKeyStub = nil
	fake.deleteKeyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) DeleteKeyReturnsOnCall(i int, result1 error) {
	fake.deleteKeyMutex.Lock()
	defer fake.deleteKeyMutex.Unlock()
	fake.DeleteKeyStub = nil
	if fake.deleteKeyReturnsOnCall == nil {
		fake.deleteKeyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteKeyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) DeleteKey64(arg1 *libbpfgo.BPFMap, arg2 uint64) error {
	fake.deleteKey64Mutex.Lock()
	ret, specificReturn := fake.deleteKey64ReturnsOnCall[len(fake.deleteKey64ArgsForCall)]
	fake.deleteKey64ArgsForCall = append(fake.deleteKey64ArgsForCall, struct {
		arg1 *libbpfgo.BPFMap
		arg2 uint64
	}{arg1, arg2})
	stub := fake.DeleteKey64Stub
	fakeReturns := fake.deleteKey64Returns
	fake.recordInvocation("DeleteKey64", []interface{}{arg1, arg2})
	fake.deleteKey64Mutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) DeleteKey64CallCount() int {
	fake.deleteKey64Mutex.RLock()
	defer fake.deleteKey64Mutex.RUnlock()
	return len(fake.deleteKey64ArgsForCall)
}

func (fake *FakeImpl) DeleteKey64Calls(stub func(*libbpfgo.BPFMap, uint64) error) {
	fake.deleteKey64Mutex.Lock()
	defer fake.deleteKey64Mutex.Unlock()
	fake.DeleteKey64Stub = stub
}

func (fake *FakeImpl) DeleteKey64ArgsForCall(i int) (*libbpfgo.BPFMap, uint64) {
	fake.deleteKey64Mutex.RLock()
	defer fake.deleteKey64Mutex.RUnlock()
	argsForCall := fake.deleteKey64ArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) DeleteKey64Returns(result1 error) {
	fake.deleteKey64Mutex.Lock()
	defer fake.deleteKey64Mutex.Unlock()
	fake.DeleteKey64Stub = nil
	fake.deleteKey64Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) DeleteKey64ReturnsOnCall(i int, result1 error) {
	fake.deleteKey64Mutex.Lock()
	defer fake.deleteKey64Mutex.Unlock()
	fake.DeleteKey64Stub = nil
	if fake.deleteKey64ReturnsOnCall == nil {
		fake.deleteKey64ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteKey64ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) DialMetrics() (*grpc.ClientConn, context.CancelFunc, error) {
	fake.dialMetricsMutex.Lock()
	ret, specificReturn := fake.dialMetricsReturnsOnCall[len(fake.dialMetricsArgsForCall)]
	fake.dialMetricsArgsForCall = append(fake.dialMetricsArgsForCall, struct {
	}{})
	stub := fake.DialMetricsStub
	fakeReturns := fake.dialMetricsReturns
	fake.recordInvocation("DialMetrics", []interface{}{})
	fake.dialMetricsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeImpl) DialMetricsCallCount() int {
	fake.dialMetricsMutex.RLock()
	defer fake.dialMetricsMutex.RUnlock()
	return len(fake.dialMetricsArgsForCall)
}

func (fake *FakeImpl) DialMetricsCalls(stub func() (*grpc.ClientConn, context.CancelFunc, error)) {
	fake.dialMetricsMutex.Lock()
	defer fake.dialMetricsMutex.Unlock()
	fake.DialMetricsStub = stub
}

func (fake *FakeImpl) DialMetricsReturns(result1 *grpc.ClientConn, result2 context.CancelFunc, result3 error) {
	fake.dialMetricsMutex.Lock()
	defer fake.dialMetricsMutex.Unlock()
	fake.DialMetricsStub = nil
	fake.dialMetricsReturns = struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeImpl) DialMetricsReturnsOnCall(i int, result1 *grpc.ClientConn, result2 context.CancelFunc, result3 error) {
	fake.dialMetricsMutex.Lock()
	defer fake.dialMetricsMutex.Unlock()
	fake.DialMetricsStub = nil
	if fake.dialMetricsReturnsOnCall == nil {
		fake.dialMetricsReturnsOnCall = make(map[int]struct {
			result1 *grpc.ClientConn
			result2 context.CancelFunc
			result3 error
		})
	}
	fake.dialMetricsReturnsOnCall[i] = struct {
		result1 *grpc.ClientConn
		result2 context.CancelFunc
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeImpl) GetMap(arg1 *libbpfgo.Module, arg2 string) (*libbpfgo.BPFMap, error) {
	fake.getMapMutex.Lock()
	ret, specificReturn := fake.getMapReturnsOnCall[len(fake.getMapArgsForCall)]
	fake.getMapArgsForCall = append(fake.getMapArgsForCall, struct {
		arg1 *libbpfgo.Module
		arg2 string
	}{arg1, arg2})
	stub := fake.GetMapStub
	fakeReturns := fake.getMapReturns
	fake.recordInvocation("GetMap", []interface{}{arg1, arg2})
	fake.getMapMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) GetMapCallCount() int {
	fake.getMapMutex.RLock()
	defer fake.getMapMutex.RUnlock()
	return len(fake.getMapArgsForCall)
}

func (fake *FakeImpl) GetMapCalls(stub func(*libbpfgo.Module, string) (*libbpfgo.BPFMap, error)) {
	fake.getMapMutex.Lock()
	defer fake.getMapMutex.Unlock()
	fake.GetMapStub = stub
}

func (fake *FakeImpl) GetMapArgsForCall(i int) (*libbpfgo.Module, string) {
	fake.getMapMutex.RLock()
	defer fake.getMapMutex.RUnlock()
	argsForCall := fake.getMapArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) GetMapReturns(result1 *libbpfgo.BPFMap, result2 error) {
	fake.getMapMutex.Lock()
	defer fake.getMapMutex.Unlock()
	fake.GetMapStub = nil
	fake.getMapReturns = struct {
		result1 *libbpfgo.BPFMap
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetMapReturnsOnCall(i int, result1 *libbpfgo.BPFMap, result2 error) {
	fake.getMapMutex.Lock()
	defer fake.getMapMutex.Unlock()
	fake.GetMapStub = nil
	if fake.getMapReturnsOnCall == nil {
		fake.getMapReturnsOnCall = make(map[int]struct {
			result1 *libbpfgo.BPFMap
			result2 error
		})
	}
	fake.getMapReturnsOnCall[i] = struct {
		result1 *libbpfgo.BPFMap
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetName(arg1 seccomp.ScmpSyscall) (string, error) {
	fake.getNameMutex.Lock()
	ret, specificReturn := fake.getNameReturnsOnCall[len(fake.getNameArgsForCall)]
	fake.getNameArgsForCall = append(fake.getNameArgsForCall, struct {
		arg1 seccomp.ScmpSyscall
	}{arg1})
	stub := fake.GetNameStub
	fakeReturns := fake.getNameReturns
	fake.recordInvocation("GetName", []interface{}{arg1})
	fake.getNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) GetNameCallCount() int {
	fake.getNameMutex.RLock()
	defer fake.getNameMutex.RUnlock()
	return len(fake.getNameArgsForCall)
}

func (fake *FakeImpl) GetNameCalls(stub func(seccomp.ScmpSyscall) (string, error)) {
	fake.getNameMutex.Lock()
	defer fake.getNameMutex.Unlock()
	fake.GetNameStub = stub
}

func (fake *FakeImpl) GetNameArgsForCall(i int) seccomp.ScmpSyscall {
	fake.getNameMutex.RLock()
	defer fake.getNameMutex.RUnlock()
	argsForCall := fake.getNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) GetNameReturns(result1 string, result2 error) {
	fake.getNameMutex.Lock()
	defer fake.getNameMutex.Unlock()
	fake.GetNameStub = nil
	fake.getNameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetNameReturnsOnCall(i int, result1 string, result2 error) {
	fake.getNameMutex.Lock()
	defer fake.getNameMutex.Unlock()
	fake.GetNameStub = nil
	if fake.getNameReturnsOnCall == nil {
		fake.getNameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getNameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetProgram(arg1 *libbpfgo.Module, arg2 string) (*libbpfgo.BPFProg, error) {
	fake.getProgramMutex.Lock()
	ret, specificReturn := fake.getProgramReturnsOnCall[len(fake.getProgramArgsForCall)]
	fake.getProgramArgsForCall = append(fake.getProgramArgsForCall, struct {
		arg1 *libbpfgo.Module
		arg2 string
	}{arg1, arg2})
	stub := fake.GetProgramStub
	fakeReturns := fake.getProgramReturns
	fake.recordInvocation("GetProgram", []interface{}{arg1, arg2})
	fake.getProgramMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) GetProgramCallCount() int {
	fake.getProgramMutex.RLock()
	defer fake.getProgramMutex.RUnlock()
	return len(fake.getProgramArgsForCall)
}

func (fake *FakeImpl) GetProgramCalls(stub func(*libbpfgo.Module, string) (*libbpfgo.BPFProg, error)) {
	fake.getProgramMutex.Lock()
	defer fake.getProgramMutex.Unlock()
	fake.GetProgramStub = stub
}

func (fake *FakeImpl) GetProgramArgsForCall(i int) (*libbpfgo.Module, string) {
	fake.getProgramMutex.RLock()
	defer fake.getProgramMutex.RUnlock()
	argsForCall := fake.getProgramArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) GetProgramReturns(result1 *libbpfgo.BPFProg, result2 error) {
	fake.getProgramMutex.Lock()
	defer fake.getProgramMutex.Unlock()
	fake.GetProgramStub = nil
	fake.getProgramReturns = struct {
		result1 *libbpfgo.BPFProg
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetProgramReturnsOnCall(i int, result1 *libbpfgo.BPFProg, result2 error) {
	fake.getProgramMutex.Lock()
	defer fake.getProgramMutex.Unlock()
	fake.GetProgramStub = nil
	if fake.getProgramReturnsOnCall == nil {
		fake.getProgramReturnsOnCall = make(map[int]struct {
			result1 *libbpfgo.BPFProg
			result2 error
		})
	}
	fake.getProgramReturnsOnCall[i] = struct {
		result1 *libbpfgo.BPFProg
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetValue(arg1 *libbpfgo.BPFMap, arg2 uint32) ([]byte, error) {
	fake.getValueMutex.Lock()
	ret, specificReturn := fake.getValueReturnsOnCall[len(fake.getValueArgsForCall)]
	fake.getValueArgsForCall = append(fake.getValueArgsForCall, struct {
		arg1 *libbpfgo.BPFMap
		arg2 uint32
	}{arg1, arg2})
	stub := fake.GetValueStub
	fakeReturns := fake.getValueReturns
	fake.recordInvocation("GetValue", []interface{}{arg1, arg2})
	fake.getValueMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) GetValueCallCount() int {
	fake.getValueMutex.RLock()
	defer fake.getValueMutex.RUnlock()
	return len(fake.getValueArgsForCall)
}

func (fake *FakeImpl) GetValueCalls(stub func(*libbpfgo.BPFMap, uint32) ([]byte, error)) {
	fake.getValueMutex.Lock()
	defer fake.getValueMutex.Unlock()
	fake.GetValueStub = stub
}

func (fake *FakeImpl) GetValueArgsForCall(i int) (*libbpfgo.BPFMap, uint32) {
	fake.getValueMutex.RLock()
	defer fake.getValueMutex.RUnlock()
	argsForCall := fake.getValueArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) GetValueReturns(result1 []byte, result2 error) {
	fake.getValueMutex.Lock()
	defer fake.getValueMutex.Unlock()
	fake.GetValueStub = nil
	fake.getValueReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetValueReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.getValueMutex.Lock()
	defer fake.getValueMutex.Unlock()
	fake.GetValueStub = nil
	if fake.getValueReturnsOnCall == nil {
		fake.getValueReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getValueReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetValue64(arg1 *libbpfgo.BPFMap, arg2 uint64) ([]byte, error) {
	fake.getValue64Mutex.Lock()
	ret, specificReturn := fake.getValue64ReturnsOnCall[len(fake.getValue64ArgsForCall)]
	fake.getValue64ArgsForCall = append(fake.getValue64ArgsForCall, struct {
		arg1 *libbpfgo.BPFMap
		arg2 uint64
	}{arg1, arg2})
	stub := fake.GetValue64Stub
	fakeReturns := fake.getValue64Returns
	fake.recordInvocation("GetValue64", []interface{}{arg1, arg2})
	fake.getValue64Mutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) GetValue64CallCount() int {
	fake.getValue64Mutex.RLock()
	defer fake.getValue64Mutex.RUnlock()
	return len(fake.getValue64ArgsForCall)
}

func (fake *FakeImpl) GetValue64Calls(stub func(*libbpfgo.BPFMap, uint64) ([]byte, error)) {
	fake.getValue64Mutex.Lock()
	defer fake.getValue64Mutex.Unlock()
	fake.GetValue64Stub = stub
}

func (fake *FakeImpl) GetValue64ArgsForCall(i int) (*libbpfgo.BPFMap, uint64) {
	fake.getValue64Mutex.RLock()
	defer fake.getValue64Mutex.RUnlock()
	argsForCall := fake.getValue64ArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) GetValue64Returns(result1 []byte, result2 error) {
	fake.getValue64Mutex.Lock()
	defer fake.getValue64Mutex.Unlock()
	fake.GetValue64Stub = nil
	fake.getValue64Returns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) GetValue64ReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.getValue64Mutex.Lock()
	defer fake.getValue64Mutex.Unlock()
	fake.GetValue64Stub = nil
	if fake.getValue64ReturnsOnCall == nil {
		fake.getValue64ReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getValue64ReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Getenv(arg1 string) string {
	fake.getenvMutex.Lock()
	ret, specificReturn := fake.getenvReturnsOnCall[len(fake.getenvArgsForCall)]
	fake.getenvArgsForCall = append(fake.getenvArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetenvStub
	fakeReturns := fake.getenvReturns
	fake.recordInvocation("Getenv", []interface{}{arg1})
	fake.getenvMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) GetenvCallCount() int {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	return len(fake.getenvArgsForCall)
}

func (fake *FakeImpl) GetenvCalls(stub func(string) string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = stub
}

func (fake *FakeImpl) GetenvArgsForCall(i int) string {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	argsForCall := fake.getenvArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) GetenvReturns(result1 string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = nil
	fake.getenvReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeImpl) GetenvReturnsOnCall(i int, result1 string) {
	fake.getenvMutex.Lock()
	defer fake.getenvMutex.Unlock()
	fake.GetenvStub = nil
	if fake.getenvReturnsOnCall == nil {
		fake.getenvReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getenvReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeImpl) GoArch() string {
	fake.goArchMutex.Lock()
	ret, specificReturn := fake.goArchReturnsOnCall[len(fake.goArchArgsForCall)]
	fake.goArchArgsForCall = append(fake.goArchArgsForCall, struct {
	}{})
	stub := fake.GoArchStub
	fakeReturns := fake.goArchReturns
	fake.recordInvocation("GoArch", []interface{}{})
	fake.goArchMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) GoArchCallCount() int {
	fake.goArchMutex.RLock()
	defer fake.goArchMutex.RUnlock()
	return len(fake.goArchArgsForCall)
}

func (fake *FakeImpl) GoArchCalls(stub func() string) {
	fake.goArchMutex.Lock()
	defer fake.goArchMutex.Unlock()
	fake.GoArchStub = stub
}

func (fake *FakeImpl) GoArchReturns(result1 string) {
	fake.goArchMutex.Lock()
	defer fake.goArchMutex.Unlock()
	fake.GoArchStub = nil
	fake.goArchReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeImpl) GoArchReturnsOnCall(i int, result1 string) {
	fake.goArchMutex.Lock()
	defer fake.goArchMutex.Unlock()
	fake.GoArchStub = nil
	if fake.goArchReturnsOnCall == nil {
		fake.goArchReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.goArchReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeImpl) InClusterConfig() (*rest.Config, error) {
	fake.inClusterConfigMutex.Lock()
	ret, specificReturn := fake.inClusterConfigReturnsOnCall[len(fake.inClusterConfigArgsForCall)]
	fake.inClusterConfigArgsForCall = append(fake.inClusterConfigArgsForCall, struct {
	}{})
	stub := fake.InClusterConfigStub
	fakeReturns := fake.inClusterConfigReturns
	fake.recordInvocation("InClusterConfig", []interface{}{})
	fake.inClusterConfigMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) InClusterConfigCallCount() int {
	fake.inClusterConfigMutex.RLock()
	defer fake.inClusterConfigMutex.RUnlock()
	return len(fake.inClusterConfigArgsForCall)
}

func (fake *FakeImpl) InClusterConfigCalls(stub func() (*rest.Config, error)) {
	fake.inClusterConfigMutex.Lock()
	defer fake.inClusterConfigMutex.Unlock()
	fake.InClusterConfigStub = stub
}

func (fake *FakeImpl) InClusterConfigReturns(result1 *rest.Config, result2 error) {
	fake.inClusterConfigMutex.Lock()
	defer fake.inClusterConfigMutex.Unlock()
	fake.InClusterConfigStub = nil
	fake.inClusterConfigReturns = struct {
		result1 *rest.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) InClusterConfigReturnsOnCall(i int, result1 *rest.Config, result2 error) {
	fake.inClusterConfigMutex.Lock()
	defer fake.inClusterConfigMutex.Unlock()
	fake.InClusterConfigStub = nil
	if fake.inClusterConfigReturnsOnCall == nil {
		fake.inClusterConfigReturnsOnCall = make(map[int]struct {
			result1 *rest.Config
			result2 error
		})
	}
	fake.inClusterConfigReturnsOnCall[i] = struct {
		result1 *rest.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) InitGlobalVariable(arg1 *libbpfgo.Module, arg2 string, arg3 interface{}) error {
	fake.initGlobalVariableMutex.Lock()
	ret, specificReturn := fake.initGlobalVariableReturnsOnCall[len(fake.initGlobalVariableArgsForCall)]
	fake.initGlobalVariableArgsForCall = append(fake.initGlobalVariableArgsForCall, struct {
		arg1 *libbpfgo.Module
		arg2 string
		arg3 interface{}
	}{arg1, arg2, arg3})
	stub := fake.InitGlobalVariableStub
	fakeReturns := fake.initGlobalVariableReturns
	fake.recordInvocation("InitGlobalVariable", []interface{}{arg1, arg2, arg3})
	fake.initGlobalVariableMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) InitGlobalVariableCallCount() int {
	fake.initGlobalVariableMutex.RLock()
	defer fake.initGlobalVariableMutex.RUnlock()
	return len(fake.initGlobalVariableArgsForCall)
}

func (fake *FakeImpl) InitGlobalVariableCalls(stub func(*libbpfgo.Module, string, interface{}) error) {
	fake.initGlobalVariableMutex.Lock()
	defer fake.initGlobalVariableMutex.Unlock()
	fake.InitGlobalVariableStub = stub
}

func (fake *FakeImpl) InitGlobalVariableArgsForCall(i int) (*libbpfgo.Module, string, interface{}) {
	fake.initGlobalVariableMutex.RLock()
	defer fake.initGlobalVariableMutex.RUnlock()
	argsForCall := fake.initGlobalVariableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) InitGlobalVariableReturns(result1 error) {
	fake.initGlobalVariableMutex.Lock()
	defer fake.initGlobalVariableMutex.Unlock()
	fake.InitGlobalVariableStub = nil
	fake.initGlobalVariableReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) InitGlobalVariableReturnsOnCall(i int, result1 error) {
	fake.initGlobalVariableMutex.Lock()
	defer fake.initGlobalVariableMutex.Unlock()
	fake.InitGlobalVariableStub = nil
	if fake.initGlobalVariableReturnsOnCall == nil {
		fake.initGlobalVariableReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initGlobalVariableReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) InitRingBuf(arg1 *libbpfgo.Module, arg2 string, arg3 chan []byte) (*libbpfgo.RingBuffer, error) {
	fake.initRingBufMutex.Lock()
	ret, specificReturn := fake.initRingBufReturnsOnCall[len(fake.initRingBufArgsForCall)]
	fake.initRingBufArgsForCall = append(fake.initRingBufArgsForCall, struct {
		arg1 *libbpfgo.Module
		arg2 string
		arg3 chan []byte
	}{arg1, arg2, arg3})
	stub := fake.InitRingBufStub
	fakeReturns := fake.initRingBufReturns
	fake.recordInvocation("InitRingBuf", []interface{}{arg1, arg2, arg3})
	fake.initRingBufMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) InitRingBufCallCount() int {
	fake.initRingBufMutex.RLock()
	defer fake.initRingBufMutex.RUnlock()
	return len(fake.initRingBufArgsForCall)
}

func (fake *FakeImpl) InitRingBufCalls(stub func(*libbpfgo.Module, string, chan []byte) (*libbpfgo.RingBuffer, error)) {
	fake.initRingBufMutex.Lock()
	defer fake.initRingBufMutex.Unlock()
	fake.InitRingBufStub = stub
}

func (fake *FakeImpl) InitRingBufArgsForCall(i int) (*libbpfgo.Module, string, chan []byte) {
	fake.initRingBufMutex.RLock()
	defer fake.initRingBufMutex.RUnlock()
	argsForCall := fake.initRingBufArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) InitRingBufReturns(result1 *libbpfgo.RingBuffer, result2 error) {
	fake.initRingBufMutex.Lock()
	defer fake.initRingBufMutex.Unlock()
	fake.InitRingBufStub = nil
	fake.initRingBufReturns = struct {
		result1 *libbpfgo.RingBuffer
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) InitRingBufReturnsOnCall(i int, result1 *libbpfgo.RingBuffer, result2 error) {
	fake.initRingBufMutex.Lock()
	defer fake.initRingBufMutex.Unlock()
	fake.InitRingBufStub = nil
	if fake.initRingBufReturnsOnCall == nil {
		fake.initRingBufReturnsOnCall = make(map[int]struct {
			result1 *libbpfgo.RingBuffer
			result2 error
		})
	}
	fake.initRingBufReturnsOnCall[i] = struct {
		result1 *libbpfgo.RingBuffer
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ListPods(arg1 context.Context, arg2 *kubernetes.Clientset, arg3 string) (*v1.PodList, error) {
	fake.listPodsMutex.Lock()
	ret, specificReturn := fake.listPodsReturnsOnCall[len(fake.listPodsArgsForCall)]
	fake.listPodsArgsForCall = append(fake.listPodsArgsForCall, struct {
		arg1 context.Context
		arg2 *kubernetes.Clientset
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ListPodsStub
	fakeReturns := fake.listPodsReturns
	fake.recordInvocation("ListPods", []interface{}{arg1, arg2, arg3})
	fake.listPodsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ListPodsCallCount() int {
	fake.listPodsMutex.RLock()
	defer fake.listPodsMutex.RUnlock()
	return len(fake.listPodsArgsForCall)
}

func (fake *FakeImpl) ListPodsCalls(stub func(context.Context, *kubernetes.Clientset, string) (*v1.PodList, error)) {
	fake.listPodsMutex.Lock()
	defer fake.listPodsMutex.Unlock()
	fake.ListPodsStub = stub
}

func (fake *FakeImpl) ListPodsArgsForCall(i int) (context.Context, *kubernetes.Clientset, string) {
	fake.listPodsMutex.RLock()
	defer fake.listPodsMutex.RUnlock()
	argsForCall := fake.listPodsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) ListPodsReturns(result1 *v1.PodList, result2 error) {
	fake.listPodsMutex.Lock()
	defer fake.listPodsMutex.Unlock()
	fake.ListPodsStub = nil
	fake.listPodsReturns = struct {
		result1 *v1.PodList
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ListPodsReturnsOnCall(i int, result1 *v1.PodList, result2 error) {
	fake.listPodsMutex.Lock()
	defer fake.listPodsMutex.Unlock()
	fake.ListPodsStub = nil
	if fake.listPodsReturnsOnCall == nil {
		fake.listPodsReturnsOnCall = make(map[int]struct {
			result1 *v1.PodList
			result2 error
		})
	}
	fake.listPodsReturnsOnCall[i] = struct {
		result1 *v1.PodList
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Listen(arg1 string, arg2 string) (net.Listener, error) {
	fake.listenMutex.Lock()
	ret, specificReturn := fake.listenReturnsOnCall[len(fake.listenArgsForCall)]
	fake.listenArgsForCall = append(fake.listenArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ListenStub
	fakeReturns := fake.listenReturns
	fake.recordInvocation("Listen", []interface{}{arg1, arg2})
	fake.listenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ListenCallCount() int {
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	return len(fake.listenArgsForCall)
}

func (fake *FakeImpl) ListenCalls(stub func(string, string) (net.Listener, error)) {
	fake.listenMutex.Lock()
	defer fake.listenMutex.Unlock()
	fake.ListenStub = stub
}

func (fake *FakeImpl) ListenArgsForCall(i int) (string, string) {
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	argsForCall := fake.listenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) ListenReturns(result1 net.Listener, result2 error) {
	fake.listenMutex.Lock()
	defer fake.listenMutex.Unlock()
	fake.ListenStub = nil
	fake.listenReturns = struct {
		result1 net.Listener
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ListenReturnsOnCall(i int, result1 net.Listener, result2 error) {
	fake.listenMutex.Lock()
	defer fake.listenMutex.Unlock()
	fake.ListenStub = nil
	if fake.listenReturnsOnCall == nil {
		fake.listenReturnsOnCall = make(map[int]struct {
			result1 net.Listener
			result2 error
		})
	}
	fake.listenReturnsOnCall[i] = struct {
		result1 net.Listener
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewForConfig(arg1 *rest.Config) (*kubernetes.Clientset, error) {
	fake.newForConfigMutex.Lock()
	ret, specificReturn := fake.newForConfigReturnsOnCall[len(fake.newForConfigArgsForCall)]
	fake.newForConfigArgsForCall = append(fake.newForConfigArgsForCall, struct {
		arg1 *rest.Config
	}{arg1})
	stub := fake.NewForConfigStub
	fakeReturns := fake.newForConfigReturns
	fake.recordInvocation("NewForConfig", []interface{}{arg1})
	fake.newForConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) NewForConfigCallCount() int {
	fake.newForConfigMutex.RLock()
	defer fake.newForConfigMutex.RUnlock()
	return len(fake.newForConfigArgsForCall)
}

func (fake *FakeImpl) NewForConfigCalls(stub func(*rest.Config) (*kubernetes.Clientset, error)) {
	fake.newForConfigMutex.Lock()
	defer fake.newForConfigMutex.Unlock()
	fake.NewForConfigStub = stub
}

func (fake *FakeImpl) NewForConfigArgsForCall(i int) *rest.Config {
	fake.newForConfigMutex.RLock()
	defer fake.newForConfigMutex.RUnlock()
	argsForCall := fake.newForConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) NewForConfigReturns(result1 *kubernetes.Clientset, result2 error) {
	fake.newForConfigMutex.Lock()
	defer fake.newForConfigMutex.Unlock()
	fake.NewForConfigStub = nil
	fake.newForConfigReturns = struct {
		result1 *kubernetes.Clientset
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewForConfigReturnsOnCall(i int, result1 *kubernetes.Clientset, result2 error) {
	fake.newForConfigMutex.Lock()
	defer fake.newForConfigMutex.Unlock()
	fake.NewForConfigStub = nil
	if fake.newForConfigReturnsOnCall == nil {
		fake.newForConfigReturnsOnCall = make(map[int]struct {
			result1 *kubernetes.Clientset
			result2 error
		})
	}
	fake.newForConfigReturnsOnCall[i] = struct {
		result1 *kubernetes.Clientset
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewModuleFromBufferArgs(arg1 *libbpfgo.NewModuleArgs) (*libbpfgo.Module, error) {
	fake.newModuleFromBufferArgsMutex.Lock()
	ret, specificReturn := fake.newModuleFromBufferArgsReturnsOnCall[len(fake.newModuleFromBufferArgsArgsForCall)]
	fake.newModuleFromBufferArgsArgsForCall = append(fake.newModuleFromBufferArgsArgsForCall, struct {
		arg1 *libbpfgo.NewModuleArgs
	}{arg1})
	stub := fake.NewModuleFromBufferArgsStub
	fakeReturns := fake.newModuleFromBufferArgsReturns
	fake.recordInvocation("NewModuleFromBufferArgs", []interface{}{arg1})
	fake.newModuleFromBufferArgsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) NewModuleFromBufferArgsCallCount() int {
	fake.newModuleFromBufferArgsMutex.RLock()
	defer fake.newModuleFromBufferArgsMutex.RUnlock()
	return len(fake.newModuleFromBufferArgsArgsForCall)
}

func (fake *FakeImpl) NewModuleFromBufferArgsCalls(stub func(*libbpfgo.NewModuleArgs) (*libbpfgo.Module, error)) {
	fake.newModuleFromBufferArgsMutex.Lock()
	defer fake.newModuleFromBufferArgsMutex.Unlock()
	fake.NewModuleFromBufferArgsStub = stub
}

func (fake *FakeImpl) NewModuleFromBufferArgsArgsForCall(i int) *libbpfgo.NewModuleArgs {
	fake.newModuleFromBufferArgsMutex.RLock()
	defer fake.newModuleFromBufferArgsMutex.RUnlock()
	argsForCall := fake.newModuleFromBufferArgsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) NewModuleFromBufferArgsReturns(result1 *libbpfgo.Module, result2 error) {
	fake.newModuleFromBufferArgsMutex.Lock()
	defer fake.newModuleFromBufferArgsMutex.Unlock()
	fake.NewModuleFromBufferArgsStub = nil
	fake.newModuleFromBufferArgsReturns = struct {
		result1 *libbpfgo.Module
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) NewModuleFromBufferArgsReturnsOnCall(i int, result1 *libbpfgo.Module, result2 error) {
	fake.newModuleFromBufferArgsMutex.Lock()
	defer fake.newModuleFromBufferArgsMutex.Unlock()
	fake.NewModuleFromBufferArgsStub = nil
	if fake.newModuleFromBufferArgsReturnsOnCall == nil {
		fake.newModuleFromBufferArgsReturnsOnCall = make(map[int]struct {
			result1 *libbpfgo.Module
			result2 error
		})
	}
	fake.newModuleFromBufferArgsReturnsOnCall[i] = struct {
		result1 *libbpfgo.Module
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ParseUint(arg1 string) (uint32, error) {
	fake.parseUintMutex.Lock()
	ret, specificReturn := fake.parseUintReturnsOnCall[len(fake.parseUintArgsForCall)]
	fake.parseUintArgsForCall = append(fake.parseUintArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ParseUintStub
	fakeReturns := fake.parseUintReturns
	fake.recordInvocation("ParseUint", []interface{}{arg1})
	fake.parseUintMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ParseUintCallCount() int {
	fake.parseUintMutex.RLock()
	defer fake.parseUintMutex.RUnlock()
	return len(fake.parseUintArgsForCall)
}

func (fake *FakeImpl) ParseUintCalls(stub func(string) (uint32, error)) {
	fake.parseUintMutex.Lock()
	defer fake.parseUintMutex.Unlock()
	fake.ParseUintStub = stub
}

func (fake *FakeImpl) ParseUintArgsForCall(i int) string {
	fake.parseUintMutex.RLock()
	defer fake.parseUintMutex.RUnlock()
	argsForCall := fake.parseUintArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) ParseUintReturns(result1 uint32, result2 error) {
	fake.parseUintMutex.Lock()
	defer fake.parseUintMutex.Unlock()
	fake.ParseUintStub = nil
	fake.parseUintReturns = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ParseUintReturnsOnCall(i int, result1 uint32, result2 error) {
	fake.parseUintMutex.Lock()
	defer fake.parseUintMutex.Unlock()
	fake.ParseUintStub = nil
	if fake.parseUintReturnsOnCall == nil {
		fake.parseUintReturnsOnCall = make(map[int]struct {
			result1 uint32
			result2 error
		})
	}
	fake.parseUintReturnsOnCall[i] = struct {
		result1 uint32
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) PollRingBuffer(arg1 *libbpfgo.RingBuffer, arg2 int) {
	fake.pollRingBufferMutex.Lock()
	fake.pollRingBufferArgsForCall = append(fake.pollRingBufferArgsForCall, struct {
		arg1 *libbpfgo.RingBuffer
		arg2 int
	}{arg1, arg2})
	stub := fake.PollRingBufferStub
	fake.recordInvocation("PollRingBuffer", []interface{}{arg1, arg2})
	fake.pollRingBufferMutex.Unlock()
	if stub != nil {
		fake.PollRingBufferStub(arg1, arg2)
	}
}

func (fake *FakeImpl) PollRingBufferCallCount() int {
	fake.pollRingBufferMutex.RLock()
	defer fake.pollRingBufferMutex.RUnlock()
	return len(fake.pollRingBufferArgsForCall)
}

func (fake *FakeImpl) PollRingBufferCalls(stub func(*libbpfgo.RingBuffer, int)) {
	fake.pollRingBufferMutex.Lock()
	defer fake.pollRingBufferMutex.Unlock()
	fake.PollRingBufferStub = stub
}

func (fake *FakeImpl) PollRingBufferArgsForCall(i int) (*libbpfgo.RingBuffer, int) {
	fake.pollRingBufferMutex.RLock()
	defer fake.pollRingBufferMutex.RUnlock()
	argsForCall := fake.pollRingBufferArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) ReadOSRelease() (map[string]string, error) {
	fake.readOSReleaseMutex.Lock()
	ret, specificReturn := fake.readOSReleaseReturnsOnCall[len(fake.readOSReleaseArgsForCall)]
	fake.readOSReleaseArgsForCall = append(fake.readOSReleaseArgsForCall, struct {
	}{})
	stub := fake.ReadOSReleaseStub
	fakeReturns := fake.readOSReleaseReturns
	fake.recordInvocation("ReadOSRelease", []interface{}{})
	fake.readOSReleaseMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ReadOSReleaseCallCount() int {
	fake.readOSReleaseMutex.RLock()
	defer fake.readOSReleaseMutex.RUnlock()
	return len(fake.readOSReleaseArgsForCall)
}

func (fake *FakeImpl) ReadOSReleaseCalls(stub func() (map[string]string, error)) {
	fake.readOSReleaseMutex.Lock()
	defer fake.readOSReleaseMutex.Unlock()
	fake.ReadOSReleaseStub = stub
}

func (fake *FakeImpl) ReadOSReleaseReturns(result1 map[string]string, result2 error) {
	fake.readOSReleaseMutex.Lock()
	defer fake.readOSReleaseMutex.Unlock()
	fake.ReadOSReleaseStub = nil
	fake.readOSReleaseReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ReadOSReleaseReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.readOSReleaseMutex.Lock()
	defer fake.readOSReleaseMutex.Unlock()
	fake.ReadOSReleaseStub = nil
	if fake.readOSReleaseReturnsOnCall == nil {
		fake.readOSReleaseReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.readOSReleaseReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Readlink(arg1 string) (string, error) {
	fake.readlinkMutex.Lock()
	ret, specificReturn := fake.readlinkReturnsOnCall[len(fake.readlinkArgsForCall)]
	fake.readlinkArgsForCall = append(fake.readlinkArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadlinkStub
	fakeReturns := fake.readlinkReturns
	fake.recordInvocation("Readlink", []interface{}{arg1})
	fake.readlinkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) ReadlinkCallCount() int {
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	return len(fake.readlinkArgsForCall)
}

func (fake *FakeImpl) ReadlinkCalls(stub func(string) (string, error)) {
	fake.readlinkMutex.Lock()
	defer fake.readlinkMutex.Unlock()
	fake.ReadlinkStub = stub
}

func (fake *FakeImpl) ReadlinkArgsForCall(i int) string {
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	argsForCall := fake.readlinkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) ReadlinkReturns(result1 string, result2 error) {
	fake.readlinkMutex.Lock()
	defer fake.readlinkMutex.Unlock()
	fake.ReadlinkStub = nil
	fake.readlinkReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) ReadlinkReturnsOnCall(i int, result1 string, result2 error) {
	fake.readlinkMutex.Lock()
	defer fake.readlinkMutex.Unlock()
	fake.ReadlinkStub = nil
	if fake.readlinkReturnsOnCall == nil {
		fake.readlinkReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.readlinkReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) RemoveAll(arg1 string) error {
	fake.removeAllMutex.Lock()
	ret, specificReturn := fake.removeAllReturnsOnCall[len(fake.removeAllArgsForCall)]
	fake.removeAllArgsForCall = append(fake.removeAllArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveAllStub
	fakeReturns := fake.removeAllReturns
	fake.recordInvocation("RemoveAll", []interface{}{arg1})
	fake.removeAllMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) RemoveAllCallCount() int {
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	return len(fake.removeAllArgsForCall)
}

func (fake *FakeImpl) RemoveAllCalls(stub func(string) error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = stub
}

func (fake *FakeImpl) RemoveAllArgsForCall(i int) string {
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	argsForCall := fake.removeAllArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) RemoveAllReturns(result1 error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = nil
	fake.removeAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) RemoveAllReturnsOnCall(i int, result1 error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = nil
	if fake.removeAllReturnsOnCall == nil {
		fake.removeAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SendMetric(arg1 api_metrics.Metrics_BpfIncClient, arg2 *api_metrics.BpfRequest) error {
	fake.sendMetricMutex.Lock()
	ret, specificReturn := fake.sendMetricReturnsOnCall[len(fake.sendMetricArgsForCall)]
	fake.sendMetricArgsForCall = append(fake.sendMetricArgsForCall, struct {
		arg1 api_metrics.Metrics_BpfIncClient
		arg2 *api_metrics.BpfRequest
	}{arg1, arg2})
	stub := fake.SendMetricStub
	fakeReturns := fake.sendMetricReturns
	fake.recordInvocation("SendMetric", []interface{}{arg1, arg2})
	fake.sendMetricMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) SendMetricCallCount() int {
	fake.sendMetricMutex.RLock()
	defer fake.sendMetricMutex.RUnlock()
	return len(fake.sendMetricArgsForCall)
}

func (fake *FakeImpl) SendMetricCalls(stub func(api_metrics.Metrics_BpfIncClient, *api_metrics.BpfRequest) error) {
	fake.sendMetricMutex.Lock()
	defer fake.sendMetricMutex.Unlock()
	fake.SendMetricStub = stub
}

func (fake *FakeImpl) SendMetricArgsForCall(i int) (api_metrics.Metrics_BpfIncClient, *api_metrics.BpfRequest) {
	fake.sendMetricMutex.RLock()
	defer fake.sendMetricMutex.RUnlock()
	argsForCall := fake.sendMetricArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) SendMetricReturns(result1 error) {
	fake.sendMetricMutex.Lock()
	defer fake.sendMetricMutex.Unlock()
	fake.SendMetricStub = nil
	fake.sendMetricReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) SendMetricReturnsOnCall(i int, result1 error) {
	fake.sendMetricMutex.Lock()
	defer fake.sendMetricMutex.Unlock()
	fake.SendMetricStub = nil
	if fake.sendMetricReturnsOnCall == nil {
		fake.sendMetricReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendMetricReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) Serve(arg1 *grpc.Server, arg2 net.Listener) error {
	fake.serveMutex.Lock()
	ret, specificReturn := fake.serveReturnsOnCall[len(fake.serveArgsForCall)]
	fake.serveArgsForCall = append(fake.serveArgsForCall, struct {
		arg1 *grpc.Server
		arg2 net.Listener
	}{arg1, arg2})
	stub := fake.ServeStub
	fakeReturns := fake.serveReturns
	fake.recordInvocation("Serve", []interface{}{arg1, arg2})
	fake.serveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) ServeCallCount() int {
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	return len(fake.serveArgsForCall)
}

func (fake *FakeImpl) ServeCalls(stub func(*grpc.Server, net.Listener) error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = stub
}

func (fake *FakeImpl) ServeArgsForCall(i int) (*grpc.Server, net.Listener) {
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	argsForCall := fake.serveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) ServeReturns(result1 error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = nil
	fake.serveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) ServeReturnsOnCall(i int, result1 error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = nil
	if fake.serveReturnsOnCall == nil {
		fake.serveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) Stat(arg1 string) (fs.FileInfo, error) {
	fake.statMutex.Lock()
	ret, specificReturn := fake.statReturnsOnCall[len(fake.statArgsForCall)]
	fake.statArgsForCall = append(fake.statArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StatStub
	fakeReturns := fake.statReturns
	fake.recordInvocation("Stat", []interface{}{arg1})
	fake.statMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) StatCallCount() int {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	return len(fake.statArgsForCall)
}

func (fake *FakeImpl) StatCalls(stub func(string) (fs.FileInfo, error)) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = stub
}

func (fake *FakeImpl) StatArgsForCall(i int) string {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	argsForCall := fake.statArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) StatReturns(result1 fs.FileInfo, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	fake.statReturns = struct {
		result1 fs.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) StatReturnsOnCall(i int, result1 fs.FileInfo, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	if fake.statReturnsOnCall == nil {
		fake.statReturnsOnCall = make(map[int]struct {
			result1 fs.FileInfo
			result2 error
		})
	}
	fake.statReturnsOnCall[i] = struct {
		result1 fs.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) TempFile(arg1 string, arg2 string) (*os.File, error) {
	fake.tempFileMutex.Lock()
	ret, specificReturn := fake.tempFileReturnsOnCall[len(fake.tempFileArgsForCall)]
	fake.tempFileArgsForCall = append(fake.tempFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.TempFileStub
	fakeReturns := fake.tempFileReturns
	fake.recordInvocation("TempFile", []interface{}{arg1, arg2})
	fake.tempFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) TempFileCallCount() int {
	fake.tempFileMutex.RLock()
	defer fake.tempFileMutex.RUnlock()
	return len(fake.tempFileArgsForCall)
}

func (fake *FakeImpl) TempFileCalls(stub func(string, string) (*os.File, error)) {
	fake.tempFileMutex.Lock()
	defer fake.tempFileMutex.Unlock()
	fake.TempFileStub = stub
}

func (fake *FakeImpl) TempFileArgsForCall(i int) (string, string) {
	fake.tempFileMutex.RLock()
	defer fake.tempFileMutex.RUnlock()
	argsForCall := fake.tempFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) TempFileReturns(result1 *os.File, result2 error) {
	fake.tempFileMutex.Lock()
	defer fake.tempFileMutex.Unlock()
	fake.TempFileStub = nil
	fake.tempFileReturns = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) TempFileReturnsOnCall(i int, result1 *os.File, result2 error) {
	fake.tempFileMutex.Lock()
	defer fake.tempFileMutex.Unlock()
	fake.TempFileStub = nil
	if fake.tempFileReturnsOnCall == nil {
		fake.tempFileReturnsOnCall = make(map[int]struct {
			result1 *os.File
			result2 error
		})
	}
	fake.tempFileReturnsOnCall[i] = struct {
		result1 *os.File
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Uname(arg1 *syscall.Utsname) error {
	fake.unameMutex.Lock()
	ret, specificReturn := fake.unameReturnsOnCall[len(fake.unameArgsForCall)]
	fake.unameArgsForCall = append(fake.unameArgsForCall, struct {
		arg1 *syscall.Utsname
	}{arg1})
	stub := fake.UnameStub
	fakeReturns := fake.unameReturns
	fake.recordInvocation("Uname", []interface{}{arg1})
	fake.unameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) UnameCallCount() int {
	fake.unameMutex.RLock()
	defer fake.unameMutex.RUnlock()
	return len(fake.unameArgsForCall)
}

func (fake *FakeImpl) UnameCalls(stub func(*syscall.Utsname) error) {
	fake.unameMutex.Lock()
	defer fake.unameMutex.Unlock()
	fake.UnameStub = stub
}

func (fake *FakeImpl) UnameArgsForCall(i int) *syscall.Utsname {
	fake.unameMutex.RLock()
	defer fake.unameMutex.RUnlock()
	argsForCall := fake.unameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImpl) UnameReturns(result1 error) {
	fake.unameMutex.Lock()
	defer fake.unameMutex.Unlock()
	fake.UnameStub = nil
	fake.unameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) UnameReturnsOnCall(i int, result1 error) {
	fake.unameMutex.Lock()
	defer fake.unameMutex.Unlock()
	fake.UnameStub = nil
	if fake.unameReturnsOnCall == nil {
		fake.unameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) Unmarshal(arg1 []byte, arg2 interface{}) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.unmarshalMutex.Lock()
	ret, specificReturn := fake.unmarshalReturnsOnCall[len(fake.unmarshalArgsForCall)]
	fake.unmarshalArgsForCall = append(fake.unmarshalArgsForCall, struct {
		arg1 []byte
		arg2 interface{}
	}{arg1Copy, arg2})
	stub := fake.UnmarshalStub
	fakeReturns := fake.unmarshalReturns
	fake.recordInvocation("Unmarshal", []interface{}{arg1Copy, arg2})
	fake.unmarshalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) UnmarshalCallCount() int {
	fake.unmarshalMutex.RLock()
	defer fake.unmarshalMutex.RUnlock()
	return len(fake.unmarshalArgsForCall)
}

func (fake *FakeImpl) UnmarshalCalls(stub func([]byte, interface{}) error) {
	fake.unmarshalMutex.Lock()
	defer fake.unmarshalMutex.Unlock()
	fake.UnmarshalStub = stub
}

func (fake *FakeImpl) UnmarshalArgsForCall(i int) ([]byte, interface{}) {
	fake.unmarshalMutex.RLock()
	defer fake.unmarshalMutex.RUnlock()
	argsForCall := fake.unmarshalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) UnmarshalReturns(result1 error) {
	fake.unmarshalMutex.Lock()
	defer fake.unmarshalMutex.Unlock()
	fake.UnmarshalStub = nil
	fake.unmarshalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) UnmarshalReturnsOnCall(i int, result1 error) {
	fake.unmarshalMutex.Lock()
	defer fake.unmarshalMutex.Unlock()
	fake.UnmarshalStub = nil
	if fake.unmarshalReturnsOnCall == nil {
		fake.unmarshalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unmarshalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) UpdateValue(arg1 *libbpfgo.BPFMap, arg2 uint32, arg3 []byte) error {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.updateValueMutex.Lock()
	ret, specificReturn := fake.updateValueReturnsOnCall[len(fake.updateValueArgsForCall)]
	fake.updateValueArgsForCall = append(fake.updateValueArgsForCall, struct {
		arg1 *libbpfgo.BPFMap
		arg2 uint32
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	stub := fake.UpdateValueStub
	fakeReturns := fake.updateValueReturns
	fake.recordInvocation("UpdateValue", []interface{}{arg1, arg2, arg3Copy})
	fake.updateValueMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) UpdateValueCallCount() int {
	fake.updateValueMutex.RLock()
	defer fake.updateValueMutex.RUnlock()
	return len(fake.updateValueArgsForCall)
}

func (fake *FakeImpl) UpdateValueCalls(stub func(*libbpfgo.BPFMap, uint32, []byte) error) {
	fake.updateValueMutex.Lock()
	defer fake.updateValueMutex.Unlock()
	fake.UpdateValueStub = stub
}

func (fake *FakeImpl) UpdateValueArgsForCall(i int) (*libbpfgo.BPFMap, uint32, []byte) {
	fake.updateValueMutex.RLock()
	defer fake.updateValueMutex.RUnlock()
	argsForCall := fake.updateValueArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) UpdateValueReturns(result1 error) {
	fake.updateValueMutex.Lock()
	defer fake.updateValueMutex.Unlock()
	fake.UpdateValueStub = nil
	fake.updateValueReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) UpdateValueReturnsOnCall(i int, result1 error) {
	fake.updateValueMutex.Lock()
	defer fake.updateValueMutex.Unlock()
	fake.UpdateValueStub = nil
	if fake.updateValueReturnsOnCall == nil {
		fake.updateValueReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateValueReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) UpdateValue64(arg1 *libbpfgo.BPFMap, arg2 uint64, arg3 []byte) error {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.updateValue64Mutex.Lock()
	ret, specificReturn := fake.updateValue64ReturnsOnCall[len(fake.updateValue64ArgsForCall)]
	fake.updateValue64ArgsForCall = append(fake.updateValue64ArgsForCall, struct {
		arg1 *libbpfgo.BPFMap
		arg2 uint64
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	stub := fake.UpdateValue64Stub
	fakeReturns := fake.updateValue64Returns
	fake.recordInvocation("UpdateValue64", []interface{}{arg1, arg2, arg3Copy})
	fake.updateValue64Mutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImpl) UpdateValue64CallCount() int {
	fake.updateValue64Mutex.RLock()
	defer fake.updateValue64Mutex.RUnlock()
	return len(fake.updateValue64ArgsForCall)
}

func (fake *FakeImpl) UpdateValue64Calls(stub func(*libbpfgo.BPFMap, uint64, []byte) error) {
	fake.updateValue64Mutex.Lock()
	defer fake.updateValue64Mutex.Unlock()
	fake.UpdateValue64Stub = stub
}

func (fake *FakeImpl) UpdateValue64ArgsForCall(i int) (*libbpfgo.BPFMap, uint64, []byte) {
	fake.updateValue64Mutex.RLock()
	defer fake.updateValue64Mutex.RUnlock()
	argsForCall := fake.updateValue64ArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImpl) UpdateValue64Returns(result1 error) {
	fake.updateValue64Mutex.Lock()
	defer fake.updateValue64Mutex.Unlock()
	fake.UpdateValue64Stub = nil
	fake.updateValue64Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) UpdateValue64ReturnsOnCall(i int, result1 error) {
	fake.updateValue64Mutex.Lock()
	defer fake.updateValue64Mutex.Unlock()
	fake.UpdateValue64Stub = nil
	if fake.updateValue64ReturnsOnCall == nil {
		fake.updateValue64ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateValue64ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImpl) Write(arg1 *os.File, arg2 []byte) (int, error) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.writeMutex.Lock()
	ret, specificReturn := fake.writeReturnsOnCall[len(fake.writeArgsForCall)]
	fake.writeArgsForCall = append(fake.writeArgsForCall, struct {
		arg1 *os.File
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.WriteStub
	fakeReturns := fake.writeReturns
	fake.recordInvocation("Write", []interface{}{arg1, arg2Copy})
	fake.writeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImpl) WriteCallCount() int {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	return len(fake.writeArgsForCall)
}

func (fake *FakeImpl) WriteCalls(stub func(*os.File, []byte) (int, error)) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = stub
}

func (fake *FakeImpl) WriteArgsForCall(i int) (*os.File, []byte) {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	argsForCall := fake.writeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImpl) WriteReturns(result1 int, result2 error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = nil
	fake.writeReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) WriteReturnsOnCall(i int, result1 int, result2 error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = nil
	if fake.writeReturnsOnCall == nil {
		fake.writeReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.writeReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeImpl) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attachGenericMutex.RLock()
	defer fake.attachGenericMutex.RUnlock()
	fake.bPFLoadObjectMutex.RLock()
	defer fake.bPFLoadObjectMutex.RUnlock()
	fake.bpfIncClientMutex.RLock()
	defer fake.bpfIncClientMutex.RUnlock()
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	fake.closeGRPCMutex.RLock()
	defer fake.closeGRPCMutex.RUnlock()
	fake.closeModuleMutex.RLock()
	defer fake.closeModuleMutex.RUnlock()
	fake.containerIDForPIDMutex.RLock()
	defer fake.containerIDForPIDMutex.RUnlock()
	fake.deleteKeyMutex.RLock()
	defer fake.deleteKeyMutex.RUnlock()
	fake.deleteKey64Mutex.RLock()
	defer fake.deleteKey64Mutex.RUnlock()
	fake.dialMetricsMutex.RLock()
	defer fake.dialMetricsMutex.RUnlock()
	fake.getMapMutex.RLock()
	defer fake.getMapMutex.RUnlock()
	fake.getNameMutex.RLock()
	defer fake.getNameMutex.RUnlock()
	fake.getProgramMutex.RLock()
	defer fake.getProgramMutex.RUnlock()
	fake.getValueMutex.RLock()
	defer fake.getValueMutex.RUnlock()
	fake.getValue64Mutex.RLock()
	defer fake.getValue64Mutex.RUnlock()
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	fake.goArchMutex.RLock()
	defer fake.goArchMutex.RUnlock()
	fake.inClusterConfigMutex.RLock()
	defer fake.inClusterConfigMutex.RUnlock()
	fake.initGlobalVariableMutex.RLock()
	defer fake.initGlobalVariableMutex.RUnlock()
	fake.initRingBufMutex.RLock()
	defer fake.initRingBufMutex.RUnlock()
	fake.listPodsMutex.RLock()
	defer fake.listPodsMutex.RUnlock()
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	fake.newForConfigMutex.RLock()
	defer fake.newForConfigMutex.RUnlock()
	fake.newModuleFromBufferArgsMutex.RLock()
	defer fake.newModuleFromBufferArgsMutex.RUnlock()
	fake.parseUintMutex.RLock()
	defer fake.parseUintMutex.RUnlock()
	fake.pollRingBufferMutex.RLock()
	defer fake.pollRingBufferMutex.RUnlock()
	fake.readOSReleaseMutex.RLock()
	defer fake.readOSReleaseMutex.RUnlock()
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	fake.sendMetricMutex.RLock()
	defer fake.sendMetricMutex.RUnlock()
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	fake.tempFileMutex.RLock()
	defer fake.tempFileMutex.RUnlock()
	fake.unameMutex.RLock()
	defer fake.unameMutex.RUnlock()
	fake.unmarshalMutex.RLock()
	defer fake.unmarshalMutex.RUnlock()
	fake.updateValueMutex.RLock()
	defer fake.updateValueMutex.RUnlock()
	fake.updateValue64Mutex.RLock()
	defer fake.updateValue64Mutex.RUnlock()
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeImpl) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
